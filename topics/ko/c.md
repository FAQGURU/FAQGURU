## C#

[C#이란?](#C이란)

[C#에서 "continue" 및 "break" 문의 차이점은 무엇입니까?](#C에서-continue-및-break-문의-차이점은-무엇입니까)

[property Accessors란 무엇입니까?](#property-Accessors란-무엇입니까)

[Object란 무엇입니까?](#Object란-무엇입니까)

[C#에서 구조체와 클래스의 차이점은 무엇입니까?](#C에서-구조체와-클래스의-차이점은-무엇입니까)

[LINQ를 사용하여 목록에서 처음 3개의 짝수를 필터링합니다.](#LINQ를-사용하여-목록에서-처음-3개의-짝수를-필터링합니다)

[C#에서 enum은 무엇입니까?](#C에서-enum은-무엇입니까)

[예외 처리는 C#에서 어떻게 구현됩니까?](#예외-처리는-C에서-어떻게-구현됩니까)

[C#에서 "finally" 블록을 사용하는 이유는 무엇입니까?](#C에서-finally-블록을-사용하는-이유는-무엇입니까)

[C#에서 nullable 형식이란 무엇입니까?](#C에서-nullable-형식이란-무엇입니까)

[C#의 동적 유형 변수는 무엇입니까?](#C의-동적-유형-변수는-무엇입니까)

["this"를 정적 메서드 내에서 사용할 수 있습니까?](#this를-정적-메서드-내에서-사용할-수-있습니까)

[C#에서 속성을 정의하시겠습니까?](#C에서-속성을-정의하시겠습니까)

[관리 코드 또는 비관리 코드란 무엇입니까?](#관리-코드-또는-비관리-코드란-무엇입니까)

[C#의 참조 유형은 무엇입니까?](#C의-참조-유형은-무엇입니까)

[C#에서 namespace란 무엇입니까?](#C에서-namespace란-무엇입니까)

[C#에서 string과 StringBuilder의 차이점은 무엇입니까?](#C에서-string과-StringBuilder의-차이점은-무엇입니까)

[메소드에 매개변수를 전달할 수 있는 방법은 몇 가지입니까?](#메소드에-매개변수를-전달할-수-있는-방법은-몇-가지입니까)

[C#의 함수에서 여러 값을 반환할 수 있습니까?](#C의-함수에서-여러-값을-반환할-수-있습니까)

[partial classes은 무엇입니까?](#partial-classes은-무엇입니까)

[추상 클래스란 무엇입니까?](#추상-클래스란-무엇입니까)

[Boxing과 Unboxing이란?](#Boxing과-Unboxing이란)

[C#의 다양한 클래스 유형은 무엇입니까?](#C의-다양한-클래스-유형은-무엇입니까)

[인터페이스 내부의 메서드에 대한 접근성 한정자를 지정할 수 없는 이유는 무엇입니까?](#인터페이스-내부의-메서드에-대한-접근성-한정자를-지정할-수-없는-이유는-무엇입니까)

[사용자 지정 예외란 무엇입니까?](#사용자-지정-예외란-무엇입니까)

[여러 catch 블록을 실행할 수 있습니까?](#여러-catch-블록을-실행할-수-있습니까)

[C#에서 LINQ는 무엇입니까?](#C에서-LINQ는-무엇입니까)

[Serialization란?](#Serialization란)

[C#.Net의 값 유형 및 참조 유형으로 무엇을 이해합니까?](#CNet의-값-유형-및-참조-유형으로-무엇을-이해합니까)

[C#에서 제네릭이란 무엇입니까?](#C에서-제네릭이란-무엇입니까)

[ref와 out 키워드의 차이점은 무엇입니까?](#ref와-out-키워드의-차이점은-무엇입니까)

[C#에서 등호 연산자(==)와 Equals() 메서드의 차이점은 무엇입니까?](#C에서-등호-연산자와-Equals-메서드의-차이점은-무엇입니까)

[C#에서 Anonymous function란 무엇입니까?](#C에서-Anonymous-function란-무엇입니까)

[C#에서 lambda식은 무엇입니까?](#C에서-lambda식은-무엇입니까)

[인터페이스와 추상 클래스의 차이점은 무엇입니까?](#인터페이스와-추상-클래스의-차이점은-무엇입니까)

[C#에서 가상 메서드란 무엇입니까?](#C에서-가상-메서드란-무엇입니까)

[코드 리팩토링](#코드-리팩토링)

[아래 프로그램의 출력은 무엇입니까? 당신의 대답을 설명하십시오.](#아래-프로그램의-출력은-무엇입니까-당신의-대답을-설명하십시오)

[int 배열이 주어지면 짝수인 모든 값의 합계를 구하는 C# 메서드를 작성합니다.](#int-배열이-주어지면-짝수인-모든-값의-합계를-구하는-C-메서드를-작성합니다)

[C#에서 상수와 읽기 전용의 차이점은 무엇입니까?](#C에서-상수와-읽기-전용의-차이점은-무엇입니까)

[C#에서 "using"의 용도는 무엇입니까?](#C에서-using의-용도는-무엇입니까)

[C#에서 Null 병합 연산자(??)의 용도는 무엇입니까?](#C에서-Null-병합-연산자의-용도는-무엇입니까)

[C# 클래스의 내부 멤버 변수 범위는 무엇입니까?](#C-클래스의-내부-멤버-변수-범위는-무엇입니까)

[C#에서 Anonymous type 설명](#C에서-Anonymous-type-설명)

[throw 예외와 throw 절의 차이점은 무엇입니까?](#throw-예외와-throw-절의-차이점은-무엇입니까)

[C#.Net에서 리플렉션이란 무엇입니까?](#CNet에서-리플렉션이란-무엇입니까)

[캡슐화는 C#에서 어떻게 구현됩니까?](#캡슐화는-C에서-어떻게-구현됩니까)

[상수와 읽기 전용의 차이점은 무엇입니까?](#상수와-읽기-전용의-차이점은-무엇입니까)

[동적 유형 변수와 객체 유형 변수의 차이점은 무엇입니까?](#동적-유형-변수와-객체-유형-변수의-차이점은-무엇입니까)

[ C#의 확장 메서드는 무엇이며 어떻게 사용합니까?](#-C의-확장-메서드는-무엇이며-어떻게-사용합니까)

[C#에서 delegates란 무엇이며 delegates uses은 무엇입니까?](#C에서-delegates란-무엇이며-delegates-uses은-무엇입니까)

[C#에서 sealed class는 무엇입니까?](#C에서-sealed-class는-무엇입니까)

[오버로딩과 오버라이드의 차이점은 무엇입니까?](#오버로딩과-오버라이드의-차이점은-무엇입니까)

[C#의 코드 컴파일 설명](#C의-코드-컴파일-설명)

[Virtual method와 Abstract method의 차이점은 무엇입니까?](#Virtual-method와-Abstract-method의-차이점은-무엇입니까)

[C#에서 소멸자란 무엇입니까?](#C에서-소멸자란-무엇입니까)

[StackOverflowError와 OutOfMemoryError의 차이점은 무엇입니까?](#StackOverflowError와-OutOfMemoryError의-차이점은-무엇입니까)

[C#에서 late binding과 early binding의 차이점은 무엇입니까?](#C에서-late-binding과-early-binding의-차이점은-무엇입니까)

[메소드가 오버로드될 수 있는 다른 방법은 무엇입니까?](#메소드가-오버로드될-수-있는-다른-방법은-무엇입니까)

[C#에서 dispose와 finalize 메소드의 차이점은 무엇입니까?](#C에서-dispose와-finalize-메소드의-차이점은-무엇입니까)

[marshalling은 무엇이며 왜 필요한가?](#marshalling은-무엇이며-왜-필요한가)

[접근성 수정자 "protected internal"를 설명합니다.](#접근성-수정자-protected-internal를-설명합니다)

[C#의 포인터 유형은 무엇입니까?](#C의-포인터-유형은-무엇입니까)

[C#에서 다차원 배열과 배열의 차이점은 무엇입니까?](#C에서-다차원-배열과-배열의-차이점은-무엇입니까)

[C# 클래스의 Protected Internal 멤버 변수의 범위는 무엇입니까?](#C클래스의-Protected-Internal-멤버-변수의-범위는-무엇입니까)

[다양한 수의 인수를 허용할 수 있는 함수를 C#에서 만들 수 있습니까?](#다양한-수의-인수를-허용할-수-있는-함수를-C#에서-만들-수-있습니까)

[연산자 오버로딩이 C#에서 지원되나요?](#연산자-오버로딩이-C에서-지원되나요)

[C#에서 조건부 전처리기 지시문을 사용하는 방법은 무엇입니까?](#C에서-조건부-전처리기-지시문을-사용하는-방법은-무엇입니까)

[System.ApplicationException 클래스와 System.SystemException 클래스의 차이점은 무엇입니까?](#SystemApplicationException-클래스와-SystemSystemException-클래스의-차이점은-무엇입니까?)

[C#의 Indexer는 무엇입니까?](#C의-Indexer는-무엇입니까)

[C#에서 "catch" 블록 없이 "try" 블록만 가질 수 있습니까?](#C에서-catch-블록-없이-try-블록만-가질-수-있습니까)

[try 블록에 return 문을 추가하면 finally 블록이 C#에서 실행되는지 여부는?](#try-블록에-return-문을-추가하면-finally-블록이-C에서-실행되는지-여부는)

[C#에서 생성자 연결이란 무엇입니까?](#C에서-생성자-연결이란-무엇입니까)

[C#에서 delegates의 용도는 무엇입니까?](#C에서-delegates의-용도는-무엇입니까)

[C#에서 잠금 문을 사용하는 이유는 무엇입니까?](#C에서-잠금-문을-사용하는-이유는-무엇입니까)

[C#에서 다중 상속을 구현할 수 있습니까?](#C에서-다중-상속을-구현할-수-있습니까)

[아래 쇼트 프로그램의 결과는 무엇입니까? 당신의 대답을 설명하십시오](#아래-쇼트-프로그램의-결과는-무엇입니까-당신의-대답을-설명하십시오)

[아래 if 문에서 시간과 null의 비교가 유효한가요? 그 이유는?](#아래-if-문에서-시간과-null의-비교가-유효한가요-그-이유는)

[아래 프로그램의 출력은 무엇입니까? 당신의 대답을 설명하십시오.](#아래-프로그램의-출력은-무엇입니까-당신의-대답을-설명하십시오)

[아래 프로그램의 출력은 무엇입니까?](#아래-프로그램의-출력은-무엇입니까)

[C#에서 array[]보다 ArrayList를 언제 사용합니까?](#C에서-array보다-ArrayList를-언제-사용합니까)

[C#에서 사용되는 "yield" 키워드는 무엇입니까?](#C에서-사용되는-yield-키워드는-무엇입니까)

[.Net의 개체 풀이란 무엇입니까?](#Net의-개체-풀이란-무엇입니까)

["where" 메서드가 작동하려면 데이터 구조에서 어떤 인터페이스를 구현해야 합니까?](#where-메서드가-작동하려면-데이터-구조에서-어떤-인터페이스를-구현해야-합니까)

[IEnumerable vs List - 무엇을 사용할 것인가? 그들은 어떻게 작동합니까?](#IEnumerable-vs-List---무엇을-사용할-것인가-그들은-어떻게-작동합니까)

[C#에서 "is"와 "as" 연산자의 이름 차이](#C에서-is와-as-연산자의-이름-차이)

[Func<string,string>과 delegate의 차이점은 무엇입니까?](#Funcstringstring과-delegate의-차이점은-무엇입니까)

[Select와 Where의 차이점 설명](#Select와-Where의-차이점-설명)

[C#에서 단락 평가가 무엇인지 설명](#C에서-단락-평가가-무엇인지-설명)

[.Net에서 평등 검사를 위한 몇 가지 다른 방법 나열](#Net에서-평등-검사를-위한-몇-가지-다른-방법-나열)

[C#에서 멀티캐스트 delegate란 무엇입니까?](#C에서-멀티캐스트-delegate란-무엇입니까)

[C#.Net에서 jagged 배열이란 무엇이며 언제 다차원 배열보다 jagged 배열을 선호합니까?](#CNet에서-jagged-배열이란-무엇이며-언제-다차원-배열보다-jagged-배열을-선호합니까)

[C#에서 sealed 추상 클래스를 만들 수 있습니까?](#C에서-sealed-추상-클래스를-만들-수-있습니까)

[C#에서 deep copy 또는 shallow copy 개념이란 무엇입니까?](#C에서-deep-copy-또는-shallow-copy-개념이란-무엇입니까)

[C#에서 전처리기 지시문이란 무엇입니까?](#C-에서-전처리기-지시문이란-무엇입니까)

[소멸자, 폐기 및 종료 방법의 차이점을 설명할 수 있습니까?](#소멸자-폐기-및-종료-방법의-차이점을-설명할-수-있습니까)

[System.Array.CopyTo()와 System.Array.Clone()의 차이점은 무엇입니까?](#SystemArrayCopyTo와-SystemArrayClone의-차이점은-무엇입니까)

[LINQ에서 지연된 실행의 이점은 무엇입니까?](#LINQ에서-지연된-실행의-이점은-무엇입니까)

[MemberwiseClone() 메서드는 무엇을 합니까?](#MemberwiseClone-메서드는-무엇을-합니까)

[순환 참조란 무엇입니까?](#순환-참조란-무엇입니까)

[lambdas와 delegates의 차이점은 무엇입니까?](#lambdas와-delegates의-차이점은-무엇입니까)

[IEnumerable과 IQueryable의 차이점은 무엇입니까?](#IEnumerable과-IQueryable의-차이점은-무엇입니까)

[Func vs. Action vs. Predicate의 차이점을 설명해 주시겠습니까?](#Func-vs-Action-vs-Predicate의-차이점을-설명해-주시겠습니까)

[C#에서 약한 참조가 무엇인지 설명하십시오.](#C에서-약한-참조가-무엇인지-설명하십시오)

[IQueryable, ICollection, IList 및 IDictionary 인터페이스의 차이점을 설명하시겠습니까?](#IQueryable-ICollection-IList-및-IDictionary-인터페이스의-차이점을-설명하시겠습니까)

[ C#에서 확장 메서드가 있는 인터페이스 대신 추상 클래스를 사용해야 하는 경우는 언제입니까?](#-C에서-확장-메서드가-있는-인터페이스-대신-추상-클래스를-사용해야-하는-경우는-언제입니까)

[기존 정적 클래스에 확장 메서드를 추가할 수 있습니까?](#기존-정적-클래스에-확장-메서드를-추가할-수-있습니까)

[C#에서 "where" 메서드 구현](#C에서-where-메서드-구현)

["volatile" 키워드는 무엇에 사용됩니까?](#volatile-키워드는-무엇에-사용됩니까)

[원의 둘레를 계산](#원의-둘레를-계산)

[정적 생성자의 용도는 무엇입니까?](#정적-생성자의-용도는-무엇입니까)



### C#이란?

C#은 Microsoft .NET 응용 프로그램을 작성하기 위한 프로그래밍 언어입니다. C#은 C++의 강력한 기능을 통해 Visual Basic에서 볼 수 있는 빠른 응용 프로그램 개발을 제공합니다. 구문은 C++ 구문과 유사하며 다음과 같은 OOP 요구 사항을 100% 충족합니다.
* 추상화
* 캡슐화
* 다형성
* 상속

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### C#에서 "continue" 및 "break" 문의 차이점은 무엇입니까?

* **break** 문을 사용하면 루프에서 벗어날 수 있습니다.
* **continue** 문을 사용하면 한 반복을 건너뛰고 루프 실행을 재개할 수 있습니다.

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### property Accessors란 무엇입니까?

속성의 _get_ 및 _set_ 부분 또는 블록을 접근자라고 합니다. 이는 속성의 액세스 가능성을 제한하는 데 유용합니다. set 접근자는 속성의 개인 필드에 값을 할당할 수 있도록 지정하고 set 접근자 속성이 없으면 읽기 전용 필드와 같습니다. get 접근자를 통해 private 필드의 값에 액세스할 수 있습니다. 즉, 단일 값을 반환합니다. Get 접근자는 공개적으로 필드 값에 액세스할 수 있음을 지정합니다.

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### Object란 무엇입니까?

MSDN에 따르면 "_a 클래스 또는 구조체 정의는 유형이 수행할 수 있는 작업을 지정하는 청사진과 같습니다. 객체는 기본적으로 청사진에 따라 할당 및 구성된 메모리 블록입니다. 프로그램은 동일한 객체를 여러 개 생성할 수 있습니다. 개체는 인스턴스라고도 하며 명명된 변수나 배열 또는 컬렉션에 저장할 수 있습니다. 클라이언트 코드는 이러한 변수를 사용하여 메서드를 호출하고 개체의 공용 속성에 액세스하는 코드입니다. C#과 같은 지향 언어, 일반적인 프로그램은 동적으로 상호 작용하는 여러 개체로 구성됩니다."

개체는 점을 사용하여 필드, 메서드 또는 속성이 될 수 있는 클래스 또는 구조체의 멤버에 액세스하는 데 도움이 됩니다.

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### C#에서 구조체와 클래스의 차이점은 무엇입니까?

클래스와 구조체는 모두 사용자 정의 데이터 유형이지만 몇 가지 주요 차이점이 있습니다:
**  
구조체**

* 구조체는 C#의 값 형식이며 System.Value 형식에서 상속됩니다.
* Struct는 일반적으로 더 적은 양의 데이터에 사용됩니다.
* 구조체는 다른 유형으로 상속될 수 없습니다.
* 구조는 추상적일 수 없습니다.
* new 키워드로 객체를 생성할 필요가 없습니다.
* 기본 생성자를 만들 권한이 없습니다.

**클래스**

* 클래스는 C#의 참조 유형이며 System.Object 유형에서 상속됩니다.
* 클래스는 일반적으로 많은 양의 데이터에 사용됩니다.
* 클래스는 다른 클래스로 상속될 수 있습니다.
* 클래스는 추상 유형이 될 수 있습니다.
* new 키워드를 사용하여 클래스의 객체를 사용할 수 없습니다.
* 기본 생성자를 만들 수 있습니다.

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### LINQ를 사용하여 목록에서 처음 3개의 짝수를 필터링합니다.

```csharp
var evenNumbers = List
   .Where(x => x % 2 ==0)
   .Take(3)
```

###### Source

* https://medium.com/sears-israel/my-number-one-c-interview-question-39cdaac16c

[[↑] 맨 위로](#C)
### C#에서 enum(열거형)은 무엇입니까?

**enum**은 종종 열거자 목록이라고 하는 관련 명명된 상수 집합이 있는 값 유형입니다. enum 키워드는 열거형을 선언하는 데 사용됩니다. 사용자가 정의한 원시 데이터 유형입니다. 열거형은 .NET 프레임워크에서 숫자 상수를 만드는 데 사용됩니다. enum의 모든 멤버는 enum 유형입니다. 각 열거형 유형에 대한 숫자 값이어야 합니다.

**enum에 대한 몇 가지 사항**

* 열거형은 C#의 열거형 데이터 형식입니다.
* 열거형은 강력한 형식의 상수입니다. 강력한 형식이 지정됩니다. 즉, 해당 멤버의 기본 값이 동일하더라도 한 형식의 열거형이 다른 형식의 열거형에 암시적으로 할당되지 않을 수 있습니다.  
* 열거(열거)는 코드를 훨씬 더 읽기 쉽고 이해하기 쉽게 만듭니다.
* 열거형 값은 고정되어 있습니다. 열거형은 문자열로 표시하고 정수로 처리할 수 있습니다.
* 기본 유형은 int이고 승인된 유형은 byte, sbyte, short, ushort, uint, long, ulong입니다. 
* 모든 열거형 유형은 자동으로 System.Enum에서 파생되므로 열거형에서 System.Enum 메서드를 사용할 수 있습니다.
* 열거형은 값 유형이며 힙이 아닌 스택에서 생성됩니다.

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### 예외 처리는 C#에서 어떻게 구현됩니까?

예외 처리는 C#에서 4개의 키워드를 사용하여 수행됩니다:

*   **try** – 예외를 검사할 코드 블록을 포함합니다.
*   **catch** – 예외 핸들러의 도움으로 예외를 잡아내는 프로그램입니다.
*   **finally** – 예외가 발생했는지 여부에 관계없이 실행되도록 작성된 코드 블록입니다.
*   **Throw** – 문제가 발생하면 예외를 throw합니다.

###### Source

* https://www.softwaretestinghelp.com/c-sharp-interview-questions/

[[↑] 맨 위로](#C)
### C#에서 "finally" 블록을 사용하는 이유는 무엇입니까?

**Finally** 블록은 예외와 상관없이 실행됩니다. 따라서 예외가 발생하면 try 블록에서 코드를 실행하는 동안 catch 블록으로 제어가 반환되어 마침내 'finally' 블록이 실행됩니다. 따라서 데이터베이스 연결을 닫거나 파일 핸들러를 해제하는 것은 `finally` 블록에 보관할 수 있습니다.

###### Source

* http://a4academics.com/interview-questions/52-dot-net-interview-questions/417-c-oops-interview-questions-and-answers?showall=&start=1

[[↑] 맨 위로](#C)
### C#에서 nullable 형식이란 무엇입니까?

C#은 특수 데이터 형식인 **nullable types**을 제공하며 여기에는 일반적인 값 범위와 null 값을 할당할 수 있습니다.

예를 들어, -2,147,483,648에서 2,147,483,647 사이의 값이나 null을 `Nullable<Int32>` 변수에 저장할 수 있습니다. 마찬가지로 `Nullable<bool>` 변수에 true, false 또는 null을 할당할 수 있습니다.

###### Source

* https://www.tutorialspoint.com/csharp/csharp_interview_questions.htm

[[↑] 맨 위로](#C)
### C#의 동적 유형 변수는 무엇입니까?

동적 데이터 유형 변수에 모든 유형의 값을 저장할 수 있습니다. 이러한 유형의 변수에 대한 유형 검사는 런타임에 발생합니다.

###### Source

* https://www.tutorialspoint.com/csharp/csharp_interview_questions.htm

[[↑] 맨 위로](#C)
### "this"를 정적 메서드 내에서 사용할 수 있습니까?

키워드 _this_는 그것을 포함하는 클래스의 현재 인스턴스에 대한 참조를 반환하기 때문에 정적 메소드에서 _this_를 사용할 수 없습니다. 정적 메서드(또는 정적 멤버)는 특정 인스턴스에 속하지 않습니다. 클래스의 인스턴스를 생성하지 않고 존재하며 인스턴스가 아닌 클래스 이름으로 호출하므로 정적 메소드의 본문에서 이 키워드를 사용할 수 없지만 확장 메소드의 경우 함수 매개변수로 사용할 수 있습니다.

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### C#에서 속성을 정의하시겠습니까?

**Properties** 은 개인 필드의 값을 읽고, 쓰고, 계산하는 유연한 메커니즘을 제공하는 멤버입니다. 즉, 속성을 통해 개인 필드에 액세스할 수 있습니다. 다시 말해서 속성은 하나의 매개변수가 있거나 매개변수가 없는 반환 유형 함수/메서드라고 말할 수 있습니다. 이들은 항상 공개 데이터 멤버입니다. 접근자라고 하는 개인 필드에 액세스하고 값을 할당하는 메서드를 사용합니다.

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### 관리 코드 또는 비관리 코드란 무엇입니까?

* **Managed Code**  - .NET 프레임워크에서 개발된 코드를 관리 코드라고 합니다. 이 코드는 관리 코드 실행을 통해 CLR에서 직접 실행됩니다. .NET Framework로 작성된 모든 언어는 관리 코드입니다.
* **Unmanaged Code** - .NET 프레임워크 외부에서 개발된 코드를 비관리 코드라고 합니다. CLR의 제어 하에 실행되지 않는 응용 프로그램을 관리되지 않는 응용 프로그램이라고 하며, C++와 같은 특정 언어를 사용하여 이러한 응용 프로그램을 작성할 수 있습니다. 예를 들어 운영 체제의 하위 수준 기능에 액세스합니다. VB, ASP 및 COM 코드와의 백그라운드 호환성은 비관리 코드의 예입니다.


###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### C#의 참조 유형은 무엇입니까?

**reference types** 은 변수에 저장된 실제 데이터를 포함하지 않지만 변수에 대한 참조를 포함합니다.

즉, 메모리 위치를 나타냅니다. 여러 변수를 사용하여 참조 유형은 메모리 위치를 참조할 수 있습니다. 메모리 위치의 데이터가 변수 중 하나에 의해 변경되면 다른 변수는 이 값 변경을 자동으로 반영합니다. 기본 제공 참조 유형의 예는 객체, 동적 및 문자열입니다.

###### Source

* https://www.tutorialspoint.com/csharp/csharp_interview_questions.htm

[[↑] 맨 위로](#C)
### C#에서 namespace란 무엇입니까?

**namespace** 는 한 세트의 이름을 다른 세트와 분리하는 방법을 제공하기 위해 설계되었습니다. 한 네임스페이스에서 선언된 클래스 이름은 다른 네임스페이스에서 선언된 동일한 클래스 이름과 충돌하지 않습니다.

###### Source

* https://www.tutorialspoint.com/csharp/csharp_interview_questions.htm

[[↑] 맨 위로](#C)
### C#에서 string과 StringBuilder의 차이점은 무엇입니까?

**String**
* 문자열 값을 보유하는 변경할 수 없는 개체입니다.
* 새 인스턴스를 생성하여 이전 값을 재정의하거나 변경하기 때문에 성능 측면에서의 문자열 속도가 느립니다.
* 문자열은 시스템 네임스페이스에 속합니다.

**StringBuilder**
* StringBuilder는 변경 가능한 개체입니다.
* 성능 측면에서 StringBuilder는 StringBuilder 개체의 동일한 인스턴스를 사용하여 기존 문자열에 값 삽입과 같은 작업을 수행하기 때문에 매우 빠릅니다.
* StringBuilder는 System.Text.Stringbuilder 네임스페이스에 속합니다.

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### 메소드에 매개변수를 전달할 수 있는 방법은 몇 가지입니까?

매개 변수를 메서드에 전달할 수 있는 세 가지 방법이 있습니다:

*   **Value parameters** − 이 메서드는 인수의 실제 값을 함수의 형식 매개변수에 복사합니다. 이 경우 함수 내부의 매개변수에 대한 변경 사항은 인수에 영향을 미치지 않습니다.
*   **Reference parameters** − 이 메서드는 인수의 메모리 위치에 대한 참조를 형식 매개변수에 복사합니다. 이는 매개변수에 대한 변경 사항이 인수에 영향을 미친다는 것을 의미합니다.
*   **Output parameters** − 이 메서드는 둘 이상의 값을 반환하는 데 도움이 됩니다.

###### Source

* https://www.tutorialspoint.com/csharp/csharp_interview_questions.htm

[[↑] 맨 위로](#C)
### C#의 함수에서 여러 값을 반환할 수 있습니까?

네! 출력 매개변수 사용. return 문은 함수에서 하나의 값만 반환하는 데 사용할 수 있습니다. 그러나 출력 매개변수를 사용하면 함수에서 두 개의 값을 반환할 수 있습니다.

###### Source

* https://www.tutorialspoint.com/csharp/csharp_interview_questions.htm

[[↑] 맨 위로](#C)
### partial classes은 무엇입니까?

**partial** 클래스는 동일한 소스 코드 파일 또는 둘 이상의 소스 파일에서 둘 이상의 클래스에서 클래스 정의를 분할하는 데만 사용됩니다. 여러 파일에 클래스 정의를 만들 수 있지만 런타임에 하나의 클래스로 컴파일되고 이 클래스의 인스턴스를 만들 때도 동일한 개체를 사용하여 모든 소스 파일의 모든 메서드에 액세스할 수 있습니다. 부분 클래스는 동일한 네임스페이스에 생성할 수 있으며 다른 네임스페이스에 부분 클래스를 생성할 수 없습니다.

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### 추상 클래스 란 무엇입니까?

**Abstract class** 은 abstract 키워드로 표시되는 클래스로 Base 클래스로만 사용할 수 있습니다. Abstract 클래스는 항상 상속되어야 합니다. 클래스 자체의 인스턴스를 만들 수 없습니다. 어떤 프로그램이 클래스의 객체를 생성하는 것을 원하지 않는다면 그러한 클래스를 추상화할 수 있습니다.

추상 클래스의 모든 메서드에는 동일한 클래스에 구현이 없습니다. 그러나 자식 클래스에서 구현해야 합니다.

###### Source

* https://www.softwaretestinghelp.com/c-sharp-interview-questions/

[[↑] 맨 위로](#C)
### Boxing과 Unboxing이란?

Boxing과 Unboxing은 모두 유형 변환에 사용되지만 몇 가지 차이점이 있습니다.

* **Boxing** - Boxing은 값 유형 데이터 유형을 개체 또는 이 값 유형에 의해 구현되는 인터페이스 데이터 유형으로 변환하는 프로세스입니다. CLR이 값을 상자에 넣으면 CLR이 값 형식을 개체 형식으로 변환할 때 System.Object 내부에 값을 래핑하고 응용 프로그램 도메인의 힙 영역에 저장합니다.

* **Unboxing** - Unboxing은 객체 또는 구현된 인터페이스 유형에서 값 유형을 추출하는 데 사용되는 프로세스이기도 합니다. 박싱은 암시적으로 수행될 수 있지만 언박싱은 코드로 명시적이어야 합니다.

boxing 및 unboxing의 개념은 모든 형식의 값을 개체로 취급할 수 있는 형식 시스템의 C# 통합 보기를 강조합니다.

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### C#의 다양한 클래스 유형은 무엇입니까?

C#의 다양한 클래스 유형은 다음과 같습니다:

*   **Partial class** – 구성원을 여러 .cs 파일로 나누거나 공유할 수 있습니다. _Partial._ 키워드로 표시됩니다.
*   **Sealed class** – 상속할 수 없는 클래스입니다. 봉인된 클래스의 멤버에 액세스하려면 해당 클래스의 개체를 만들어야 합니다. _Sealed_ 키워드로 표시됩니다.
*   **Abstract class** – 개체를 인스턴스화할 수 없는 클래스입니다. 클래스는 상속만 가능합니다. 최소한 하나의 메소드를 포함해야 합니다. _abstract._ 키워드로 표시됩니다.
*   **Static class** – 상속을 허용하지 않는 클래스입니다. 클래스의 멤버도 정적입니다. _static_ 키워드로 표시됩니다. 이 키워드는 정적 클래스의 우발적인 인스턴스를 확인하도록 컴파일러에 지시합니다.

###### Source

* https://www.softwaretestinghelp.com/c-sharp-interview-questions/

[[↑] 맨 위로](#C)
### 인터페이스 내부의 메서드에 대한 접근성 한정자를 지정할 수 없는 이유는 무엇입니까?

인터페이스에는 메서드 정의가 없는 가상 메서드가 있습니다. 모든 메서드는 파생 클래스에서 재정의되어야 합니다. 그것이 그들이 모두 공개적인 이유입니다.

###### Source

* https://www.guru99.com/c-sharp-interview-questions.html

[[↑] 맨 위로](#C)
### 사용자 지정 예외란 무엇입니까?

때때로 사용자 요구 사항에 따라 처리해야 하는 몇 가지 오류가 있습니다. 사용자 정의 예외가 사용되며 정의된 예외로 사용됩니다.

###### Source

* https://www.guru99.com/c-sharp-interview-questions.html

[[↑] 맨 위로](#C)
### 여러 catch 블록을 실행할 수 있습니까?

아니요, 캐치 블록을 여러 개 실행할 수 없습니다. 일단 적절한 캐치 코드가 실행되면, 컨트롤은 최종 블록으로 전송되고 그 다음에 최종 블록을 따르는 코드가 실행된다.

###### Source

* https://www.guru99.com/c-sharp-interview-questions.html

[[↑] 맨 위로](#C)
### C#에서 LINQ는 무엇입니까?

**LINQ** 은 언어 통합 쿼리를 나타냅니다. LINQ는 모든 데이터 소스를 쿼리할 수 있는 강력한 기능을 가지고 있습니다. 데이터 소스는 개체, 데이터베이스 또는 XML 파일의 컬렉션일 수 있습니다. `IEnumerable<T>` 인터페이스를 구현하는 모든 개체에서 데이터를 쉽게 검색할 수 있습니다.

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### Serialization란?

**Serialization** 은 파일과 같은 보조 메모리에 개체의 상태를 저장하는 것을 의미합니다.

1.  바이너리 직렬화(객체 데이터를 바이너리 형식으로 저장).
2.  soap 직렬화(객체 데이터를 바이너리 형식으로 저장, 주로 네트워크 관련 통신에 사용).
3.  XmlSerialization(객체 데이터를 XML 파일로 저장).

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### C#.Net의 값 유형 및 참조 유형으로 무엇을 이해합니까?

C#에서 데이터 유형은 **값 유형**과 **참조 유형**의 두 가지 유형일 수 있습니다. 값 유형 변수에는 해당 개체(또는 데이터)가 직접 포함됩니다. 하나의 값 유형 변수를 다른 변수에 복사하면 실제로 두 번째 변수에 대한 개체의 복사본을 만드는 것입니다. 값 유형 멤버는 스택에 위치하며 참조 멤버는 항상 힙에 위치합니다.

###### Source

* https://stackoverflow.com/questions/412813/when-to-use-arraylist-over-array-in-c

[[↑] 맨 위로](#C)
### C#에서 제네릭이란 무엇입니까?

**Generics** 은 프로그램에서 실제로 사용될 때까지 클래스나 메서드에서 프로그래밍 요소의 데이터 유형 지정을 지연할 수 있습니다. 다시 말해, 제네릭을 사용하면 모든 데이터 유형에서 작동할 수 있는 클래스 또는 메서드를 작성할 수 있습니다.

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### ref와 out 키워드의 차이점은 무엇입니까?

* **out**은 키워드는 인수가 참조로 전달되도록 합니다. 이것은 ref가 전달되기 전에 변수 _be를 초기화해야 한다는 점을 제외하고는 ref 키워드와 유사합니다.
* **ref** 키워드는 인수가 값이 아닌 참조로 전달되도록 합니다. 참조로 전달하면 메서드의 매개변수에 대한 모든 변경 사항이 호출 메서드의 기본 인수 변수에 반영됩니다.


###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### C#에서 등호 연산자(==)와 Equals() 메서드의 차이점은 무엇입니까?

== 연산자(일반적으로 ReferenceEquals와 동일함, 재정의될 수 있음)는 참조 ID를 비교하는 반면 Equals()(가상 Equals()) 메서드는 두 개체가 동일한지 비교합니다.

###### Source

* https://stackoverflow.com/questions/3191969/5-ways-for-equality-check-in-net-why-and-which-to-use

[[↑] 맨 위로](#C)
### C#에서 Anonymous function란 무엇입니까?

**anonymous function**은 대리자 형식이 예상되는 모든 위치에서 사용할 수 있는 "인라인" 문 또는 식입니다. 이를 사용하여 명명된 대리자를 초기화하거나 명명된 대리자 형식 대신 메서드 매개 변수로 전달할 수 있습니다.

anonymous function에는 두 가지 종류가 있습니다:

* 람다 표현식
* Anonymous Methods

Consider:
```csharp
// Original delegate syntax required 
// initialization with a named method.
TestDelegate testDelA = new TestDelegate(M);

// C# 2.0: A delegate can be initialized with
// inline code, called an "anonymous method." This
// method takes a string as an input parameter.
TestDelegate testDelB = delegate(string s) {
 Console.WriteLine(s);
};

// C# 3.0. A delegate can be initialized with
// a lambda expression. The lambda also takes a string
// as an input parameter (x). The type of x is inferred by the compiler.
TestDelegate testDelC = (x) => {
 Console.WriteLine(x);
};

// Invoke the delegates.
testDelA("Hello. My name is M and I write lines.");
testDelB("That's nothing. I'm anonymous and ");
testDelC("I'm a famous author.");
```

###### Source

* https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/anonymous-functions

[[↑] 맨 위로](#C)
### C#에서 lambda식은 무엇입니까?

**lambda expression**는 대리자 또는 _expression tree_ 유형을 만드는 데 사용할 수 있는 익명 함수입니다. 람다 식을 사용하여 인수로 전달되거나 함수 호출의 값으로 반환될 수 있는 로컬 함수를 작성할 수 있습니다. 람다 식은 LINQ 쿼리 식을 작성할 때 특히 유용합니다.

###### Source

* https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/lambda-expressions

[[↑] 맨 위로](#C)
### 인터페이스와 추상 클래스의 차이점은 무엇입니까?

**추상 클래스**와 **인터페이스** 사이에는 다음과 같은 몇 가지 차이점이 있습니다.

* 클래스는 여러 인터페이스를 구현할 수 있지만 하위 클래스는 기껏해야 하나의 추상 클래스만 사용할 수 있습니다. 
* 추상 클래스는 비추상 메서드(구체 메서드)를 가질 수 있지만 인터페이스의 경우 모든 메서드는 추상이어야 합니다.
* 추상 클래스는 인터페이스가 허용되지 않는 동안 모든 변수를 선언하거나 사용할 수 있습니다.
* 추상 클래스에서 모든 데이터 멤버 또는 함수는 기본적으로 비공개이고 인터페이스에서는 모두 공개이므로 수동으로 변경할 수 없습니다.
* 추상 클래스에서는 추상 메서드를 선언하기 위해 추상 키워드를 사용해야 하는 반면 인터페이스에서는 사용할 필요가 없습니다.
* 추상 클래스는 다중 상속에 사용할 수 없지만 인터페이스는 다중 상속으로 사용할 수 있습니다.
* 추상 클래스는 생성자를 사용하지만 인터페이스에는 생성자 유형이 없습니다.

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### C#에서 가상 메서드란 무엇입니까?

가상 메서드는 파생 클래스에서 재정의할 수 있는 메서드입니다. 가상 메서드는 파생 클래스뿐만 아니라 기본 클래스에서도 구현됩니다. 가상 메서드가 호출되면 개체의 런타임 형식에서 재정의 멤버가 있는지 확인합니다.

1.  기본적으로 메서드는 가상이 아닙니다. 비가상 메서드를 재정의할 수 없습니다. 
2.  정적, 추상, 개인 또는 재정의 수정자와 함께 가상 수정자를 사용할 수 없습니다.

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### 코드 리팩토링

`this` 키워드는 다른 생성자를 호출하여 클래스 객체를 초기화하는 데 사용됩니다. 다음은 구현을 보여줍니다.

```csharp
class ClassA
{
  public ClassA() : this(10)
  { }

  public ClassA(int pValue)
  {  }
}
```

###### Source

* https://www.toptal.com/c-sharp/interview-questions

[[↑] 맨 위로](#C)
### 아래 프로그램의 출력은 무엇입니까? 당신의 대답을 설명하십시오.

이 프로그램은 숫자 10을 10번 출력합니다.

이유는 다음과 같습니다. 대리자가 for 루프에 추가되고 값 자체보다는 `i`에 대한 "참조"(또는 "포인터"가 더 나은 단어 선택일 수 있음)가 저장됩니다. 따라서 루프를 종료한 후 변수 `i`는 10으로 설정되었으므로 각 대리자가 호출될 때까지 모두에게 전달된 값은 10입니다.

###### Source

* https://www.toptal.com/c-sharp/interview-questions

[[↑] 맨 위로](#C)
### int 배열이 주어지면 짝수인 모든 값의 합계를 구하는 C# 메서드를 작성합니다.

```csharp
static long TotalAllEvenNumbers(int[] intArray) {
  return intArray.Where(i => i % 2 == 0).Sum(i => (long)i);
}
```
or
```csharp
static long TotalAllEvenNumbers(int[] intArray) {
  return (from i in intArray where i % 2 == 0 select (long)i).Sum();
}
```

###### Source

* https://www.toptal.com/c-sharp/interview-questions

[[↑] 맨 위로](#C)
### C#에서 상수와 읽기 전용의 차이점은 무엇입니까?

**Const**(const) 및 **Readonly **(readonly) 둘 다 용도에 따라 같아 보이지만 몇 가지 차이점이 있습니다.

* **Constant **은 C#에서 "const" 키워드로 알려져 있으며 이는 컴파일 시간에 알려지고 응용 프로그램이 실행될 때까지 응용 프로그램의 수명 동안 응용 프로그램의 수명 동안 어떤 함수나 생성자와 같이 런타임에 값을 변경하지 않는 불변 값으로도 알려져 있습니다.

* **Readonly** 은 C#에서 "읽기 전용" 키워드로 알려져 있으며 이는 변경할 수 없는 값으로도 알려져 있으며 컴파일 및 런타임에 알려져 있으며 응용 프로그램이 실행될 때까지 응용 프로그램의 수명 동안 다른 함수와 같이 런타임에 값을 변경하지 않습니다. "new" 키워드로 생성자를 호출할 때 생성자별로 값을 분석할 수 있습니다.

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### C#에서 "using"의 용도는 무엇입니까?

using 문을 사용하는 이유는 개체가 범위를 벗어나는 즉시 삭제되고(IDisposable 호출) 이러한 일이 발생하도록 하기 위해 명시적 코드가 필요하지 않도록 하기 위함입니다.

The .NET CLR converts:
```csharp
using (MyResource myRes = new MyResource())
{
    myRes.DoSomething();
}
```
to:
```csharp
{ // Limits scope of myRes
    MyResource myRes= new MyResource();
    try
    {
        myRes.DoSomething();
    }
    finally
    {
        // Check for a null resource.
        if (myRes != null)
            // Call the object's Dispose method.
            ((IDisposable)myRes).Dispose();
    }
}
```

###### Source

* https://stackoverflow.com/questions/75401/what-are-the-uses-of-using-in-c-sharp

[[↑] 맨 위로](#C)
### C#에서 Null 병합 연산자(??)의 용도는 무엇입니까?

**??** 연산자는 **null-coalescing operator**라고 하며 nullable 값 유형 또는 참조 유형에 대한 기본값을 정의하는 데 사용됩니다. 피연산자가 null이 아니면 왼쪽 피연산자를 반환합니다. 그렇지 않으면 오른쪽 피연산자를 반환합니다.

```csharp
string name = null;  
string myname = name ?? "Laxmi";  
Console.WriteLine(myname);  
```

###### Source

* https://www.tutorialspoint.com/csharp/csharp_interview_questions.htm

[[↑] 맨 위로](#C)
### C# 클래스의 내부 멤버 변수 범위는 무엇입니까?

**Internal** 액세스 지정자는 클래스가 _현재 어셈블리_의 다른 함수 및 개체에 해당 멤버 변수 및 멤버 함수를 노출할 수 있도록 합니다. 즉, 내부 액세스 지정자가 있는 모든 멤버는 해당 멤버가 정의된 응용 프로그램 내에 정의된 모든 클래스 또는 메서드에서 액세스할 수 있습니다.


###### Source

* https://www.tutorialspoint.com/csharp/csharp_interview_questions.htm

[[↑] 맨 위로](#C)
### C#에서 Anonymous type 설명

**Anonymous types** 을 사용하면 정의하지 않고 새 유형을 만들 수 있습니다. 이것은 유형을 명시적으로 정의하지 않고 단일 객체에 읽기 전용 속성을 정의하는 방법입니다. 여기서 Type은 컴파일러에 의해 생성되며 현재 코드 블록에 대해서만 액세스할 수 있습니다. 속성 유형은 컴파일러에서도 유추됩니다.

Consider:
```csharp
var anonymousData = new
{  
     ForeName = "Jignesh",  
     SurName = "Trivedi"
};  

Console.WriteLine("First Name : " + anonymousData.ForeName); 
```

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### throw 예외와 throw 절의 차이점은 무엇입니까?

* 기본적인 차이점은 **Throw exception**이 스택 추적을 덮어쓰므로 예외를 throw한 원래 코드 줄 번호를 찾기가 어렵습니다.
* **Throw**는 스택 정보를 유지하고 throw된 예외의 스택 정보에 추가합니다.

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### C#.Net에서 리플렉션이란 무엇입니까?

**Reflection** 은 동적 방식으로 유형 시스템을 쿼리하고 상호 작용하는 기능입니다. 일반적으로 리플렉션을 사용하면 개체에 대한 메타데이터에 액세스할 수 있습니다. 예를 들어 DLL을 로드하고 인터페이스 구현이 포함되어 있는지 확인할 수 있습니다. 이것을 사용하여 런타임에 기능을 지원하는 dll을 찾을 수 있습니다. 이를 사용하여 다시 컴파일하거나 다시 시작할 필요 없이 응용 프로그램을 확장할 수 있습니다.

###### Source

* https://stackoverflow.com/questions/1859902/in-3-minutes-what-is-reflection

[[↑] 맨 위로](#C)
### 캡슐화는 C#에서 어떻게 구현됩니까?

**캡슐화**는 **액세스 지정자**를 사용하여 구현됩니다. 액세스 지정자는 클래스 멤버의 범위와 가시성을 정의합니다.

* **Public** 접근 지정자는 클래스가 자신의 멤버 변수와 멤버 함수를 다른 함수와 객체에 노출할 수 있도록 합니다. 모든 public 멤버는 클래스 외부에서 액세스할 수 있습니다.
* **Private** 접근 지정자는 클래스가 자신의 멤버 변수와 멤버 함수를 다른 함수와 객체로부터 숨길 수 있도록 합니다. 같은 클래스의 함수만 private 멤버에 액세스할 수 있습니다. 클래스의 인스턴스라도 private 멤버에 액세스할 수 없습니다.
* **Protected**  액세스 지정자는 자식 클래스가 기본 클래스의 멤버 변수 및 멤버 함수에 액세스할 수 있도록 합니다. 이렇게 하면 상속을 구현하는 데 도움이 됩니다.


###### Source

* https://www.tutorialspoint.com/csharp/csharp_interview_questions.htm

[[↑] 맨 위로](#C)
### 상수와 읽기 전용의 차이점은 무엇입니까?

상수 변수는 컴파일 타임에 선언되고 초기화됩니다. 값은 나중에 변경할 수 없습니다. Readonly는 런타임에 값을 할당하려는 경우에만 사용됩니다.

###### Source

* https://www.guru99.com/c-sharp-interview-questions.html

[[↑] 맨 위로](#C)
### 동적 유형 변수와 객체 유형 변수의 차이점은 무엇입니까?

동적 유형은 개체 유형 변수에 대한 유형 검사가 컴파일 시간에 발생하는 반면 동적 유형 변수에 대한 유형 검사는 런타임에 발생한다는 점을 제외하고는 개체 유형과 유사합니다.

###### Source

* https://www.tutorialspoint.com/csharp/csharp_interview_questions.htm

[[↑] 맨 위로](#C)
###  C#의 확장 메서드는 무엇이며 어떻게 사용합니까?

**Extension methods** 을 사용하면 새 파생 형식을 만들거나, 다시 컴파일하거나, 원래 형식을 수정하지 않고도 기존 형식에 메서드를 추가할 수 있습니다. 확장 메소드는 특별한 종류의 정적 메소드이지만 확장 유형의 인스턴스 메소드인 것처럼 호출됩니다.

```csharp
namespace ExtensionMethods
{
    public static class MyExtensions
    {
        public static int WordCount(this String str)
        {
            return str.Split(new char[] { ' ', '.', '?' }, 
                             StringSplitOptions.RemoveEmptyEntries).Length;
        }
    }   
}
```

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### C#에서 delegates란 무엇이며 delegates uses은 무엇입니까?

C# 대리자는 C 또는 C++에서 함수에 대한 포인터와 동일합니다. 대리자 개체는 메서드에 대한 참조를 유지하는 데 사용하는 참조 형식 변수입니다. 참조는 델리게이트의 객체에 의해 유지되는 런타임에 변경될 수 있습니다. 델리게이트 개체는 시퀀스 FIFO의 함수를 참조하는 호출 목록이라고도 하는 많은 함수 참조를 보유할 수 있습니다. 런타임에 이 목록에서 새로운 기능을 참조할 수 있습니다. += 연산자를 사용하고 -= 연산자로 제거할 수 있습니다.

대리자는 특히 이벤트 및 콜백 메서드를 구현하는 데 사용됩니다. 모든 대리자는 System.Delegate 클래스에서 암시적으로 파생됩니다.

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### C#에서 sealed class는 무엇입니까?

**Sealed** 클래스는 객체 지향 프로그래밍의 상속 기능을 제한하는 데 사용됩니다. 클래스가 봉인된 클래스로 정의되면 클래스를 상속할 수 없습니다.
 
구조체도 밀봉됩니다. 구조체에서 클래스를 파생시킬 수 없습니다.

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### 오버로딩과 오버라이드의 차이점은 무엇입니까?

* **Overloading** 은 같은 범위에 이름은 같지만 서명이 다른 여러 메서드가 있는 경우입니다.

```csharp
//Overloading
public class test
{
    public void getStuff(int id)
    {}
    public void getStuff(string name)
    {}
}
```
* **Overriding** 자식 클래스에서 메서드의 기능을 변경할 수 있도록 하는 원리입니다.

```csharp
//Overriding
public class test
{
        public virtual void getStuff(int id)
        {
            //Get stuff default location
        }
}

public class test2 : test
{
        public override void getStuff(int id)
        {
            //base.getStuff(id);
            //or - Get stuff new location
        }
}
```

###### Source

* https://stackoverflow.com/questions/673721/overloading-and-overriding

[[↑] 맨 위로](#C)
### C#의 코드 컴파일 설명

코드 컴파일에는 다음과 같은 4단계가 있습니다:

*   소스 코드를 C# 컴파일러로 관리 코드로 컴파일합니다.
*   새로 생성된 코드를 어셈블리로 결합합니다.
*   CLR(공용 언어 런타임)을 로드합니다.
*   CLR로 어셈블리를 실행합니다.

###### Source

* https://www.softwaretestinghelp.com/c-sharp-interview-questions/

[[↑] 맨 위로](#C)
### Virtual method와 Abstract method의 차이점은 무엇입니까?

* **Virtual method** 은 항상 기본 구현이 있어야 합니다. 그러나 필수는 아니지만 파생 클래스에서 재정의할 수 있습니다. _override_ 키워드를 사용하여 재정의할 수 있습니다.
* **Abstract method** 은 구현이 없습니다. 추상 클래스에 있습니다. 파생 클래스가 추상 메서드를 구현하는 것은 필수입니다. _override_ 키워드는 사용할 수 있지만 여기에는 필요하지 않습니다.

###### Source

* https://www.softwaretestinghelp.com/c-sharp-interview-questions/

[[↑] 맨 위로](#C)
### C#에서 소멸자란 무엇입니까?

**Destructor** 메모리를 정리하고 리소스를 해제하는 데 사용됩니다. 그러나 C#에서는 가비지 수집기가 자체적으로 수행합니다. System.GC.Collect()는 정리를 위해 내부적으로 호출됩니다. 그러나 때로는 소멸자를 수동으로 구현해야 할 수도 있습니다.

###### Source

* https://www.softwaretestinghelp.com/c-sharp-interview-questions/

[[↑] 맨 위로](#C)
### StackOverflowError와 OutOfMemoryError의 차이점은 무엇입니까?

* **OutOfMemoryError** 는 힙과 관련이 있습니다. 피하려면: GC에 불필요한 개체를 사용할 수 있는지 확인하십시오.
* **StackOverflowError**는 스택과 관련이 있습니다. 피하려면: 메서드 호출이 종료되고 있는지 확인하십시오(무한 루프가 아님).


###### Source

* http://a4academics.com/interview-questions/52-dot-net-interview-questions/417-c-oops-interview-questions-and-answers?showall=&start=1

[[↑] 맨 위로](#C)
### C#에서 late binding과 early binding의 차이점은 무엇입니까?

* **Compile time polymorphism** 또는 **Early Binding**에서는 이름은 같지만 매개변수 유형이 다른 여러 메서드를 사용하거나 숫자 또는 매개변수가 될 수 있습니다. 메서드 **오버로딩**이라고도 하는 동일한 클래스입니다.
* **Run time polymorphism**은 **late binding**이라고도 하며 런타임 다형성 또는 후기 바인딩에서는 동일한 서명을 가진 동일한 메서드 이름을 사용할 수 있습니다. 컴파일 타임에 이를 허용하지 않으므로 런타임에 바인딩하는 파생 클래스에서 자식 클래스 또는 파생 클래스 개체가 인스턴스화될 때 사용할 수 있습니다. 이러한 방식은 후기 바인딩을 메서드 **overriding**라고도 합니다.


###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### 메소드가 오버로드될 수 있는 다른 방법은 무엇입니까?

매개변수에 대해 다른 데이터 유형, 매개변수 순서 및 매개변수 수를 사용하여 메소드를 오버로드할 수 있습니다.

###### Source

* https://www.guru99.com/c-sharp-interview-questions.html

[[↑] 맨 위로](#C)
### C#에서 dispose와 finalize 메소드의 차이점은 무엇입니까?

Finalizer와 Dispose는 모두 관리되지 않는 리소스를 해제하는 것과 같은 동일한 작업에 사용되지만 몇 가지 차이점이 있습니다.

**Finalize:**

* 파일, 응용 프로그램 도메인의 데이터베이스 연결 등과 같이 사용되지 않는 관리되지 않는 리소스를 해제하는 데 사용되는 Finalize는 해당 개체가 파괴되기 전에 개체가 보유하고 있습니다.
* 내부 프로세스에서는 Garbage Collector에 의해 호출되며 사용자 코드 또는 서비스에 의해 수동으로 호출될 수 없습니다.
* Finalize는 System.Object 클래스에 속합니다.
* 코드에 관리되지 않는 리소스가 있는 경우 이를 구현하고 가비지 수집이 발생할 때 이러한 리소스가 해제되는지 확인합니다.

**Dispose:**

* Dispose 또한 파일이나 응용 프로그램 도메인의 데이터베이스 연결과 같이 사용되지 않는 관리되지 않는 리소스를 언제든지 해제하는 데 사용됩니다.  
* 명시적으로 삭제는 수동 사용자 코드에 의해 호출됩니다. 
* 메서드를 폐기해야 하는 경우 해당 클래스를 IDisposable 인터페이스로 구현해야 합니다.
* IDisposable 인터페이스에 속합니다.
* 다른 사용자가 사용할 사용자 정의 클래스를 작성할 때 이것을 구현하십시오.

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### marshalling은 무엇이며 왜 필요한가?

언어와 환경에 따라 호출 규칙, 레이아웃 규칙, 기본 형식의 크기(C#의 char 및 C의 char 참조), 개체 생성/파기 규칙 및 디자인 지침이 다르기 때문입니다. 관리되는 토지의 물건을 관리되지 않는 토지가 보고 이해할 수 있는 곳으로 가져갈 수 있는 방법이 필요합니다. 마샬링이 바로 그것입니다.

###### Source

* https://stackoverflow.com/questions/2240804/marshalling-what-is-it-and-why-do-we-need-it

[[↑] 맨 위로](#C)
### 접근성 수정자 "protected internal"를 설명합니다.

보호된 내부 변수/메서드는 동일한 어셈블리 내에서 그리고 이 부모 클래스에서 파생된 클래스에서도 액세스할 수 있습니다.

###### Source

* https://www.guru99.com/c-sharp-interview-questions.html

[[↑] 맨 위로](#C)
### C#의 포인터 유형은 무엇입니까?

**Pointer type** 변수는 다른 유형의 메모리 주소를 저장합니다. C#의 포인터는 C 또는 C++의 포인터와 동일한 기능을 가지고 있습니다.

```csharp
char* cptr;  int* iptr;
```


###### Source

* https://www.tutorialspoint.com/csharp/csharp_interview_questions.htm

[[↑] 맨 위로](#C)
### C#에서 다차원 배열과 배열의 차이점은 무엇입니까?

* 배열의 배열(jagged 배열)은 다차원 배열보다 빠르며 더 효과적으로 사용할 수 있습니다.
* 다차원 배열은 구문이 더 좋습니다.

###### Source

* https://stackoverflow.com/questions/597720/what-are-the-differences-between-a-multidimensional-array-and-an-array-of-arrays

[[↑] 맨 위로](#C)
### C# 클래스의 Protected Internal 멤버 변수의 범위는 무엇입니까?

**protected internal** 액세스 지정자를 사용하면 클래스가 동일한 응용 프로그램 내의 자식 클래스를 제외하고 다른 클래스 개체 및 함수에서 해당 멤버 변수 및 멤버 함수를 숨길 수 있습니다. 이것은 상속을 구현할 때도 사용됩니다.

###### Source

* https://www.tutorialspoint.com/csharp/csharp_interview_questions.htm

[[↑] 맨 위로](#C)
### 다양한 수의 인수를 허용할 수 있는 함수를 C#에서 만들 수 있습니까?

'params' 키워드를 사용하여 가변 개수의 인수를 사용하는 메서드 매개변수를 지정할 수 있습니다. 메서드 선언에서 params 키워드 뒤에는 추가 매개 변수가 허용되지 않으며 메서드 선언에는 하나의 params 키워드만 허용됩니다. params 매개변수의 선언된 유형은 1차원 배열이어야 합니다.

```csharp
public static void UseParams(params int[] list) {
 for (int i = 0; i < list.Length; i++) {
  Console.Write(list[i] + " ");
 }
 Console.WriteLine();
}

public static void UseParams2(params object[] list) {
 for (int i = 0; i < list.Length; i++) {
  Console.Write(list[i] + " ");
 }
 Console.WriteLine();
}

// usage
UseParams(1, 2, 3, 4);
UseParams2(1, 'a', "test");
```



###### Source

* https://www.tutorialspoint.com/csharp/csharp_interview_questions.htm

[[↑] 맨 위로](#C)
### 연산자 오버로딩이 C#에서 지원되나요?

C#에서 사용할 수 있는 대부분의 기본 제공 연산자를 재정의하거나 오버로드할 수 있습니다. 따라서 프로그래머는 사용자 정의 유형과 함께 연산자도 사용할 수 있습니다

오버로드된 연산자는 operator 키워드 뒤에 정의되는 연산자에 대한 기호가 오는 특수 이름을 가진 함수입니다. 다른 함수와 마찬가지로 오버로드된 연산자에는 반환 형식과 매개 변수 목록이 있습니다.

###### Source

* https://www.tutorialspoint.com/csharp/csharp_interview_questions.htm

[[↑] 맨 위로](#C)
### C#에서 조건부 전처리기 지시문을 사용하는 방법은 무엇입니까?

`#if` 지시문을 사용하여 조건부 지시문을 만들 수 있습니다. 조건부 지시문은 기호가 true로 평가되는지 확인하기 위해 기호를 테스트하는 데 유용합니다. true로 평가되면 컴파일러는 `#if`와 다음 지시문 사이의 모든 코드를 평가합니다.

###### Source

* https://www.tutorialspoint.com/csharp/csharp_interview_questions.htm

[[↑] 맨 위로](#C)
### System.ApplicationException 클래스와 System.SystemException 클래스의 차이점은 무엇입니까?

* `System.ApplicationException` 클래스는 응용 프로그램에서 생성된 예외를 지원합니다. 따라서 프로그래머가 정의한 예외는 이 클래스에서 파생되어야 합니다.
* `System.SystemException` 클래스는 미리 정의된 모든 시스템 예외의 기본 클래스입니다.

###### Source

* https://www.tutorialspoint.com/csharp/csharp_interview_questions.htm

[[↑] 맨 위로](#C)
### C#의 Indexer는 무엇입니까?

**indexer** 를 사용하면 배열과 같은 객체를 인덱싱할 수 있습니다. 클래스에 대한 인덱서를 정의하면 이 클래스는 가상 배열과 유사하게 동작합니다. 그런 다음 배열 액세스 연산자([ ])를 사용하여 이 클래스의 인스턴스에 액세스할 수 있습니다. 인덱서는 오버로드될 수 있습니다. 인덱서는 여러 매개변수를 사용하여 선언할 수도 있으며 각 매개변수는 다른 유형일 수 있습니다. 인덱스가 정수일 필요는 없습니다. C#에서는 인덱스가 문자열과 같은 다른 유형이 될 수 있습니다.

Consider:
```CSharp
class IndexedNames {
	private string[] namelist = new string[size];

	public string this[int index] {
		get {
			string tmp;

			if (index >= 0 && index <= size - 1) {
				tmp = namelist[index];
			} else {
				tmp = "";
			}

			return (tmp);
		}
		set {
			if (index >= 0 && index <= size - 1) {
				namelist[index] = value;
			}
		}
	}
}
```

###### Source

* https://www.tutorialspoint.com/csharp/csharp_indexers.htm

[[↑] 맨 위로](#C)
### C#에서 "catch" 블록 없이 "try" 블록만 가질 수 있습니까?

예, catch 블록 없이 try 블록만 가질 수 있지만 finally 블록은 있어야 합니다.

###### Source

* http://a4academics.com/interview-questions/52-dot-net-interview-questions/417-c-oops-interview-questions-and-answers?showall=&start=1

[[↑] 맨 위로](#C)
### try 블록에 return 문을 추가하면 finally 블록이 C#에서 실행되는지 여부는?

예. 마지막으로 블록은 try 블록에 return 문이 있는 경우에도 계속 실행됩니다.

###### Source

* http://a4academics.com/interview-questions/52-dot-net-interview-questions/417-c-oops-interview-questions-and-answers?showall=&start=1

[[↑] 맨 위로](#C)
### C#에서 생성자 연결이란 무엇입니까?

**Constructor Chaining** 은 생성자가 동일한 또는 기본 클래스의 다른 생성자를 호출하는 접근 방식입니다. 이것은 여러 생성자를 정의하는 클래스가 있을 때 매우 편리합니다.

Consider:
```csharp
class Foo {
    private int id;
    private string name;

    public Foo() : this(0, "") {
    }

    public Foo(int id) : this(id, "") {
    }

    public Foo(string name) : this(0, name) {
    }

    public Foo(int id, string name) {
        this.id = id;
        this.name = name;
    }
}
```

###### Source

* https://stackoverflow.com/questions/1814953/c-sharp-constructor-chaining-how-to-do-it

[[↑] 맨 위로](#C)
### C#에서 delegates의 용도는 무엇입니까?

다음은 C#의 대리자 사용 목록입니다:
* Callback Mechanism
* Asynchronous Processing
* Abstract and Encapsulate method
* Multicasting

###### Source

* http://a4academics.com/interview-questions/52-dot-net-interview-questions/417-c-oops-interview-questions-and-answers?showall=&start=1

[[↑] 맨 위로](#C)
### C#에서 잠금 문을 사용하는 이유는 무엇입니까?

**Lock** 은 한 스레드가 코드의 일부를 실행하는 다른 스레드를 가로채지 않도록 합니다. 따라서 lock 문은 스레드를 기다리게 하고 객체가 해제될 때까지 차단합니다.

###### Source

* http://a4academics.com/interview-questions/52-dot-net-interview-questions/417-c-oops-interview-questions-and-answers?showall=&start=1

[[↑] 맨 위로](#C)
### C#에서 다중 상속을 구현할 수 있습니까?

C#에서 파생 클래스는 하나의 기본 클래스에서만 상속할 수 있습니다. 여러 기본 클래스에서 상속하려면 인터페이스를 사용하십시오.

###### Source

* https://stackoverflow.com/questions/4506990/what-is-the-use-of-static-constructors

[[↑] 맨 위로](#C)
### 아래 쇼트 프로그램의 결과는 무엇입니까? 당신의 대답을 설명하십시오

출력은 다음과 같습니다.
```csharp
location is null
1/1/0001 12:00:00 AM
```
두 변수 모두 초기화되지 않았지만 `String`은 참조 유형이고 `DateTime`은 값 유형입니다. 값 유형으로 단위화된 `DateTime` 변수는 기본값인 1/1/1(예, A.D. 1년) 자정으로 설정되며 _not_ `null`입니다.

###### Source

* https://www.toptal.com/c-sharp/interview-questions

[[↑] 맨 위로](#C)
### 아래 if 문에서 시간과 null의 비교가 유효한가요? 그 이유는?

`DateTime` 변수는 절대 null이 될 수 없기 때문에(0001년 1월 1일로 자동 초기화됨) 컴파일러는 `DateTime` 변수가 `null`과 비교될 때 불평할 것이라고 생각할 수도 있습니다. 그러나 형식 강제로 인해 컴파일러는 이를 허용하므로 잠재적으로 헤드페이크 및 뽑기 버그가 발생할 수 있습니다.

특히 `==` 연산자는 피연산자를 다른 허용 가능한 유형으로 캐스팅하여 양쪽에서 공통 유형을 얻은 다음 비교할 수 있습니다. 이것이 다음과 같은 것이 예상한 결과를 제공하는 이유입니다(피연산자의 유형이 다르기 때문에 실패하거나 예기치 않게 동작하는 것과 반대).

```csharp
double x = 5.0;
int y = 5;
Console.WriteLine(x == y);  // outputs true
```
    

그러나 'DateTime' 변수와 'null'을 비교하는 경우와 같이 예기치 않은 동작이 발생할 수 있습니다. 이러한 경우 `DateTime` 변수와 `null` 리터럴 모두 `Nullable<DateTime>`으로 캐스트될 수 있습니다. 따라서 결과가 _항상_ 거짓이더라도 두 값을 비교하는 것은 합법적입니다.

###### Source

* https://www.toptal.com/c-sharp/interview-questions

[[↑] 맨 위로](#C)
### 아래 프로그램의 출력은 무엇입니까? 당신의 대답을 설명하십시오.

질문의 첫 번째 부분(즉, `await Task.Delay(5);`이 있는 코드 버전)에 대한 대답은 프로그램이 빈 줄을 출력한다는 것입니다("Hello world!"가 아닌_). 이는 `Console.WriteLine`이 호출될 때 `result`가 여전히 초기화되지 않기 때문입니다.

대부분의 절차적 및 객체 지향 프로그래머는 호출하는 함수로 돌아가기 전에 함수가 처음부터 끝까지 또는 `return` 문으로 실행될 것으로 기대합니다. 이것은 C# `async` 함수의 경우가 아닙니다. 첫 번째 `await` 문까지만 실행한 다음 호출자에게 돌아갑니다. `await`에 의해 호출된 함수(이 경우 `Task.Delay`)는 비동기적으로 실행되며 `await` 문 뒤의 행은 `Task.Delay`가 완료될 때까지(5밀리초 내) 실행 신호를 받지 않습니다. 그러나 그 시간 안에 제어는 이미 호출자에게 반환되었으며, 호출자는 아직 초기화되지 않은 문자열에 대해 `Console.WriteLine` 문을 실행합니다.

`await Task.Delay(5)`를 호출하면 현재 스레드가 하고 있는 작업을 계속할 수 있으며, 완료되면(대기 중인 대기 중) 스레드 풀로 반환합니다. 이것이 async/await 메커니즘의 주요 이점입니다. 이를 통해 CLR은 스레드 풀에서 더 적은 스레드로 더 많은 요청을 처리할 수 있습니다.


비동기 프로그래밍은 네트워크를 통한 서비스 요청 또는 많은 활동에 대한 데이터베이스 요청을 수행하는 장치의 보급으로 인해 훨씬 ​​더 보편화되었습니다. C#에는 비동기 메서드 프로그래밍 작업을 크게 간소화하는 몇 가지 우수한 프로그래밍 구성이 있으며 이를 알고 있는 프로그래머는 더 나은 프로그램을 생성할 것입니다.

질문의 두 번째 부분과 관련하여 `await Task.Delay(5);`가 `Thread.Sleep(5)`로 바뀌면 프로그램은 `Hello world!`를 출력합니다. 하나 이상의 `await` 문이 _없는_ 'async' 메서드는 동기 메서드처럼 작동합니다. 즉, 처음부터 끝까지 또는 `return` 문을 만날 때까지 실행됩니다. `Thread.Sleep()`을 호출하면 단순히 현재 실행 중인 스레드를 차단하므로 `Thread.Sleep(5)` 호출은 `SaySomething()` 메서드의 실행 시간에 5밀리초만 추가합니다.

###### Source

* https://www.toptal.com/c-sharp/interview-questions

[[↑] 맨 위로](#C)
### 아래 프로그램의 출력은 무엇입니까?

`테스트값 : 10`

클래스의 정적 생성자는 클래스의 인스턴스가 생성되기 전에 호출됩니다. 여기서 호출되는 정적 생성자는 'TestValue' 변수를 먼저 초기화합니다.

###### Source

* https://www.toptal.com/c-sharp/interview-questions

[[↑] 맨 위로](#C)
### C#에서 array[]보다 ArrayList를 언제 사용합니까?

* **Arrays**는 강력한 형식이며 매개변수로 잘 작동합니다. 컬렉션의 길이를 알고 고정되어 있으면 배열을 사용해야 합니다.
* **ArrayLists** 은 강력한 유형이 아니므로 모든 삽입 또는 재시도에서 원래 유형으로 돌아가기 위해 캐스트가 필요합니다. 특정 유형의 목록을 가져오는 방법이 필요한 경우 모든 유형을 포함하는 ArrayList를 전달할 수 있기 때문에 ArrayList는 부족합니다. ArrayList는 내부적으로 동적으로 확장되는 배열을 사용하므로 용량에 도달하면 내부 배열의 크기를 확장해야 하는 문제도 있습니다.

실제로 사용하고 싶은 것은 List<T>와 같은 일반 목록입니다. 이것은 Array 및 ArrayLists의 모든 장점을 가지고 있습니다. 강력한 형식이며 다양한 길이의 항목을 지원합니다.

###### Source

* https://stackoverflow.com/questions/412813/when-to-use-arraylist-over-array-in-c

[[↑] 맨 위로](#C)
### C#에서 사용되는 "yield" 키워드는 무엇입니까?

이 함수는 'IEnumerable' 인터페이스를 구현하는 객체를 반환합니다. 호출 함수가 이 객체에 대해 foreach-ing을 시작하면 함수가 "양보"할 때까지 다시 호출됩니다. 이것은 C# 2.0에 도입된 구문 설탕입니다.

'Yield'에는 다음과 같은 두 가지 큰 용도가 있습니다.
* 임시 컬렉션을 만들지 않고 사용자 지정 반복을 제공하는 데 도움이 됩니다.
* 상태 저장 반복을 수행하는 데 도움이 됩니다.

'yield'를 사용하는 이점은 데이터를 사용하는 함수에 컬렉션의 첫 번째 항목만 필요한 경우 나머지 항목이 생성되지 않는다는 것입니다.

###### Source

* https://stackoverflow.com/questions/39476/what-is-the-yield-keyword-used-for-in-c

[[↑] 맨 위로](#C)
### .Net의 개체 풀이란 무엇입니까?

개체 풀링은 나중에 재사용할 수 있도록 메모리에 개체 풀을 유지하려고 하므로 개체 생성 로드를 크게 줄일 수 있습니다. 새 개체에 대한 요청이 있을 때마다 풀 관리자는 요청을 받고 풀에서 개체를 할당하여 서비스를 제공합니다.

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### "where" 메서드가 작동하려면 데이터 구조에서 어떤 인터페이스를 구현해야 합니까?

`IEnumerable`

###### Source

* https://medium.com/sears-israel/my-number-one-c-interview-question-39cdaac16c

[[↑] 맨 위로](#C)
### IEnumerable vs List - 무엇을 사용할 것인가? 그들은 어떻게 작동합니까?

`IEnumerable`은 동작을 설명하는 반면 List는 해당 동작의 구현입니다. `IEnumerable`을 사용하면 컴파일러가 작업을 나중으로 연기할 수 있는 기회를 주어 최적화할 수 있습니다. `ToList()`를 사용하면 컴파일러가 결과를 즉시 구체화하도록 합니다.

LINQ 표현식을 "스택"할 때마다 `IEnumerable`을 사용해야 합니다. 동작만 지정하면 LINQ가 평가를 연기하고 프로그램을 최적화할 수 있기 때문입니다.

###### Source

* https://stackoverflow.com/questions/3628425/ienumerable-vs-list-what-to-use-how-do-they-work

[[↑] 맨 위로](#C)
### C#에서 "is"와 "as" 연산자의 이름 차이

* 'is' 연산자는 객체를 특정 유형으로 캐스팅할 수 있는지 확인합니다.
```csharp
if (someObject is StringBuilder) ...
```

* 'as' 연산자는 객체를 특정 유형으로 캐스팅하려고 시도하고 실패하면 null을 반환합니다.
```csharp
StringBuilder b = someObject as StringBuilder;
if (b != null) ...
```

###### Source

* https://stackoverflow.com/questions/3786361/difference-between-is-and-as-keyword

[[↑] 맨 위로](#C)
### Func<string,string>과 delegate의 차이점은 무엇입니까?

첫 번째는 제네릭 대리자 변수를 선언하고 값을 할당하는 것이고, 두 번째는 대리자 유형을 정의하는 것입니다. `Func<string,string>` 및 대리자 문자열 convertMethod(string) 모두 메서드, 익명 메서드 또는 람다 식이든 동일한 메서드 정의를 보유할 수 있습니다.

Consider:
```csharp
public static class Program
{
    // you can define your own delegate for a nice meaningful name, but the
    // generic delegates (Func, Action, Predicate) are all defined already
    public delegate string ConvertedMethod(string value);

    public static void Main()
    {
        // both work fine for taking methods, lambdas, etc.
        Func<string, string> convertedMethod = s => s + ", Hello!";
        ConvertedMethod convertedMethod2 = s => s + ", Hello!";
    }
}
```

###### Source

* https://stackoverflow.com/questions/6818656/what-is-the-difference-between-funcstring-string-and-delegate

[[↑] 맨 위로](#C)
### Select와 Where의 차이점 설명

* **Select**는 프로젝션이므로 서버의 ContextSet()에 있는 각 요소에 대해 평가된 표현식 `x=> x.FirstName == "John"`이 표시됩니다. 즉, 많은 참/거짓 값(원래 목록과 동일한 숫자). 선택하면 `IEnumerable<bool>`과 같은 항목이 반환됩니다(`x=> x.FirstName == "John"`의 유형은 bool이기 때문에). 모든 결과를 유지하되 유형을 변경(투영)하려면 '선택'을 사용하세요.
* ** Where**는 결과를 필터링하여 원래 유형의 열거형(프로젝션 없음)을 반환합니다. 원래 유형을 유지하면서 결과를 필터링하려면 '어디'를 사용하세요.


###### Source

* https://stackoverflow.com/questions/8230278/difference-between-select-and-where-in-entity-framework

[[↑] 맨 위로](#C)
### C#에서 단락 평가가 무엇인지 설명

**단락 평가**는 논리 연산자 AND 및 OR을 평가하는 까다로운 방법입니다. 이 방법에서는 모든 하위 표현식을 평가하지 않고 전체 표현식을 'true' 또는 'false'로 평가할 수 있습니다.

###### Source

* https://www.c-sharpcorner.com/article/short-circuit-evaluation-in-c-sharp/

[[↑] 맨 위로](#C)
### .Net에서 평등 검사를 위한 몇 가지 다른 방법 나열

* ReferenceEquals() 메서드 - 두 개의 참조 유형 변수(구조체가 아닌 클래스)가 동일한 메모리 주소를 참조하는지 확인합니다.
* 가상 Equals() 메서드. (System.Object) - 두 개체가 동일한지 확인합니다.
* 정적 Equals() 메서드 - 검사에 null 값이 있을 때 문제를 처리하는 데 사용됩니다.
* IEquatable 인터페이스의 Equals 메서드입니다.
* 비교 연산자 == - 일반적으로 ReferenceEquals와 동일함을 의미하며 두 변수가 동일한 메모리 주소를 가리키는지 확인합니다. 문제는 이 연산자가 다른 유형의 검사를 수행하기 위해 재정의될 수 있다는 것입니다. 예를 들어 문자열에서 두 개의 다른 인스턴스가 동일한지 확인합니다.

###### Source

* https://stackoverflow.com/questions/3191969/5-ways-for-equality-check-in-net-why-and-which-to-use

[[↑] 맨 위로](#C)
### C#에서 멀티캐스트 delegate란 무엇입니까?

대리자는 대리자에 캡슐화된 하나의 메서드 참조만 호출할 수 있습니다. 특정 대리자가 여러 메서드를 보유하고 호출하는 것이 가능합니다. 이러한 대리자를 **멀티캐스트 대리자**라고 합니다. 멀티캐스트 대리자는 결합 가능한 대리자라고도 하며 다음 조건을 충족해야 합니다.

* 대리자의 반환 형식은 void여야 합니다. 대리자 형식의 매개 변수는 out 키워드를 사용하여 출력 매개 변수로 선언할 수 없습니다.
* 멀티캐스트 델리게이트 인스턴스는 2개의 델리게이트를 결합하여 생성되며, 호출 목록은 추가 연산의 두 피연산자의 호출 목록을 연결하여 구성됩니다. 대리자는 추가된 순서대로 호출됩니다.

실제로 C#의 모든 대리자는 대상으로 단일 메서드만 있는 경우에도 MulticastDelegates입니다. (익명 함수와 람다도 정의상 단일 대상만 있지만 MulticastDelegates입니다.)

Consider:
```csharp
ublic partial class MainPage : PhoneApplicationPage
{
    public delegate void MyDelegate(int a, int b);
    // Constructor
    public MainPage()
    {
        InitializeComponent();

        // Multicast delegate
        MyDelegate myDel = new MyDelegate(AddNumbers);
        myDel += new MyDelegate(MultiplyNumbers);
        myDel(10, 20);
    }

    public void AddNumbers(int x, int y)
    {
        int sum = x + y;
        MessageBox.Show(sum.ToString());
    }

    public void MultiplyNumbers(int x, int y)
    {
        int mul = x * y;
        MessageBox.Show(mul.ToString());
    }

}
```

###### Source

* https://stackoverflow.com/questions/15023736/multicast-delegate-c-sharp

[[↑] 맨 위로](#C)
### C#.Net에서 jagged 배열이란 무엇이며 언제 다차원 배열보다 jagged 배열을 선호합니까?

**jagged 배열**(`double[][]`)은 요소가 배열인 배열입니다. 들쭉날쭉한 배열의 요소는 차원과 크기가 다를 수 있습니다. 속도에 관심이 있다면 항상 다차원 배열보다 들쭉날쭉한 배열을 선호합니다. .NET 런타임 지원(지터 및 CLR)은 벡터와 배열을 강력하게 구분합니다. 들쭉날쭉한 배열은 벡터의 벡터이므로 사용할 때 모든 런타임 최적화를 얻을 수 있습니다. 다차원 배열은 그렇지 않습니다. 속도 차이는 약 2배입니다.

구문의 편리함을 선호하고 배열 인덱싱이 프로그램의 주요 경로에 없음을 확인한 경우에만 다차원 배열 사용을 고려하십시오.

###### Source

* https://stackoverflow.com/questions/19887182/what-can-be-a-situation-where-a-jagged-array-be-preferred-over-a-normal-rectangu

[[↑] 맨 위로](#C)
### C#에서 sealed 추상 클래스를 만들 수 있습니까?

아뇨! 추상 클래스는 봉인된 것으로 선언할 수 없으므로 생성할 수 없습니다.

###### Source

* https://www.tutorialspoint.com/csharp/csharp_interview_questions.htm

[[↑] 맨 위로](#C)
### C#에서 deep copy 또는 shallow copy 개념이란 무엇입니까?

* **Shallow Copy**는 객체의 값 유형 필드를 대상 객체에 복사하는 것이며 객체의 참조 유형은 참조로 대상 객체에 복사되지만 참조된 객체 자체는 복사되지 않습니다. 유형을 비트별로 복사합니다. 결과적으로 두 인스턴스가 모두 복제되고 원본이 동일한 개체를 참조하게 됩니다.
* **Deep Copy**는 내부 참조 유형의 완전한 전체 복사본을 만드는 데 사용됩니다. 이를 위해 `MemberwiseClone()`이 반환하는 객체를 구성해야 합니다.

즉, 깊은 복사는 개체가 참조하는 개체와 함께 복사될 때 발생합니다.

###### Source

* https://social.msdn.microsoft.com/Forums/vstudio/en-US/ea757e8d-0f50-44a0-a586-f3ea541f6536/what-is-deep-or-shallow-copy-concept-in-c?forum=csharpgeneral

[[↑] 맨 위로](#C)
### C#에서 전처리기 지시문이란 무엇입니까?

**전처리기 지시문**은 실제 컴파일이 시작되기 전에 정보를 사전 처리하도록 컴파일러에 지시합니다.

모든 전처리기 지시문은 **#**로 시작하고 공백 문자만 행에서 전처리기 지시문 앞에 나타날 수 있습니다. 전처리기 지시문은 문이 아니므로 세미콜론(;)으로 끝나지 않습니다.

###### Source

* https://www.tutorialspoint.com/csharp/csharp_interview_questions.htm

[[↑] 맨 위로](#C)
### 소멸자, 폐기 및 종료 방법의 차이점을 설명할 수 있습니까?

C# 용어에서 소멸자와 종료자는 기본적으로 상호 교환 가능한 개념이며 형식이 수집될 때 **관리되지 않는** 리소스(예: 외부 핸들)를 해제하는 데 사용해야 합니다. 종료자를 작성해야 하는 경우는 ***매우*** 드뭅니다.

문제는 GC가 비결정적이므로 `IDisposable`을 통해 `Dispose()` 메서드를 사용하면 *결정적* 정리를 지원할 수 있다는 것입니다. 이것은 가비지 수집과 관련이 없으며 호출자가 모든 리소스를 *더 빨리* 해제할 수 있도록 합니다. 예를 들어 데이터베이스 연결을 *캡슐화*하는(말하자면) 유형이 있는 경우 연결을 해제하기 위해 유형을 폐기할 수도 있습니다.

###### Source

* https://stackoverflow.com/questions/13988334/difference-between-destructor-dispose-and-finalize-method

[[↑] 맨 위로](#C)
### System.Array.CopyTo()와 System.Array.Clone()의 차이점은 무엇입니까?

* **Clone** - Method creates a shallow copy of an array. A shallow copy of an Array copies only the elements of the Array, whether they are reference types or value types, but it does not copy the objects that the references refer to. The references in the new Array point to the same objects that the references in the original Array point to.
* **CopyTo** - The Copy static method of the Array class copies a section of an array to another array. The CopyTo method copies all the elements of an array to another one-dimension array. The code listed in Listing 9 copies contents of an integer array to an array of object types. 

###### Source

* https://www.c-sharpcorner.com/UploadFile/8ef97c/C-Sharp-net-interview-questions-and-answers/

[[↑] 맨 위로](#C)
### LINQ에서 지연된 실행의 이점은 무엇입니까?

LINQ에서 쿼리에는 즉시 실행과 지연 실행이라는 두 가지 실행 동작이 있습니다. 지연된 실행은 실현된 값이 실제로 필요할 때까지 표현식 평가가 지연됨을 의미합니다. 불필요한 실행을 방지하여 성능을 크게 향상시킵니다.

Consider:
```csharp
var results = collection.Select(item => item.Foo).Where(foo => foo < 3).ToList();
```
지연된 실행을 사용하면 위의 항목이 컬렉션을 한 번 반복하고 반복 중에 항목이 요청될 때마다 맵 작업을 수행하고 필터링한 다음 결과를 사용하여 목록을 작성합니다.

LINQ가 매번 완전히 실행되도록 하려면 각 작업(Select / Where)이 전체 시퀀스를 반복해야 합니다. 이것은 연쇄 작업을 매우 비효율적으로 만듭니다.

###### Source

* https://stackoverflow.com/questions/7324033/what-are-the-benefits-of-a-deferred-execution-in-linq

[[↑] 맨 위로](#C)
### MemberwiseClone() 메서드는 무엇을 합니까?

**MemberwiseClone()** 메서드는 새 개체를 만든 다음 현재 개체의 비정적 필드를 새 개체에 복사하여 _shallow copy_를 만듭니다.
* 필드가 _값 유형_인 경우 필드의 비트 단위 복사가 수행됩니다.
* 필드가 _참조 유형_인 경우 참조는 복사되지만 참조된 개체는 복사되지 않습니다. 따라서 원본 개체와 해당 복제본은 동일한 개체를 참조합니다.

Consider:
```csharp
public class Person 
{
    public int Age;
    public string Name;
    public IdInfo IdInfo;

    public Person ShallowCopy()
    {
       return (Person) this.MemberwiseClone();
    }

    public Person DeepCopy()
    {
       Person other = (Person) this.MemberwiseClone();
       other.IdInfo = new IdInfo(IdInfo.IdNumber);
       other.Name = String.Copy(Name);
       return other;
    }
}
```

###### Source

* https://stackoverflow.com/questions/2289420/what-is-the-method-memberwiseclone-doing

[[↑] 맨 위로](#C)
### 순환 참조란 무엇입니까?

**Circular reference** 는 두 개 이상의 리소스가 서로 종속되어 잠금 상태가 되어 리소스를 사용할 수 없게 만드는 상황입니다.

###### Source

* https://www.guru99.com/c-sharp-interview-questions.html

[[↑] 맨 위로](#C)
### lambdas와 delegates의 차이점은 무엇입니까?

그들은 실제로 두 가지 매우 다른 것입니다:

* **Delegate** 는 실제로 메서드 또는 람다에 대한 참조를 보유하는 변수의 이름이고 람다는 영구적인 이름이 없는 메서드입니다.
* **Lambdas** 는 몇 가지 미묘한 차이점을 제외하고는 다른 방법과 매우 유사합니다:
 * 일반 메서드는 "문"에 정의되고 영구적인 이름에 묶인 반면, 람다는 "식"에서 "즉석에서" 정의되고 영구적인 이름이 없습니다.
 * Lambda는 .NET 표현식 트리와 함께 사용할 수 있지만 메서드는 사용할 수 없습니다.

###### Source

* https://stackoverflow.com/questions/73227/what-is-the-difference-between-lambdas-and-delegates-in-the-net-framework

[[↑] 맨 위로](#C)
### IEnumerable과 IQueryable의 차이점은 무엇입니까?

* `IEnumerable<>` 인터페이스는 무언가를 열거할 수 있음을 나타냅니다. 즉, foreach 루프를 수행할 수 있습니다.
* `IQueryable<>` 인터페이스는 주어진 표현식을 보고 일종의 쿼리로 변환할 수 있는 일종의 백업 쿼리 공급자가 있음을 나타냅니다.

IQueryable<T>에 있는 것은 IEnumerable<T>가 특히 두 가지 속성이 아니라는 점입니다. 하나는 **쿼리 공급자**(예: LINQ to SQL 공급자)를 가리키는 속성이고 다른 하나는 **쿼리 표현식을 가리키는 속성입니다. ** IQueryable<T> 개체를 지정된 쿼리 공급자가 이해할 수 있는 런타임 탐색 가능한 추상 구문 트리로 나타냅니다(대부분의 경우 LINQ to Entities 공급자 없이는 LINQ to SQL 식을 LINQ to Entities 공급자 예외가 발생함).

###### Source

* https://stackoverflow.com/questions/252785/what-is-the-difference-between-iqueryablet-and-ienumerablet

[[↑] 맨 위로](#C)
### Func vs. Action vs. Predicate의 차이점을 설명해 주시겠습니까?

* **Predicate**: 본질적으로 `Func<T, bool>`; "지정된 인수가 대리자가 나타내는 조건을 충족합니까?"라는 질문을 합니다. `List.FindAll`과 같은 것에서 사용됩니다.
* **Action**: 주어진 인수로 작업을 수행합니다. 매우 일반적인 목적. 기본적으로 부작용을 암시하므로 LINQ에서는 많이 사용되지 않습니다.
* **Func**: 광범위하게 LINQ에서, 보통, 예를 들어 한 속성에 대한 복잡한 구조 돌출해 논쟁을 변화시키는 데 사용됩니다.

###### Source

* https://stackoverflow.com/questions/6818656/what-is-the-difference-between-funcstring-string-and-delegate

[[↑] 맨 위로](#C)
### C#에서 약한 참조가 무엇인지 설명하십시오.

가비지 수집기는 응용 프로그램의 코드가 해당 개체에 도달할 수 있는 동안 응용 프로그램에서 사용 중인 개체를 수집할 수 없습니다. 응용 프로그램에 개체에 대한 강력한 참조가 있다고 합니다.

**weak reference** 를 사용하면 가비지 수집기가 개체를 수집하는 동시에 응용 프로그램이 개체에 액세스할 수 있습니다. 약한 참조는 강한 참조가 없을 때 개체가 수집될 때까지 불확실한 시간 동안에만 유효합니다.

Weak references 는 많은 메모리를 사용하는 개체에 유용하지만 가비지 수집으로 회수하면 쉽게 다시 만들 수 있습니다.

###### Source

* https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/weak-references?view=netframework-4.7.2

[[↑] 맨 위로](#C)
### IQueryable, ICollection, IList 및 IDictionary 인터페이스의 차이점을 설명하시겠습니까?

이러한 모든 인터페이스는 **IEnumerable**에서 상속됩니다. 이 인터페이스를 사용하면 기본적으로 'foreach' 문(C#에서)에서 클래스를 사용할 수 있습니다.

 - **ICollection**은 나열한 인터페이스 중 가장 기본적인 것입니다. Count를 지원하는 열거 가능한 인터페이스입니다.
 - **IList**는 ICollection의 모든 것이지만 항목 추가 및 제거, 색인으로 항목 검색 등을 지원합니다. "객체 목록"에 가장 일반적으로 사용되는 인터페이스입니다.
 - **IQueryable**은 LINQ를 지원하는 열거 가능한 인터페이스입니다. 항상 IList에서 IQueryable을 만들고 LINQ to Objects를 사용할 수 있지만 LINQ to SQL 및 LINQ to Entities에서 SQL 문의 지연 실행에 사용되는 IQueryable도 있습니다.
 - **IDictionary**는 고유 키를 값에 매핑한다는 점에서 다른 동물입니다. 또한 키/값 쌍을 열거할 수 있다는 점에서 열거할 수 있지만 그렇지 않으면 나열한 다른 것과 다른 용도로 사용됩니다.

###### Source

* https://stackoverflow.com/questions/4455428/difference-between-iqueryable-icollection-ilist-idictionary-interface

[[↑] 맨 위로](#C)
###  C#에서 확장 메서드가 있는 인터페이스 대신 추상 클래스를 사용해야 하는 경우는 언제입니까?

* **Abstract** 클래스는 _inheritance_에 의해 작동합니다. 특별한 기본 클래스이기 때문에 일부 is-a-relationship을 모델링합니다.

* 반면 **Interfaces** 는 다른 이야기입니다. 그들은 상속을 사용하지 않지만 _polymorphism_(상속으로 구현할 수도 있음)을 제공합니다. 그들은 is- 관계를 모델링하지 않지만 더 많은 것을 지원합니다.

인터페이스에 확장 메서드를 적용하는 것은 공통 인터페이스만 공유할 수 있는 클래스 간에 공통 동작을 적용하는 데 유용합니다.

###### Source

* https://softwareengineering.stackexchange.com/questions/41740/when-to-use-abstract-classes-instead-of-interfaces-with-extension-methods-in-c

[[↑] 맨 위로](#C)
### 기존 정적 클래스에 확장 메서드를 추가할 수 있습니까?

아니요. 확장 메서드에는 개체에 대한 인스턴스 변수(값)가 필요합니다. 그러나 정적 래퍼 클래스를 작성할 수 있습니다. 또한 확장 메서드는 구문 설탕입니다.

Consider:
```csharp
public static string SomeStringExtension(this string s)
{
   //whatever..
}
// When you then call it 
myString.SomeStringExtension(); 
// the compiler just turns it into:
ExtensionClass.SomeStringExtension(myString);
```

###### Source

* https://stackoverflow.com/questions/249222/can-i-add-extension-methods-to-an-existing-static-class/26831158

[[↑] 맨 위로](#C)
### C#에서 "where" 메서드 구현

Consider:
```csharp
public static IEnumerable<T> Where<T>(this IEnumerable<T> items, Predicate< T> prodicate)
{
  foreach(var item in items)
  {
      if (predicate(item))
      {
           // for lazy/deffer execution plus avoid temp collection defined
           yield return item;
      }
  }
}

```

###### Source

* https://medium.com/sears-israel/my-number-one-c-interview-question-39cdaac16c

[[↑] 맨 위로](#C)
### "volatile" 키워드는 무엇에 사용됩니까?

C#에서 'volatile'은 변수 값이 프로그램 자체 범위(예: 운영 체제, 하드웨어 또는 동시에 실행되는 스레드)를 벗어나 변경될 수 있으므로 변수 값을 캐시해서는 안 된다고 컴파일러에 지시합니다. 그러면 컴파일러는 변수가 "제어 범위 밖에서" 변경되는 경우 문제를 일으킬 수 있는 최적화를 방지합니다.

###### Source

* https://stackoverflow.com/questions/3430757/what-is-the-volatile-keyword-used-for

[[↑] 맨 위로](#C)
### 원의 둘레를 계산

선호하는 답변은 다음과 같은 형식입니다:

```csharp
circle.Calculate(r => 2 * Math.PI * r);
```    

객체의 _private_ `radius` 필드에 액세스할 수 없기 때문에 객체 자체에 계산 함수를 인라인으로 전달하여 둘레를 계산하도록 지시합니다.

많은 C# 프로그래머는 함수 값 매개변수를 기피하거나 이해하지 못합니다. 이 경우 예제는 약간 인위적이지만, 목적은 신청자가 메서드의 정의와 일치하는 'Calculate' 호출을 공식화하는 방법을 이해하는지 확인하는 것입니다.

또는 유효한(덜 우아하지만) 솔루션은 객체에서 반경 값 자체를 검색한 다음 그 결과로 계산을 수행하는 것입니다:

```csharp
var radius = circle.Calculate(r => r);
var circumference = 2 * Math.PI * radius;
```    

어느 쪽이든 작동합니다. 여기서 우리가 찾고 있는 주요 사항은 후보자가 'Calculate' 메서드를 호출하는 방법에 익숙하고 이해하고 있는지 확인하는 것입니다.

###### Source

* https://www.toptal.com/c-sharp/interview-questions

[[↑] 맨 위로](#C)
### 정적 생성자의 용도는 무엇입니까?

**static constructor** 는 유형(또는 기타 유형별 작업)과 관련된 모든 정적 필드를 초기화하는 데 유용합니다. 특히 필수 구성 데이터를 읽기 전용 필드로 읽는 데 유용합니다.

처음 필요할 때 런타임에 의해 자동으로 실행됩니다(정확한 규칙은 복잡하고("beforefieldinit" 참조), CLR2와 CLR4 사이에서 미묘하게 변경됨). 리플렉션을 남용하지 않는 한 최대 한 번 실행이 보장됩니다(두 스레드가 동시에 도착하더라도).

당신은 그것을 오버로드 할 수 없습니다.

###### Source

* https://stackoverflow.com/questions/4506990/what-is-the-use-of-static-constructors

[[↑] 맨 위로](#C)
