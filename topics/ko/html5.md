## HTML5

[다음을 출력하는 HTML 테이블 태그 시퀀스를 작성하십시오.](#다음을-출력하는-HTML-테이블-태그-시퀀스를-작성하십시오)

[iframe이란 무엇이며 어떻게 작동합니까?](#iframe이란-무엇이며-어떻게-작동합니까)

[HTML의 메타 태그 설명](#HTML의-메타-태그-설명)

[이미지에서 alt 속성의 목적은 무엇입니까?](#이미지에서-alt-속성의-목적은-무엇입니까)

[self closing tag란?](#self-closing-tag란)

[span과 div의 차이점은 무엇입니까?](#span과-div의-차이점은-무엇입니까)

[검색 엔진에서 더 나은 색인을 얻으려면 어떻게 해야 합니까?](#검색-엔진에서-더-나은-색인을-얻으려면-어떻게-해야-합니까)

[HTML에서 텍스트를 어떻게 강조 표시할 수 있습니까?](#HTML에서-텍스트를-어떻게-강조-표시할-수-있습니까)

[다음 HTML5 의미 요소의 올바른 사용법을 간략하게 설명하세요. `<header>`, `<article>`, `<section>`, `<footer>`](#다음-HTML5-의미-요소의-올바른-사용법을-간략하게-설명하세요-header-article-section-footer)

[문자 인코딩이란 무엇입니까?](#문자-인코딩이란-무엇입니까)

[HTML5 사양의 주요 목표와 동기는 무엇이었습니까?](#HTML5-사양의-주요-목표와-동기는-무엇이었습니까)

[html 텍스트의 방향을 어떻게 변경합니까?](#html-텍스트의-방향을-어떻게-변경합니까)

[WebSQL이란 무엇입니까?](#WebSQL이란-무엇입니까)

[블록 요소와 인라인 요소의 차이점 설명](#블록-요소와-인라인-요소의-차이점-설명)

[optional tag란 무엇입니까?](#optional-tag란-무엇입니까)

[작은 요소는 언제 사용하는 것이 적절합니까?](#작은-요소는-언제-사용하는-것이-적절합니까)

[`<section>`과 `<div>`의 차이점은 무엇인가요?](#section과-div의-차이점은-무엇인가요)

[웹 작업자란 무엇입니까?](#웹-작업자란-무엇입니까)

[DOCTYPE은 무엇을 합니까?](#DOCTYPE은-무엇을-합니까)

[여러 언어로 된 콘텐츠가 있는 페이지를 어떻게 제공합니까?](#여러-언어로-된-콘텐츠가-있는-페이지를-어떻게-제공합니까)

[캐시 무효화의 목적은 무엇이며 어떻게 달성할 수 있습니까?](#캐시-무효화의-목적은-무엇이며-어떻게-달성할 수-있습니까)

[웹 페이지에 여러 <header> 요소가 포함될 수 있습니까? <footer> 요소는 어떻습니까?](#웹-페이지에-여러-header-요소가-포함될-수-있습니까-footer-요소는-어떻습니까)

[`data-` 속성은 무엇에 좋은가요?](#data-속성은-무엇에-좋은가요)

[`<script>` 태그의 `defer` 및 `async` 속성은 무엇입니까?](#script-태그의-defer-및-async-속성은-무엇입니까)

[DOM이란 무엇입니까?](#DOM이란-무엇입니까)

[HTML 사양과 브라우저 구현 간의 차이점에 대해 논의합니다.](#HTML-사양과-브라우저-구현-간의-차이점에-대해-논의합니다)

[XHTML이 HTML과 비교했을 때 어떤 차이점이 있습니까?](#XHTML이-HTML과-비교했을-때-어떤-차이점이-있습니까)

[`rel="noopener"` 속성은 어디에서 왜 사용되나요?](#relnoopener-속성은-어디에서-왜-사용되나요)

[HTML5 웹 스토리지란 무엇입니까? `localStorage`와 `sessionStorage`에 대해 설명하세요.](#HTML5-웹-스토리지란-무엇입니까-localStorage와-sessionStorage에-대해-설명하세요)

[WebSQL이란 무엇입니까?](#WebSQL이란-무엇입니까)

['cookie', 'sessionStorage' 및 'localStorage'의 차이점을 설명합니다.](#cookie-sessionStorage-및-localStorage의-차이점을-설명합니다)

[IE 호환 모드를 어떻게 설정합니까?](#IE-호환-모드를-어떻게-설정합니까)

[HTML 5의 새로운 기능은 무엇입니까?](#HTML-5의-새로운-기능은-무엇입니까)

[이전에 다른 HTML 템플릿 언어를 사용한 적이 있습니까?](#이전에-다른-HTML-템플릿-언어를-사용한-적이-있습니까)

[쿠키, 세션 및 로컬 저장소의 차이점 설명](#쿠키-세션-및-로컬-저장소의-차이점-설명)

[거의 표준, 전체 표준 및 쿼크 모드 설명](#거의-표준-전체-표준-및-쿼크-모드-설명)

[`<script>`, `<script async>` 및 `<script defer>`의 차이점을 설명하세요.](#script-script-async-및-script-defer의-차이점을-설명하세요)

[WebP 란 무엇입니까?](#WebP-란-무엇입니까)

[프로그레시브 렌더링이란 무엇입니까?](#프로그레시브-렌더링이란-무엇입니까)

[이미지 태그에 `srcset` 속성을 사용하는 이유는 무엇입니까? 이 속성의 내용을 평가할 때 브라우저가 사용하는 프로세스를 설명하십시오.](#이미지-태그에-srcset-속성을-사용하는-이유는-무엇입니까-이-속성의-내용을-평가할-때-브라우저가-사용하는-프로세스를-설명하십시오)

[HTML5 시맨틱 태그를 사용하는 이유는 무엇입니까?](#HTML5-시맨틱-태그를-사용하는-이유는-무엇입니까)

[HTML 마크업 유효성](#HTML-마크업-유효성)

[doctype이 필요한 이유는 무엇이며 어떤 역할을 합니까?](#doctype이-필요한-이유는-무엇이며-어떤-역할을-합니까)

[전체 표준, 거의 표준 및 쿼크 모드의 차이점은 무엇입니까?](#전체-표준-거의-표준-및-쿼크-모드의-차이점은-무엇입니까)

[다국어 사이트를 디자인하거나 개발할 때 주의해야 할 점은 무엇입니까?](#다국어-사이트를-디자인하거나-개발할-때-주의해야-할-점은-무엇입니까)

[귀하의 사이트에 대해 sv 또는 캔버스를 어떻게 선택하시겠습니까?](#귀하의-사이트에-대해-sv-또는-캔버스를-어떻게-선택하시겠습니까)

[HTML5의 빌딩 블록은 무엇입니까?](#HTML5의-빌딩-블록은-무엇입니까)

[HTML 전처리기란 무엇이며 사용하고 있습니까?](#HTML-전처리기란-무엇이며-사용하고-있습니까)

['메인' 요소의 목적은 무엇입니까?](#메인-요소의-목적은-무엇입니까)

[웹 구성 요소란 무엇입니까?](#웹-구성-요소란-무엇입니까)

[웹 애플리케이션에서 접근성 및 ARIA 역할은 무엇을 의미합니까?](#웹-애플리케이션에서-접근성-및-ARIA-역할은-무엇을-의미합니까)

[HTML로 공개 키를 생성할 수 있습니까?](#HTML로-공개-키를-생성할-수-있습니까)

[CSS `<link>s`를 `<head></head>`와 JS `<script>s` 사이에 배치하는 것이 일반적으로 `</body>` 바로 앞에 있는 이유는 무엇인가요? 예외를 알고 있습니까?](#CSS-links를-headhead와-JS-scripts-사이에-배치하는-것이-일반적으로-body-바로-앞에-있는-이유는-무엇인가요-예외를-알고-있습니까)

[IndexedDB란 무엇입니까?](#IndexedDB란-무엇입니까)



### 다음을 출력하는 HTML 테이블 태그 시퀀스를 작성하십시오.

다음을 출력하는 HTML 테이블 태그 시퀀스를 작성하십시오.
```
50 pcs 100 500
10 pcs 5 50
```

**답:**
```html
<table>
  <tr>
    <td>50 pcs</td>
    <td>100</td>
    <td>500</td>
  </tr>
  <tr>
    <td>10 pcs</td>
    <td>5</td>
    <td>50</td>
  </tr>
</table>
```

###### Source

* https://www.toptal.com/html5/interview-questions

[[↑] 맨 위로](#HTML5)
### iframe이란 무엇이며 어떻게 작동합니까?

**iframe**은 다른 HTML 페이지에 포함될 수 있는 **HTML 문서**입니다.

**예**:

```html
<iframe src="https://github.com" height="300px" width="300px"></iframe>
```

###### Source

* https://github.com/FuelFrontend/Frontend-Developer-Interview-Preparation

[[↑] 맨 위로](#HTML5)
### HTML의 메타 태그 설명

- **Meta tags**는 항상 HTML 페이지의 **head 태그** 안에 들어갑니다.
- **Meta tags**는 항상 이름/값 쌍으로 전달됩니다.
- **Meta tags**는 페이지에 표시되지 않지만 브라우저용입니다.
- **Meta tags**에는 문서의 **character encoding**, **description**, **title** 등에 대한 정보가 포함될 수 있습니다.

**예**:

```html
<!DOCTYPE html>
<html>
<head>
  <meta name="description" content="I am a web page with description"> 
  <title>Home Page</title>
</head>
<body>
  
</body>
</html>
```


###### Source

* https://github.com/FuelFrontend/Frontend-Developer-Interview-Preparation

[[↑] 맨 위로](#HTML5)
### 이미지에서 alt 속성의 목적은 무엇입니까?

'alt' 속성은 사용자가 이미지를 볼 수 없는 경우 이미지에 대한 대체 정보를 제공합니다. 'alt' 속성은 장식 목적으로만 사용되는 이미지를 제외한 모든 이미지를 설명하는 데 사용해야 하며, 이 경우 비워두어야 합니다.


###### Source

* https://developer.mozilla.org/en-US/docs/Learn/Accessibility/HTML

[[↑] 맨 위로](#HTML5)
### self closing tag란?

HTML5에서는 특정 HTML 태그를 닫을 필요가 없습니다. 특정 닫는 태그가 필요하지 않은 태그를 "자체 닫는" 태그라고 합니다.

자동 닫힘 태그의 예로는 줄 바꿈(`<br />`) 또는 메타 태그(`<meta>`)가 있습니다. 이는 다음이 모두 허용됨을 의미합니다.

```html
<meta charset="UTF-8">
...
<meta charset="UTF-8" />
```

###### Source

* http://blog.teamtreehouse.com/to-close-or-not-to-close-tags-in-html5

[[↑] 맨 위로](#HTML5)
### span과 div의 차이점은 무엇입니까?

* `div`는 블록 요소입니다.
* `span`은 인라인 요소입니다.

보너스 포인트의 경우 인라인 요소 내부에 블록 요소를 배치하는 것은 불법이며 'div'에는 'p' 태그가 포함될 수 있고 'p' 태그에는 'span'이 포함될 수 있음을 지적할 수 있습니다. `span`에는 내부에 `div` 또는 `p` 태그가 있을 수 없습니다.

###### Source

* http://thatjsdude.com/INTERVIEW/HTML.HTML

[[↑] 맨 위로](#HTML5)
### 검색 엔진에서 더 나은 색인을 얻으려면 어떻게 해야 합니까?

문서의 `<HEAD>` 부분에 다음 두 문장을 배치하면 더 나은 색인을 생성할 수 있습니다.

```html
<META NAME="keywords" CONTENT="keyword keyword keyword keyword">
<META NAME="description" CONTENT="description of your site">
```
둘 다 최대 1022자를 포함할 수 있습니다. 키워드가 7회 이상 사용되면 키워드 태그가 모두 무시됩니다. 또한 설명 또는 키워드 목록에 마크업(엔티티 제외)을 넣을 수 없습니다.

###### Source

* http://www.freejavaguide.com/html-interview-questions.htm

[[↑] 맨 위로](#HTML5)
### HTML에서 텍스트를 어떻게 강조 표시할 수 있습니까?

HTML5 페이지로 작업하는 경우 `<mark>` 태그를 사용하면 페이지의 텍스트를 빠르고 쉽게 강조 표시하거나 표시할 수 있습니다.

```html
<mark>highlighted text</mark>
```

HTML 코드만으로 텍스트를 강조 표시하고 모든 브라우저를 지원하려면 <span> HTML 태그를 사용하여 아래 예와 같이 배경색 스타일을 설정하십시오.
```html
<span style="background-color: #FFFF00">Yellow text.</span>
```

###### Source

* https://www.computerhope.com/issues/ch001391.htm

[[↑] 맨 위로](#HTML5)
### 다음 HTML5 의미 요소의 올바른 사용법을 간략하게 설명하세요. `<header>`, `<article>`, `<section>`, `<footer>`

* `<header>`는 페이지 섹션에 대한 소개 및 탐색 정보를 포함하는 데 사용됩니다. 여기에는 섹션 제목, 저자 이름, 출판 시간 및 날짜, 목차 또는 기타 탐색 정보가 포함될 수 있습니다.

* `<article>`은 의미를 잃지 않고 페이지 외부에서 논리적으로 독립적으로 다시 만들 수 있는 독립적인 구성을 수용하기 위한 것입니다. 개별 블로그 게시물이나 뉴스 기사가 좋은 예입니다.

* `<섹션>`은 공통 정보 주제 또는 목적을 공유하는 콘텐츠를 담기 위한 유연한 컨테이너입니다.

* `<footer>`는 콘텐츠 섹션의 끝에 나타나야 하는 정보를 담고 있고 섹션에 대한 추가 정보를 포함하는 데 사용됩니다. 작성자 이름, 저작권 정보 및 관련 링크가 이러한 콘텐츠의 대표적인 예입니다.

###### Source

* https://www.w3schools.com/html/html5_semantic_elements.asp

[[↑] 맨 위로](#HTML5)
### 문자 인코딩이란 무엇입니까?

HTML 페이지를 올바르게 표시하려면 웹 브라우저에서 사용할 문자 집합(문자 인코딩)을 알아야 합니다. 이것은 <meta> 태그에 지정됩니다.

**HTML4:**
```html
<meta http-equiv="Content-Type" content="text/html;charset=ISO-8859-1">
```

**HTML5:**
```html
<meta charset="UTF-8">
```


###### Source

* https://www.w3schools.com/html/html_charset.asp

[[↑] 맨 위로](#HTML5)
### HTML5 사양의 주요 목표와 동기는 무엇이었습니까?

HTML5는 HTML 4, XHTML 및 HTML DOM 레벨 2를 대체하도록 설계되었습니다. HTML5 사양의 주요 목표와 동기는 다음과 같습니다.

* Flash와 같은 추가 플러그인 없이 풍부한 콘텐츠(그래픽, 영화 등)를 제공합니다.
* 새로운 구조적 요소 태그를 통해 웹 페이지 구조에 대한 더 나은 의미론적 지원을 제공합니다.
* 더 엄격한 구문 분석 표준을 제공하여 오류 처리를 단순화하고 브라우저 간 동작이 보다 일관되게 하며 이전 표준으로 작성된 문서와의 호환성을 단순화합니다.
* PC, 태블릿 또는 스마트폰에서 실행 여부에 관계없이 더 나은 크로스 플랫폼 지원을 제공합니다.

###### Source

* https://www.toptal.com/html5/interview-questions

[[↑] 맨 위로](#HTML5)
### html 텍스트의 방향을 어떻게 변경합니까?

`dir` 속성은 표시할 텍스트의 기본 방향을 설정하는 데 사용됩니다. 아랍어, 히브리어, 시리아어 및 Thaana와 같이 오른쪽에서 왼쪽으로 쓰는 스크립트에서 HTML을 활성화하는 데 필수적입니다.

```html
<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
<meta charset="utf-8">
...
```

###### Source

* https://html.com/tags/keygen/

[[↑] 맨 위로](#HTML5)
### WebSQL이란 무엇입니까?

- **WebSQL**은 SQL을 사용하는 클라이언트(브라우저) 데이터베이스를 위한 **데이터베이스 API**입니다.
- **SQL**과 유사하게 API는 매우 간단합니다.
- **모든 브라우저가 **지원하는 것은 아닙니다**](http://caniuse.com/#search=websql) WebSQL.
- 현재 WebSQL은 [**더 이상 사용되지 않음**](https://www.w3.org/TR/webdatabase/)입니다.

###### Source

* https://github.com/FuelFrontend/Frontend-Developer-Interview-Preparation

[[↑] 맨 위로](#HTML5)
### 블록 요소와 인라인 요소의 차이점 설명

* *차단 요소*는 웹 페이지에서 사용 가능한 전체 너비를 차지하는 요소로, 왼쪽 또는 오른쪽 옆에 있는 다른 요소를 효과적으로 차단합니다.
* *인라인 요소*는 요소의 내용을 표시하는 데 필요한 만큼만 너비를 차지하므로 다른 요소가 인라인 요소와 일직선이 되도록 합니다.

**공통 블록 요소:**
* Paragraphs (`<p>`)
* Headers (`<h1>` through `<h6>`)
* Divisions (`<div>`)
* Lists and list items (`<ol>`, `<ul>`, and `<li>`)
* Forms (`<form>`)

**일반적인 인라인 요소:**
* Spans (`<span>`)
* Images (`<img>`)
* Anchors (`<a>`)

###### Source

* https://coursework.vschool.io/html-block-vs-inline/

[[↑] 맨 위로](#HTML5)
### optional tag란 무엇입니까?

HTML에서 일부 요소에는 선택적 태그가 있습니다. 사실, 일부 요소의 여는 태그와 닫는 태그는 요소 자체가 필요하더라도 HTML 문서에서 완전히 제거될 수 있습니다.

시작 및 종료 태그가 선택 사항인 세 가지 필수 HTML 요소는 'html', 'head' 및 'body' 요소입니다.

###### Source

* https://www.computerhope.com/issues/ch001391.htm

[[↑] 맨 위로](#HTML5)
### 작은 요소는 언제 사용하는 것이 적절합니까?

HTML `<small>` 요소는 텍스트 글꼴 크기를 브라우저의 최소 글꼴 크기까지 한 사이즈 작게 만듭니다(예: 큰 것에서 중간 또는 작은 것에서 x-small로). HTML5에서 이 요소는 스타일이 지정된 프레젠테이션과 관계없이 저작권 및 법적 텍스트를 포함하여 부수적인 설명과 작은 글씨를 나타내도록 용도가 변경되었습니다.

Consider:
```html
<img src="image.jpg" alt="London by night">
<small>The copyright of this image is owned by Aurelio De Rosa</small>
```

###### Source

* https://developer.mozilla.org/en-US/docs/Web/HTML/Element/small

[[↑] 맨 위로](#HTML5)
### `<section>`과 `<div>`의 차이점은 무엇인가요?

* `<섹션>`은 내부 콘텐츠가 그룹화되어(즉, 단일 테마와 관련됨) 페이지 개요의 항목으로 나타나야 함을 의미합니다.

* 반면에 `<div>`는 class, lang 및 title 속성에서 발견되는 것을 제외하고는 의미를 전달하지 않습니다.

###### Source

* https://stackoverflow.com/questions/6939864/what-is-the-difference-between-section-and-div

[[↑] 맨 위로](#HTML5)
### 웹 작업자란 무엇입니까?

- **Web Workers**는 **백그라운드** **차단 없이** 애플리케이션에서 **자바스크립트 코드**를 실행하는 데 도움이 됩니다.
- **Web Workers**는 자바스크립트 코드 **실행**을 위해 **분리된(새) 스레드**에서 실행됩니다.
- **Web Workers**는 일반적으로 **대규모 작업**에 사용됩니다.
- **Web Workers**는 자바스크립트 코드를 위한 **별도의 파일**이 필요합니다.
- **Web Worker** 파일은 **다운로드** **비동기**입니다.
- **Web Workers**는 모든 **최신** 브라우저에서 [**지원**](http://caniuse.com/#feat=webworkers)됩니다.

**Example**:

아래의 클라이언트 측 js 파일:

```js
var myWebWorker = new Worker("task.js"); // Creating a worker

// Listen to task.js worker messages
worker.addEventListener("message", function(event) {
  console.log("Worker said: ", event.data);
}, false);

worker.postMessage("From web worker file"); // Will start the worker
```

**task.js**(작업자 파일) 파일 아래:

```js
// Listen to client js file post messages
self.addEventListener("message", function(event) {
  self.postMessage(event.data); // Send processed data to listening client js file.
}, false);
```

###### Source

* https://github.com/FuelFrontend/Frontend-Developer-Interview-Preparation

[[↑] 맨 위로](#HTML5)
### DOCTYPE은 무엇을 합니까?

'DOCTYPE'은 "문서 유형"의 약어입니다. 표준 모드와 [쿼크 모드](https://quirks.spec.whatwg.org/#history)를 구분하기 위해 HTML에서 사용하는 선언입니다. 그것의 존재는 브라우저에게 표준 모드에서 웹 페이지를 렌더링하도록 지시합니다.

이야기의 교훈 - 페이지 시작 부분에 `<!DOCTYPE html>`을 추가하기만 하면 됩니다.

###### Source

* https://stackoverflow.com/questions/7695044/what-does-doctype-html-do

[[↑] 맨 위로](#HTML5)
### 여러 언어로 된 콘텐츠가 있는 페이지를 어떻게 제공합니까?

질문은 약간 모호합니다. 가장 일반적인 경우인 여러 언어로 제공되는 콘텐츠가 있는 페이지를 제공하는 방법에 대해 묻는 것으로 가정하지만 페이지 내의 콘텐츠는 일관된 하나의 언어로만 표시되어야 합니다.

HTTP 요청이 서버에 만들어지면 요청하는 사용자 에이전트는 일반적으로 `Accept-Language` 헤더와 같은 언어 기본 설정에 대한 정보를 보냅니다. 그런 다음 서버는 이 정보를 사용하여 적절한 언어로 된 문서 버전을 반환하는 데 사용할 수 있습니다. 반환된 HTML 문서는 `<html>` 태그에 `lang` 속성도 선언해야 합니다(예: `<html lang="en">...</html>`).

백엔드에서 HTML 마크업에는 YML 또는 JSON 형식으로 저장된 특정 언어에 대한 'i18n' 자리 표시자와 콘텐츠가 포함됩니다. 그런 다음 서버는 일반적으로 백엔드 프레임워크의 도움으로 특정 언어로 된 콘텐츠가 포함된 HTML 페이지를 동적으로 생성합니다.

###### Source

* https://www.w3.org/International/getting-started/language

[[↑] 맨 위로](#HTML5)
### 캐시 무효화의 목적은 무엇이며 어떻게 달성할 수 있습니까?

브라우저에는 웹 사이트에 파일을 임시로 저장하는 캐시가 있으므로 페이지 간에 전환하거나 동일한 페이지를 다시 로드할 때 다시 다운로드할 필요가 없습니다. 서버는 주어진 시간 동안 파일을 저장하도록 브라우저에 지시하는 헤더를 보내도록 설정됩니다. 이는 웹사이트 속도를 크게 높이고 대역폭을 보존합니다.

그러나 사용자의 캐시가 여전히 오래된 파일을 참조하기 때문에 개발자가 웹 사이트를 변경한 경우 문제가 발생할 수 있습니다. 캐시된 CSS 및 JavaScript 파일이 더 이상 존재하지 않거나 이동했거나 이름이 변경된 요소를 참조하는 경우 이전 기능을 그대로 유지하거나 웹 사이트를 중단할 수 있습니다.

캐시 무효화는 브라우저가 새 파일을 다운로드하도록 하는 프로세스입니다. 이것은 파일 이름을 이전 파일과 다른 이름으로 지정하여 수행됩니다.

브라우저가 파일을 다시 다운로드하도록 하는 일반적인 기술은 파일 끝에 쿼리 ​​문자열을 추가하는 것입니다.

* `src="js/script.js"` => `src="js/script.js?v=2"`

브라우저는 이를 다른 파일로 간주하지만 파일 이름을 변경할 필요가 없습니다.

###### Source

* https://css-tricks.com/strategies-for-cache-busting-css/

[[↑] 맨 위로](#HTML5)
### 웹 페이지에 여러 <header> 요소가 포함될 수 있습니까? <footer> 요소는 어떻습니까?

둘 다 그렇습니다. W3 문서에 따르면 태그는 가장 가까운 조상 "섹션"의 헤더(`<header>`) 및 바닥글(`<footer>`) 영역을 나타냅니다. 따라서 `<body>` 페이지에는 머리글과 바닥글이 포함될 수 있을 뿐만 아니라 모든 `<article>` 및 `<section>` 요소도 포함될 수 있습니다.

###### Source

* https://stackoverflow.com/questions/4837269/html5-using-header-or-footer-tag-twice?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa

[[↑] 맨 위로](#HTML5)
### `data-` 속성은 무엇에 좋은가요?

JavaScript 프레임워크가 대중화되기 전에 프론트 엔드 개발자는 비표준 속성, DOM의 추가 속성과 같은 다른 해킹 없이 DOM 자체 내에 추가 데이터를 저장하기 위해 `data-` 속성을 사용했습니다. 더 이상 적절한 속성이나 요소가 없는 페이지 또는 응용 프로그램에 대한 사용자 지정 데이터를 비공개로 저장하기 위한 것입니다.

요즘에는 `data-` 속성을 사용하는 것이 권장되지 않습니다. 한 가지 이유는 사용자가 브라우저에서 inspect 요소를 사용하여 데이터 속성을 쉽게 수정할 수 있기 때문입니다. 데이터 모델은 JavaScript 자체에 더 잘 저장되며 라이브러리 또는 프레임워크를 통한 데이터 바인딩을 통해 DOM으로 업데이트된 상태를 유지합니다.

###### Source

* https://www.w3.org/TR/html5/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes

[[↑] 맨 위로](#HTML5)
### `<script>` 태그의 `defer` 및 `async` 속성은 무엇입니까?

속성이 모두 없으면 스크립트가 다운로드되어 동기적으로 실행되며 실행이 완료될 때까지 문서 구문 분석을 중지합니다(기본 동작). 스크립트가 순서대로 다운로드되어 실행됩니다.
그들은 마주친다.

`defer` 속성은 문서가 아직 구문 분석되는 동안 스크립트를 다운로드하지만 문서를 실행하기 전에 구문 분석이 완료될 때까지 기다립니다. 이는 `DOMContentLoaded` 이벤트 리스너 내에서 실행하는 것과 같습니다. `defer` 스크립트는 순서대로 실행됩니다.

`async` 속성은 문서를 구문 분석하는 동안 스크립트를 다운로드하지만 구문 분석이 완전히 완료되기 전에 스크립트를 실행하기 위해 구문 분석기를 일시 중지합니다. 'async' 스크립트가 반드시 순서대로 실행되는 것은 아닙니다.

참고: 두 속성은 스크립트에 `src` 속성이 있는 경우에만 사용해야 합니다(즉, 인라인 스크립트가 아님).

```html
<script src="myscript.js"></script>
<script src="myscript.js" defer></script>
<script src="myscript.js" async></script>
```

###### Source

* http://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html

[[↑] 맨 위로](#HTML5)
### DOM이란 무엇입니까?

*DOM(Document Object Model)*은 HTML 및 XML 문서를 노드로 구성된 트리 구조로 처리하는 크로스 플랫폼 API입니다. 이러한 노드(예: 요소 및 텍스트 노드)는 프로그래밍 방식으로 조작할 수 있는 개체이며 눈에 보이는 변경 사항은 문서에 실시간으로 반영됩니다. 브라우저에서 이 API는 DOM 노드를 조작하여 스타일, 내용, 문서의 배치를 변경하거나 이벤트 리스너를 통해 상호 작용할 수 있는 JavaScript에서 사용할 수 있습니다.

* DOM은 특정 프로그래밍 언어와 독립적으로 설계되어 문서의 구조적 표현을 일관된 단일 API에서 사용할 수 있습니다.
* DOM은 페이지가 로드될 때 브라우저에서 점진적으로 구성되기 때문에 스크립트는 종종 페이지 하단, `defer` 속성이 있는 `<head>` 또는 `DOMContentLoaded` 이벤트 리스너 내부에 배치됩니다. . DOM 노드를 조작하는 스크립트는 오류를 피하기 위해 DOM이 구성된 후에 실행되어야 합니다.
* `document.getElementById()`와 `document.querySelector()`는 DOM 노드를 선택하는 공통 함수입니다.
* `innerHTML` 속성을 새 값으로 설정하면 HTML 파서를 통해 문자열이 실행되어 노드에 동적 HTML 콘텐츠를 쉽게 추가할 수 있습니다.

###### Source

* https://developer.mozilla.org/en-US/docs/DOM

[[↑] 맨 위로](#HTML5)
### HTML 사양과 브라우저 구현 간의 차이점에 대해 논의합니다.

'HTML5'와 같은 HTML 사양은 문서가 해당 사양에 따라 "유효"하기 위해 준수해야 하는 일련의 규칙을 정의합니다. 또한 사양은 브라우저가 이러한 문서를 해석하고 렌더링하는 방법에 대한 지침을 제공합니다.

브라우저가 사양 규칙에 따라 유효한 문서를 처리하는 경우 사양을 "지원"한다고 합니다. 아직까지 'HTML5' 사양의 모든 측면을 지원하는 브라우저는 없으며(모든 주요 브라우저가 대부분 지원하지만) 결과적으로 개발자가 사용 중인 측면이 HTML5 사양을 사용할 것인지 확인해야 합니다. 콘텐츠를 표시하려는 모든 브라우저에서 지원해야 합니다. 이것이 개선된 사양에도 불구하고 브라우저 간 지원이 개발자들에게 계속 골칫거리가 되는 이유입니다.

* `HTML5`는 잘못된 `HTML5` 문서(즉, 구문 오류가 포함된 문서)에 대해 따라야 할 몇 가지 규칙을 정의합니다.
* 단, 유효하지 않은 문서에는 내용이 포함될 수 있으므로 사양에서 모든 가능성을 포괄적으로 처리하는 것은 불가능합니다.
* 따라서 기형 문서를 처리하는 방법에 대한 많은 결정은 브라우저에 달려 있습니다.

###### Source

* https://www.w3.org/TR/html52/

[[↑] 맨 위로](#HTML5)
### XHTML이 HTML과 비교했을 때 어떤 차이점이 있습니까?

몇 가지 주요 차이점은 다음과 같습니다.

* XHTML 요소에는 XHTML `<DOCTYPE>`이 있어야 합니다.
* 속성 값은 따옴표로 묶어야 합니다.
* 속성 최소화는 금지됩니다(예: `checked` 대신 `checked="checked"`를 사용해야 함)
* 요소는 항상 적절하게 중첩되어야 합니다.
* 요소는 항상 닫혀 있어야 합니다.
* 특수 문자는 이스케이프 처리해야 합니다.

###### Source

* https://www.w3schools.com/html/html_xhtml.asp

[[↑] 맨 위로](#HTML5)
### `rel="noopener"` 속성은 어디에서 왜 사용되나요?

`rel="noopener"`는 `<a>` 요소(하이퍼링크)에 사용되는 속성입니다. 이는 페이지가 링크가 열린 페이지를 가리키고 하이퍼링크에서 열린 페이지가 하이퍼링크가 있는 페이지를 조작할 수 있도록 하는 `window.opener` 속성을 갖는 것을 방지합니다.

###### Source

* https://developers.google.com/web/tools/lighthouse/audits/noopener

[[↑] 맨 위로](#HTML5)
### HTML5 웹 스토리지란 무엇입니까? `localStorage`와 `sessionStorage`에 대해 설명하세요.

HTML5를 사용하면 웹 페이지는 사용자의 브라우저 내에서 로컬로 데이터를 저장할 수 있습니다.
데이터는 이름/값 쌍으로 저장되며 웹 페이지는 자체적으로 저장된 데이터에만 액세스할 수 있습니다.

**수명에 관한 `localStorage`와 `sessionStorage`의 차이점:**

* 'localStorage'를 통해 저장된 데이터는 영구적입니다. 웹 앱이 데이터를 삭제하거나 사용자가 브라우저에서 삭제를 요청할 때까지 만료되지 않고 사용자의 컴퓨터에 저장된 상태로 유지됩니다.
* `sessionStorage`는 데이터가 저장된 최상위 창 또는 브라우저 탭과 동일한 수명을 가집니다. 탭이 영구적으로 닫히면 'sessionStorage'를 통해 저장된 모든 데이터가 삭제됩니다.

**저장 범위에 관한 `localStorage`와 `sessionStorage`의 차이점:**

두 가지 저장 형식 모두 문서 원본으로 범위가 지정되므로 원본이 다른 문서는 저장된 개체를 공유하지 않습니다.

* `sessionStorage`도 창 단위로 범위가 지정됩니다. 동일한 출처의 문서가 있는 두 개의 브라우저 탭에는 별도의 'sessionStorage' 데이터가 있습니다.
* `localStorage`와 달리 동일한 출처의 동일한 스크립트가 다른 탭에서 열릴 때 서로의 `sessionStorage`에 액세스할 수 없습니다.

###### Source

* https://www.w3schools.com/html/html5_webstorage.asp

[[↑] 맨 위로](#HTML5)
### WebSQL이란 무엇입니까?

- **WebSQL**은 SQL을 사용하는 클라이언트(브라우저) 데이터베이스를 위한 **데이터베이스 API**입니다.
- **SQL**과 유사하게 API는 매우 간단합니다.
- **모든 브라우저가 **지원하는 것은 아닙니다**](http://caniuse.com/#search=websql) WebSQL.
- 현재 WebSQL은 [**더 이상 사용되지 않음**](https://www.w3.org/TR/webdatabase/)입니다.

###### Source

* https://github.com/FuelFrontend/Frontend-Developer-Interview-Preparation

[[↑] 맨 위로](#HTML5)
### 'cookie', 'sessionStorage' 및 'localStorage'의 차이점을 설명합니다.

위에서 언급한 모든 기술은 클라이언트 측의 키-값 저장 메커니즘입니다. 값을 문자열로만 저장할 수 있습니다.

|                                        | `cookie`                                                 | `localStorage` | `sessionStorage` |
| -------------------------------------- | -------------------------------------------------------- | -------------- | ---------------- |
| Initiator                              | Client or server. Server can use `Set-Cookie` header     | Client         | Client           |
| Expiry                                 | Manually set                                             | Forever        | On tab close     |
| Persistent across browser sessions     | Depends on whether expiration is set                     | Yes            | No               |
| Sent to server with every HTTP request | Cookies are automatically being sent via `Cookie` header | No             | No               |
| Capacity (per domain)                  | 4kb                                                      | 5MB            | 5MB              |
| Accessibility                          | Any window                                               | Any window     | Same tab         |

###### Source

* https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies

[[↑] 맨 위로](#HTML5)
### IE 호환 모드를 어떻게 설정합니까?

- 콘텐츠 **IE=edge**와 함께 **http-equiv=X-UA-Compatible** 메타 태그 사용
- **IE=edge** 모드는 **Internet Explorer**가 사용 가능한 최고 모드에서 콘텐츠를 표시하도록 지시합니다.

**예**:

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="description" content="I am a web page with description"> 
  <title>Home Page</title>
</head>
<body>
  
</body>
</html>
```

###### Source

* https://github.com/FuelFrontend/Frontend-Developer-Interview-Preparation

[[↑] 맨 위로](#HTML5)
### HTML 5의 새로운 기능은 무엇입니까?

HTML 5는 HTML 사양에 많은 새로운 기능을 추가합니다.

**새 문서 유형**

아직도 그 성가시고 외우기 불가능한 XHTML 문서 유형을 사용하고 있습니까?

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
```

그렇다면 왜? 새 HTML5 문서 유형으로 전환합니다. 당신은 더 오래 살 것입니다 -- 더글라스 퀘이드가 말했듯이.

```html
<!DOCTYPE html>
```

**새로운 구조**

- `<section>` - 페이지의 섹션을 정의합니다.
- `<header>` - 페이지의 헤더를 정의합니다.
- `<footer>` - 페이지의 바닥글을 정의합니다.
- `<nav>` - 페이지의 탐색을 정의합니다.
- `<article>` - 페이지의 기사 또는 주요 콘텐츠를 정의합니다.
- `<aside>` - 페이지의 사이드바와 같은 추가 콘텐츠를 정의합니다.
- `<Figure>` - 기사에 주석을 추가하는 이미지를 정의합니다.

**새로운 인라인 요소**

이러한 인라인 요소는 몇 가지 기본 개념을 정의하고 대부분 시간과 관련하여 의미적으로 마크업된 상태로 유지합니다.

- `<mark>` - 어떤 방식으로 표시된 콘텐츠를 나타냅니다.
- `<time>` - 시간 또는 날짜인 내용을 나타냅니다.
- `<meter>` - 디스크 사용량과 같이 알려진 범위의 일부인 콘텐츠를 나타냅니다.
- `<progress>` - 완료를 향한 작업의 진행 상황을 나타냅니다.

**새 양식 유형**

- `<입력 유형="날짜/시간">`
- `<입력 유형="날짜 시간-로컬">`
- `<입력 유형="날짜">`
- `<입력 유형="월">`
- `<입력 유형="주">`
- `<입력 유형="시간">`
- `<입력 유형="숫자">`
- `<입력 유형="범위">`
- `<입력 유형="이메일">`
- `<입력 유형="url">`

**새로운 요소**

HTML 5에는 몇 가지 흥미로운 새 요소가 있습니다.

- `<canvas>` - 웹 페이지의 JavaScript에서 그리기 공간을 제공하는 요소입니다. 도구 설명에 이미지나 그래프를 추가하거나 웹 페이지에서 즉석에서 구축된 동적 그래프를 생성할 수 있습니다.
- `<video>` - 이 간단한 태그를 사용하여 웹 페이지에 비디오를 추가합니다.
- `<audio>` - 이 간단한 태그를 사용하여 웹 페이지에 사운드를 추가합니다.

**스크립트 및 링크 유형이 더 이상 필요하지 않음**

여전히 `link` 및 `script` 태그에 `type` 속성을 추가할 수 있습니다.

```html
<link rel="stylesheet" href="path/to/stylesheet.css" type="text/css" />
<script type="text/javascript" src="path/to/script.js"></script>
```

이것은 더 이상 필요하지 않습니다. 이 두 태그는 각각 스타일시트와 스크립트를 참조한다는 의미입니다. 따라서 `type` 속성을 함께 제거할 수 있습니다.

```html
<link rel="stylesheet" href="path/to/stylesheet.css" />
<script src="path/to/script.js"></script>
```

**콘텐츠를 편집 가능하게 만들기**

새 브라우저에는 'contenteditable'이라는 요소에 적용할 수 있는 멋진 새 속성이 있습니다. 이름에서 알 수 있듯이 사용자는 자식을 포함하여 요소 내에 포함된 모든 텍스트를 편집할 수 있습니다. 로컬 저장소를 활용하는 할일 목록처럼 간단한 앱을 포함하여 이와 같이 다양한 용도로 사용할 수 있습니다.

```html
<h2> To-Do List </h2>
<ul contenteditable="true">
  <li> Break mechanical cab driver. </li>
  <li> Drive to abandoned factory
  <li> Watch video of self </li>
</ul>
```

**속성**

- 양식 필드를 언급하려면 `require`가 필요합니다.
- '자동 초점'은 커서를 입력 필드에 놓습니다.

###### Source

* https://github.com/FuelFrontend/Frontend-Developer-Interview-Preparation

[[↑] 맨 위로](#HTML5)
### 이전에 다른 HTML 템플릿 언어를 사용한 적이 있습니까?

네
* Pug (formerly Jade), 
* ERB, 
* Slim, 
* Handlebars, 
* Jinja, 
* Liquid 

몇가지 말하자면. 내 생각에, 그것들은 거의 동일하며 표시할 데이터를 조작하기 위한 유용한 필터 및 콘텐츠 이스케이프와 유사한 기능을 제공합니다. 대부분의 템플릿 엔진은 표시하기 전에 사용자 정의 처리가 필요한 경우에 고유한 필터를 삽입할 수도 있습니다.

###### Source

* fullstack.cafe

[[↑] 맨 위로](#HTML5)
### 쿠키, 세션 및 로컬 저장소의 차이점 설명

**Cookies**

- **제한된** 저장 공간 **4096바이트/~4kb**
- **문자열**로만 데이터 저장 허용
- 저장된 데이터는 HTML, CSS, 이미지 등과 같은 모든 **HTTP 요청**에 대해 서버로 다시 전송됩니다.
- **도메인당 20개의 쿠키만 저장할 수 있음**
- 사이트에서 허용되는 총 쿠키 수는 **300**개입니다.
- **HTTP 전용** 플래그를 설정하면 자바스크립트를 통해 **쿠키에 액세스하는 것을 방지**
- 자동 삭제를 위한 **만료** 기간 설정 가능(서버 또는 클라이언트에서 설정 가능)

**예**:

```js
// Set with expiration & path
document.cookie = "name=Gokul; expires=Thu, 18 Dec 2016 12:00:00 UTC; path=/;";

// Get
document.cookie;

// Delete by setting empty value and same path
document.cookie = "name=; expires=Thu, 18 Dec 2016 12:00:00 UTC; path=/;";
```

**Session Storage**

- 저장 공간은 **5mb / ~5120kb**입니다.
- 저장 공간은 브라우저에 따라 **약간** 다를 수 있습니다.
- **문자열**로만 데이터 저장 허용
- **창 또는 탭**별로 데이터를 사용할 수 있습니다.
- 창이나 탭이 닫히면 저장된 데이터는 **삭제**됩니다.
- 데이터는 **동일한 출처에서만 사용 가능합니다**

**예**:

```js
// Set
sessionStorage.setItem("name", "gokul");

// Get
sessionStorage.getItem("name"); // gokul

// Delete
sessionStorage.removeItem("name"); 

// Delete All
sessionStorage.clear();
```

**Local Storage**

- 저장 공간은 **5mb / ~5120kb**입니다.
- 저장 공간은 브라우저에 따라 **약간** 다를 수 있습니다.
- **문자열**로만 데이터 저장 허용
- 데이터는 **동일한 출처에서만 사용 가능합니다**
- 데이터는 **영구적**입니다(명시적으로 삭제될 때까지).
- API는 세션 스토리지와 유사합니다.

**예**:

```js
// Set
localStorage.setItem("name", "gokul");

// Get
localStorage.getItem("name"); // gokul

// Delete
localStorage.removeItem("name"); 

// Delete All
localStorage.clear();
```

###### Source

* https://github.com/FuelFrontend/Frontend-Developer-Interview-Preparation

[[↑] 맨 위로](#HTML5)
### 거의 표준, 전체 표준 및 쿼크 모드 설명

이제 웹 브라우저의 레이아웃 엔진이 사용하는 세 가지 모드가 있습니다: 쿼크 모드, 거의 표준 모드 및 전체 표준 모드.
* **쿼크 모드**에서 레이아웃은 Navigator 4 및 Internet Explorer 5의 비표준 동작을 에뮬레이트합니다. 이는 웹 표준이 널리 채택되기 전에 구축된 웹 사이트를 지원하기 위해 필수적입니다.
* **전체 표준 모드**에서 동작은 (바라건대) HTML 및 CSS 사양에 설명된 동작입니다.
* **거의 표준 모드**에서는 구현된 단점이 매우 적습니다.

HTML 문서의 경우 브라우저는 문서 시작 부분에 'DOCTYPE'을 사용하여 문서를 쿼크 모드에서 처리할지 표준 모드에서 처리할지 결정합니다.

###### Source

* https://developer.mozilla.org/en-US/docs/Web/HTML/Quirks_Mode_and_Standards_Mode

[[↑] 맨 위로](#HTML5)
### `<script>`, `<script async>` 및 `<script defer>`의 차이점을 설명하세요.

* `<script>` - HTML 구문 분석이 차단되고 스크립트가 즉시 가져와 실행되며 스크립트가 실행된 후 HTML 구문 분석이 다시 시작됩니다.
* `<script async>` - 스크립트는 HTML 구문 분석과 병렬로 가져와 사용 가능한 즉시 실행됩니다(HTML 구문 분석이 완료되기 전에 가능). 스크립트가 페이지의 다른 스크립트(예: 분석)와 독립적인 경우 'async'를 사용합니다.
* `<script defer>` - 스크립트는 HTML 구문 분석과 병렬로 가져오고 페이지 구문 분석이 완료되면 실행됩니다. 여러 스크립트가 있는 경우 지연된 각 스크립트는 문서에서 발생한 순서대로 실행됩니다. 스크립트가 완전히 구문 분석된 DOM에 의존하는 경우 `defer` 속성은 실행 전에 HTML이 완전히 구문 분석되었는지 확인하는 데 유용합니다. `<body>` 끝에 일반 `<script>`를 넣어도 큰 차이는 없습니다. 지연된 스크립트에는 `document.write`가 포함되어서는 안 됩니다.

참고: `src` 속성이 없는 스크립트의 경우 `async` 및 `defer` 속성이 무시됩니다.

###### Source

* https://stackoverflow.com/questions/10808109/script-tag-async-defer

[[↑] 맨 위로](#HTML5)
### WebP 란 무엇입니까?

- **WebP**는 **jpg**, **png**와 같은 이미지 형식으로, 다른 형식보다 **약** **10-20% 더 작은** 크기입니다.
- **2010년**에 **Google**에서 **개발** 및 **도입**했습니다.
- **모든 브라우저가 **WebP를 지원하는 것은 아닙니다**.
- 플러그인을 사용하여 다른 형식을 **WebP**로 변환할 수 있습니다.

###### Source

* https://github.com/FuelFrontend/Frontend-Developer-Interview-Preparation

[[↑] 맨 위로](#HTML5)
### 프로그레시브 렌더링이란 무엇입니까?

*Progressive rendering*은 가능한 한 빨리 표시할 콘텐츠를 렌더링하기 위해 웹페이지의 성능을 향상(특히, 인지된 로드 시간 개선)하는 데 사용되는 기술에 부여된 이름입니다.

광대역 인터넷 이전에는 훨씬 더 널리 사용되었지만 모바일 데이터 연결이 점점 더 대중화되고(그리고 불안정해짐) 현대 개발에서는 여전히 사용됩니다!

이러한 기술의 예:

* 이미지 로딩 지연 - 페이지의 이미지가 한번에 로딩되지 않습니다. JavaScript는 사용자가 이미지를 표시하는 페이지 부분으로 스크롤할 때 이미지를 로드하는 데 사용됩니다.
* 가시적 콘텐츠(또는 스크롤 없이 볼 수 있는 렌더링) 우선 순위 지정 - 사용자 브라우저에서 먼저 렌더링될 페이지의 양에 필요한 최소한의 CSS/콘텐츠/스크립트만 포함하여 가능한 빨리 표시한 다음 지연을 사용할 수 있습니다. 스크립트를 사용하거나 `DOMContentLoaded`/`load` 이벤트를 수신하여 다른 리소스 및 콘텐츠를 로드합니다.
* 비동기 HTML 조각 - 페이지가 백엔드에서 구성될 때 HTML의 일부를 브라우저로 플러시합니다. 이 기술에 대한 자세한 내용은 [여기]

###### Source

* https://stackoverflow.com/questions/33651166/what-is-progressive-rendering

[[↑] 맨 위로](#HTML5)
### 이미지 태그에 `srcset` 속성을 사용하는 이유는 무엇입니까? 이 속성의 내용을 평가할 때 브라우저가 사용하는 프로세스를 설명하십시오.

장치 디스플레이 너비에 따라 사용자에게 다른 이미지를 제공하려는 경우 `srcset` 속성을 사용합니다. 레티나 디스플레이가 있는 장치에 더 높은 품질의 이미지를 제공하면 사용자 경험이 향상되고 낮은 해상도의 이미지를 저사양 장치에 제공하면 성능이 향상되고 성능이 향상됩니다. 데이터 낭비를 줄입니다(더 큰 이미지를 제공하더라도 눈에 띄는 차이가 없기 때문).

예: `<img srcset="small.jpg 500w, medium.jpg 1000w, large.jpg 2000w" src="..." alt="">`는 브라우저에 소형, 중형 또는 대형 `을 표시하도록 지시합니다. jpg` 그래픽은 클라이언트의 해상도에 따라 다릅니다. 첫 번째 값은 이미지 이름이고 두 번째 값은 픽셀 단위의 이미지 너비입니다. 장치 너비가 320px인 경우 다음 계산이 수행됩니다.

* 500 / 320 = 1.5625
* 1000 / 320 = 3.125
* 2000 / 320 = 6.25

클라이언트의 해상도가 1x라면 1.5625가 가장 가깝고 'small.jpg'에 해당하는 '500w'가 브라우저에서 선택됩니다.

해상도가 레티나(2x)인 경우 브라우저는 최소값보다 높은 가장 가까운 해상도를 사용합니다. 1보다 크고 이미지가 나빠 보일 수 있기 때문에 500w(1.5625)를 선택하지 않음을 의미합니다. 그런 다음 브라우저는 결과 비율이 1000w(3.125)인 2에 더 가까운 이미지를 선택합니다.

`srcset`은 데스크탑 디스플레이와 같이 큰 이미지가 필요하지 않기 때문에 좁은 화면 장치에 더 작은 이미지 파일을 제공하려는 문제를 해결하고 선택적으로 다른 해상도 이미지를 고밀도/저밀도로 제공하려는 경우 밀도 스크린.

###### Source

* https://css-tricks.com/responsive-images-youre-just-changing-resolutions-use-srcset/

[[↑] 맨 위로](#HTML5)
### HTML5 시맨틱 태그를 사용하는 이유는 무엇입니까?

이름에서 알 수 있듯이 이것은 의미론적 목적만을 위한 것입니다. 문서의 자동화된 처리를 개선하기 위한 것입니다. 자동화된 처리는 생각보다 자주 발생합니다. 검색 엔진의 각 웹사이트 순위는 모든 웹사이트의 자동화된 처리에서 파생됩니다.

```html
// machine: okay, this structure looks like it might be a navigation element?
<div class="some-meaningless-class"><ul><li><a href="internal_link">...</div>

// machine: ah, a navigation element!
<nav class="some-meaningless-class"><ul><li><a>...</nav>
```

###### Source

* https://stackoverflow.com/questions/17272019/why-to-use-html5-semantic-tag-instead-of-div

[[↑] 맨 위로](#HTML5)
### HTML 마크업 유효성

다음 마크업을 고려하십시오. 유효합니까? 그렇지 않다면 그 이유를 설명할 수 있습니까?

```html
<figure>
   <picture>
      <source media="(min-width: 40em)"
      srcset="large.jpg 1024w, medium.jpg 640w, small.jpg 320y">
      <img src="medium.jpg" alt="London by night">
   </picture>
   <figcaption>A landscape of London by night</figcaption>
</figure>
```

**답변:**

마크업은 비교적 새로운 그림 요소를 사용합니다. 코드는 srcset 속성에 지정된 마지막 이미지를 제외하고 모두 유효합니다. '320y'는 유효한 값이 아니며 'y'는 'w'로 바꿔야 합니다.

###### Source

* https://www.sitepoint.com/10-typical-html-interview-exercises/

[[↑] 맨 위로](#HTML5)
### doctype이 필요한 이유는 무엇이며 어떤 역할을 합니까?

Doctype은 두 가지 작업을 수행합니다.

* 사용 중인 HTML의 방언을 식별합니다.
* 브라우저가 문서를 렌더링하기 위해 "표준" 또는 "특이한" 모드를 사용할지 여부를 제어합니다.

문서 유형이 없거나 인식할 수 없는 문서 유형이 있는 경우 "특이한" 모드를 사용하고 문서를 최대한 해석합니다. IS doctype이 있고 이를 인식하면 표준을 따릅니다. 렌더링 결과는 문서를 해석하는 방식에 따라 달라질 수 있습니다.

###### Source

* https://stackoverflow.com/questions/6076432/why-do-i-need-a-doctype-what-does-it-do

[[↑] 맨 위로](#HTML5)
### 전체 표준, 거의 표준 및 쿼크 모드의 차이점은 무엇입니까?

**web**이 **세계에 처음 등장했을 때** 웹페이지는 두 가지 버전으로 작성되었습니다.

- Netscape Navigator
- Internet Explorer 

**W3C**(World Wide Web Consortium)가 웹에 대한 새로운 표준을 도입했을 때 브라우저는 **새로운** 및 **이전 웹 표준**을 지원하기 위해 **두 가지 레이아웃 모드**를 도입했습니다.

그 모드들은

- Quirks mode
- Standard mode
- Almost standard mode

**Quirks Mode**

- 브라우저는 **Netscape Navigator 4** 및 **Internet Explorer 5**에서 **비표준** 동작을 에뮬레이트합니다.
- **웹 표준** 이전에 구축된 웹사이트를 지원하기 위해 필수적이었습니다.

**Full Standard Mode**

- **Full Standard** 모드에서 브라우저의 동작은 **HTML & CSS** 사양과 동일합니다.
- 거의 **모든** 최신 브라우저가 **전체 표준 모드**를 사용합니다.

전체 표준 모드를 ​​사용하려면 HTML 문서에 `<!DOCTYPE html>`을 지정하세요.

```html
<!DOCTYPE html>
<html>
<head>
  <title>Document title</title>
</head>
<body>

</body>
</html>
```

**Almost Standard Mode**

- **거의 표준** 모드에서 브라우저의 동작은 **전체 표준 모드**와 동일하지만 매우 적은 수의 단점 구현

###### Source

* https://github.com/FuelFrontend/Frontend-Developer-Interview-Preparation

[[↑] 맨 위로](#HTML5)
### 다국어 사이트를 디자인하거나 개발할 때 주의해야 할 점은 무엇입니까?

* HTML에서 `lang` 속성을 사용하세요.
* 사용자를 모국어로 안내 - 사용자가 번거로움 없이 쉽게 국가/언어를 변경할 수 있습니다.
* 이미지의 텍스트는 확장 가능한 접근 방식이 아닙니다. 이미지에 텍스트를 배치하는 것은 여전히 ​​모든 컴퓨터에 표시할 보기 좋은 비시스템 글꼴을 얻는 인기 있는 방법입니다. 그러나 이미지 텍스트를 번역하려면 각 텍스트 문자열에 언어별로 생성된 별도의 이미지가 있어야 합니다. 이와 같은 소수의 대체품보다 더 많은 것은 빠르게 통제 불능 상태가 될 수 있습니다.
* 단어/문장 길이 제한 - 일부 내용은 다른 언어로 작성 시 더 길어질 수 있습니다. 디자인에서 레이아웃 또는 오버플로 문제에 주의하십시오. 많은 양의 텍스트가 디자인을 만들거나 끊을 수 있는 디자인을 피하는 것이 가장 좋습니다. 문자 수는 헤드라인, 레이블 및 버튼과 같은 요소와 관련이 있습니다. 본문이나 주석과 같이 자유롭게 흐르는 텍스트에서는 문제가 되지 않습니다.
* 색상이 인식되는 방식에 유의하십시오. 색상은 언어와 문화에 따라 다르게 인식됩니다. 디자인은 색상을 적절하게 사용해야 합니다.
* 날짜 및 통화 형식 지정 - 달력 날짜는 때때로 다른 방식으로 표시됩니다. 예. 미국의 "2012년 5월 31일" 대 유럽 일부의 "2012년 5월 31일".
* 번역된 문자열을 연결하지 마십시오 - `"오늘 날짜는 " + date`와 같은 작업을 수행하지 마십시오. 다른 단어 순서로 언어에서 깨집니다. 대신 각 언어에 대한 매개변수 대체가 있는 템플릿 문자열을 사용하십시오. 예를 들어 영어와 중국어로 각각 `I will travel on {% date %}` 및 `{% date %} 我会出发`의 두 문장을 보세요. 변수의 위치는 언어의 문법 규칙에 따라 다릅니다.
* 언어 읽기 방향 - 영어는 왼쪽에서 오른쪽, 위에서 아래로, 전통 일본어는 텍스트를 위에서 아래, 오른쪽에서 왼쪽으로 읽습니다.

###### Source

* https://www.quora.com/What-kind-of-things-one-should-be-wary-of-when-designing-or-developing-for-multilingual-sites

[[↑] 맨 위로](#HTML5)
### 귀하의 사이트에 대해 sv 또는 캔버스를 어떻게 선택하시겠습니까?

SVG는 XML에서 2D 그래픽을 설명하기 위한 언어입니다. Canvas는 JavaScript를 사용하여 즉석에서 2D 그래픽을 그립니다. SVG와 Canvas의 차이점은 올바른 것을 선택하는 데 도움이 될 것입니다.

**Canvas**

* 해상도에 따라 다름
* 이벤트 핸들러를 지원하지 않음
* 빈약한 텍스트 렌더링 기능
* 결과 이미지를 .png 또는 .jpg로 저장할 수 있습니다.
* 그래픽 집약적인 게임에 적합

**SVG**

* 해상도 독립
* 이벤트 핸들러 지원
* 렌더링 영역이 큰 애플리케이션에 가장 적합(Google 지도)
* 복잡한 경우 느린 렌더링(DOM을 많이 사용하는 것은 모두 느림)
* 게임 애플리케이션에는 적합하지 않음

**Conclusion:** 
* SVG는 항목이 거의 없는 애플리케이션 및 앱에 더 좋습니다.
* Canvas는 수천 개의 개체와 세심한 조작에 더 적합하지만, 이를 구현하려면 훨씬 더 많은 코드(또는 라이브러리)가 필요합니다.

###### Source

* https://stackoverflow.com/questions/5882716/html5-canvas-vs-svg-vs-div

[[↑] 맨 위로](#HTML5)
### HTML5의 빌딩 블록은 무엇입니까?

* **Semantics** - 콘텐츠가 무엇인지 더 정확하게 설명할 수 있습니다.
* **연결성** - 새롭고 혁신적인 방식으로 서버와 통신할 수 있습니다.
* **오프라인 및 스토리지** - 웹페이지가 클라이언트 측에서 로컬로 데이터를 저장하고 오프라인에서 보다 효율적으로 작동할 수 있습니다.
* **멀티미디어** - Open Web에서 비디오 및 오디오를 일류 시민으로 만듭니다.
* **2D/3D 그래픽 및 효과** - 훨씬 더 다양한 프레젠테이션 옵션을 허용합니다.
* **성능 및 통합** - 컴퓨터 하드웨어의 더 나은 속도 최적화 및 더 나은 사용을 제공합니다.
* **디바이스 접근** - 다양한 입출력 디바이스의 사용을 허용합니다.
* **스타일링** - 작성자가 보다 정교한 테마를 작성할 수 있습니다.

###### Source

* https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5

[[↑] 맨 위로](#HTML5)
### HTML 전처리기란 무엇이며 사용하고 있습니까?

HTML 전처리기는 **적은 코드**로 **더 빠르게** HTML 코드를 작성하는 데 도움이 됩니다.

**일부 전처리기는**:

- Pug
- Haml

**예**: **`index.jade`**

```html
html
  head
    title= HelloWorld
  body
    h1 Using Jade to create HelloWorld web page
```

**Compiled file**: **`index.html`**

```html
<!DOCTYPE html>
<html>
  <head>
    <title>HelloWorld</title>
  <body>
    <h1>Using Jade to create HelloWorld web page</h1>
  </body>
</html>
```

###### Source

* https://github.com/FuelFrontend/Frontend-Developer-Interview-Preparation

[[↑] 맨 위로](#HTML5)
### '메인' 요소의 목적은 무엇입니까?

HTML `<main>` 요소는 문서의 `<body>`, 문서의 일부 또는 애플리케이션의 주요 내용을 나타냅니다. 주요 콘텐츠 영역은 문서의 중심 주제 또는 응용 프로그램의 중심 기능과 직접 관련되거나 확장되는 콘텐츠로 구성됩니다. `<main>`의 한 가지 중요한 측면은 페이지당 한 번만 사용할 수 있다는 것입니다.

`<main>`은 문서의 개요에 기여하지 않습니다. 즉, `<body>`와 같은 요소, `<h2>`와 같은 제목과 달리` <main>`은 페이지 구조에 대한 DOM의 개념에 영향을 미치지 않습니다. 철저하게 정보를 제공합니다.

###### Source

* https://developer.mozilla.org/en-US/docs/Web/HTML/Element/main

[[↑] 맨 위로](#HTML5)
### 웹 구성 요소란 무엇입니까?

- 웹 컴포넌트는 웹 플랫폼 API의 집합입니다.
- 웹 구성 요소를 사용하면 웹 응용 프로그램에서 **사용자 정의 재사용 가능한 위젯** 또는 **구성 요소**를 만들 수 있습니다.
- 웹 구성 요소는 **브라우저의 일부**이며 **모든 최신 브라우저**에서 **작동**합니다.
- 웹 구성 요소는 **필요하지 않습니다** **작동**하기 위해 **외부 라이브러리**가 필요하지 않습니다.

**특징**

- 사용자 정의 요소 - **완벽한 기능을 갖춘** DOM 요소를 자체적으로 작성합니다.
- Shadow DOM - 웹 페이지에 대한 **iframe**, **style** 및 **markup**의 최고의 기능을 제공합니다.
- HTML 템플릿 - 웹페이지에 일부 **마크업을 **저장**할 수 있으며 나중에 **복제** 및 **재사용**할 수 있습니다.
- HTML 가져오기 - **외부 HTML 문서**를 **가져오기** 허용합니다.

###### Source

* https://github.com/FuelFrontend/Frontend-Developer-Interview-Preparation

[[↑] 맨 위로](#HTML5)
### 웹 애플리케이션에서 접근성 및 ARIA 역할은 무엇을 의미합니까?

접근성이란 사용자가 어떤 방법으로든 웹 사이트를 탐색하고 상호 작용할 수 있도록 하는 것을 의미합니다. 키보드, 마우스 또는 장애가 있거나 장애가 있는 사람이 되자.

- **ARIA**는 **액세스 가능한 리치 인터넷 애플리케이션**을 나타냅니다.
- **ARIA**는 **W3C**의 **사양**입니다.
- **ARIA**는 **웹 애플리케이션**의 **접근성 향상**을 위해 만들어졌습니다.
- **ARIA**는 **HTML 속성**을 통해 **스크린 리더**에 **추가 정보**를 제공합니다.
- **ARIA** **요소**가 브라우저에서 **렌더링**되는 방식에 영향을 미치지 않습니다**.

###### Source

* https://github.com/FuelFrontend/Frontend-Developer-Interview-Preparation

[[↑] 맨 위로](#HTML5)
### HTML로 공개 키를 생성할 수 있습니까?

`<keygen>` 요소는 공개-개인 키 쌍을 생성하고 양식 제출과 함께 공개 키를 서버에 보냅니다. 요소는 더 이상 사용되지 않을 것으로 예상되며 광범위한 브라우저 지원이 없습니다.

두 당사자가 안전하게 통신하려면 공개-개인 키 쌍을 생성한 다음 공개 키를 상대방과 공유할 수 있어야 합니다. `<keygen>`은 HTML 형식의 컨텍스트 내에서 이를 용이하게 하기 위한 것입니다. 그것을 구현하는 브라우저에서(모두가 그렇지는 않음) 요소가 양식에 포함되어 있으면 브라우저는 키 쌍을 로컬로 생성하고 양식이 제출될 때 공개 키를 서버로 보냅니다. 그런 다음 개인 키는 공유되지 않고 로컬에 저장됩니다.

`<keygen>` 요소가 더 이상 사용되지 않으며 HTML5 표준에서 제거될 것이라고 발표되었습니다. 이는 키 생성의 대체 방법이 필요함을 의미합니다. 당연히 이것은 단순히 JavaScript를 사용하는 것을 의미합니다.

###### Source

* https://html.com/tags/keygen/

[[↑] 맨 위로](#HTML5)
### CSS `<link>s`를 `<head></head>`와 JS `<script>s` 사이에 배치하는 것이 일반적으로 `</body>` 바로 앞에 있는 이유는 무엇인가요? 예외를 알고 있습니까?

**`<head>`에 `<link>` 배치**

헤드에 `<link>`를 넣는 것은 사양의 일부입니다. 그 외에도 상단에 배치하면 페이지가 점진적으로 렌더링되어 사용자 경험이 향상됩니다. 문서 맨 아래에 스타일시트를 배치할 때의 문제는 Internet Explorer를 포함한 많은 브라우저에서 프로그레시브 렌더링을 금지한다는 것입니다. 일부 브라우저는 스타일이 변경되는 경우 페이지 요소를 다시 칠하지 않아도 되도록 렌더링을 차단합니다. 사용자가 빈 흰색 페이지를 보고 있습니다. 스타일이 지정되지 않은 콘텐츠의 플래시를 방지합니다.

**`</body>` 바로 앞에 `<script>` 배치**

`<script>`는 다운로드 및 실행되는 동안 HTML 구문 분석을 차단합니다. 맨 아래에 있는 스크립트를 다운로드하면 HTML을 구문 분석하여 사용자에게 먼저 표시할 수 있습니다.

맨 아래에 `<script>`의 위치 지정에 대한 예외는 스크립트에 `document.write()`가 포함되어 있는 경우이지만 요즘에는 `document.write()`를 사용하는 것이 좋지 않습니다. 또한 `<script>`를 맨 아래에 배치하면 전체 문서가 구문 분석될 때까지 브라우저에서 스크립트 다운로드를 시작할 수 없습니다. 한 가지 가능한 해결 방법은 `<head>`에 `<script>`를 넣고 `defer` 속성을 사용하는 것입니다.

###### Source

* https://developer.yahoo.com/performance/rules.html#css_top

[[↑] 맨 위로](#HTML5)
### IndexedDB란 무엇입니까?

- **IndexedDB**는 자바스크립트 기반 **객체 지향 데이터베이스**입니다.
- **IndexedDB**는 **대량**의 **데이터**를 웹 애플리케이션에 저장하려는 경우에 유용합니다.
- **IndexedDB**는 데이터를 **키-값** 쌍으로 저장합니다.
- **IndexedDB**는 **비동기** API입니다.
- **IndexedDB**는 **대부분의 브라우저**에서 [**지원**](http://caniuse.com/#feat=indexeddb)됩니다.

###### Source

* https://github.com/FuelFrontend/Frontend-Developer-Interview-Preparation

[[↑] 맨 위로](#HTML5)
