## Java

[JVM이란 무엇입니까? Java를 "플랫폼 독립 프로그래밍 언어"라고 부르는 이유는 무엇입니까?](#JVM이란-무엇입니까-Java를-플랫폼-독립-프로그래밍-언어라고-부르는-이유는-무엇입니까)

[서블릿이란 무엇입니까?](#서블릿이란-무엇입니까)

[JSP 페이지란 무엇입니까?](#JSP-페이지란-무엇입니까)

[스윙에 대해 이야기합시다. 선택과 목록의 차이점은 무엇입니까?](#스윙에-대해-이야기합시다-선택과-목록의-차이점은-무엇입니까)

[애플릿과 자바 애플리케이션의 차이점은 무엇입니까?](#애플릿과-자바-애플리케이션의-차이점은-무엇입니까)

[JDK와 JRE의 차이점은 무엇입니까?](#JDK와-JRE의-차이점은-무엇입니까)

[Java의 두 가지 예외 유형은 무엇입니까? 이들의 차이점은 무엇인가요?](#Java의-두-가지-예외-유형은-무엇입니까-이들의-차이점은-무엇인가요)

[서블릿의 아키텍처를 설명합니다.](#서블릿의-아키텍처를-설명합니다)

[인터페이스와 추상 클래스의 차이점은 무엇입니까?](#인터페이스와-추상-클래스의-차이점은-무엇입니까)

[참조에 의한 전달과 값에 의한 전달이란 무엇입니까?](#참조에-의한-전달과-값에-의한-전달이란-무엇입니까)

[프로세스와 스레드의 차이점은 무엇입니까?](#프로세스와-스레드의-차이점은-무엇입니까?)

[직렬화와 역직렬화에 대해 설명합니다.](#직렬화와-역직렬화에-대해-설명합니다)

[표현식이란 무엇입니까?](#표현식이란-무엇입니까)

[선언이란 무엇입니까?](#선언이란-무엇입니까)

[JSP 작업이란 무엇입니까?](#JSP-작업이란-무엇입니까)

[지시문이란 무엇입니까?](#지시문이란-무엇입니까)

[JSP 요청은 어떻게 처리됩니까?](#JSP-요청은-어떻게-처리됩니까)

[Java Collection Framework의 기본 인터페이스는 무엇입니까?](#Java-Collection-Framework의-기본-인터페이스는-무엇입니까)

["정적" 키워드는 무엇을 의미합니까? Java에서 개인 또는 정적 메소드를 재정의할 수 있습니까?](#정적-키워드는-무엇을-의미합니까-Java에서-개인-또는-정적-메소드를-재정의할-수-있습니까)

[반복자 란 무엇입니까?](#반복자-란-무엇입니까)

[Class.forName 메서드의 목적은 무엇입니까?](#ClassforName-메서드의-목적은-무엇입니까)

[JDBC 란 무엇입니까?](#JDBC-란-무엇입니까)

[HashMap은 Java에서 어떻게 작동합니까?](#HashMap은-Java에서-어떻게-작동합니까)

[Java가 모든 Swing 구성 요소에 사용하는 디자인 패턴은 무엇입니까?](#Java가-모든-Swing-구성-요소에-사용하는-디자인-패턴은-무엇입니까)

[HashMap과 Hashtable 사이에는 어떤 차이점이 있습니까?](#HashMap과-Hashtable-사이에는-어떤-차이점이-있습니까)

[Java의 레이아웃 관리자는 기존 윈도우 시스템에 비해 어떤 이점을 제공합니까?](#Java의-레이아웃-관리자는-기존-윈도우-시스템에-비해-어떤-이점을-제공합니까)

[GUI 구성 요소는 자체 이벤트를 어떻게 처리할 수 있습니까?](#GUI-구성-요소는-자체-이벤트를-어떻게-처리할-수-있습니까)

[레이아웃 관리자란 무엇입니까?](#레이아웃-관리자란-무엇입니까)

[sendRedirect와 전달 방법의 차이점은 무엇입니까?](#sendRedirect와-전달-방법의-차이점은-무엇입니까)

[Big-O 표기법에 대해 무엇을 알고 있으며 다른 데이터 구조와 관련하여 몇 가지 예를 제공할 수 있습니까?](#Big-O-표기법에-대해-무엇을-알고-있으며-다른-데이터-구조와-관련하여-몇-가지-예를-제공할-수-있습니까)

[Java에서 지원하는 데이터 유형은 무엇입니까? 오토박싱과 언박싱이란?](#Java에서-지원하는-데이터-유형은-무엇입니까-오토박싱과-언박싱이란)

[Java에서 함수 재정의 및 오버로딩이란 무엇입니까?](#Java에서-함수-재정의-및-오버로딩이란-무엇입니까)

[자바 애플릿이란 무엇입니까?](#자바-애플릿이란-무엇입니까)

[예외 처리 후 Exception 객체는 어떻게 됩니까?](#예외-처리-후-Exception-객체는-어떻게-됩니까)

[Java에서 가비지 수집의 목적은 무엇이며 언제 사용됩니까?](#Java에서-가비지-수집의-목적은-무엇이며-언제-사용됩니까)

[System.gc() 및 Runtime.gc() 메서드는 무엇을 합니까?](#Systemgc및-Runtimegc-메서드는-무엇을-합니까)

[예외 처리에서 finally 블록의 중요성은 무엇입니까?](#예외-처리에서-finally-블록의-중요성은-무엇입니까)

[Java에서 예외와 오류의 차이점은 무엇입니까?](#Java에서-예외와-오류의-차이점은-무엇입니까)

[웹 애플리케이션이란 무엇을 의미합니까?](#웹-애플리케이션이란-무엇을-의미합니까)

[Java에서 객체가 가비지 수집에 적합한 시기는 언제입니까?](#Java에서-객체가-가비지-수집에-적합한-시기는-언제입니까)

[Collection이 Cloneable 및 Serializable 인터페이스를 확장하지 않는 이유는 무엇입니까?](#Collection이-Cloneable-및-Serializable-인터페이스를-확장하지-않는-이유는-무엇입니까)

[애플릿이 로드되면 어떻게 됩니까?](#애플릿이-로드되면-어떻게-됩니까)

[RMI에서 스텁의 역할은 무엇입니까?](#RMI에서-스텁의-역할은-무엇입니까)

[Java 힙의 구조는 무엇입니까?](#Java-힙의-구조는-무엇입니까)

[개체 참조가 null로 설정된 경우 가비지 수집기가 해당 개체가 보유한 메모리를 즉시 해제합니까?](#개체-참조가-null로-설정된-경우-가비지-수집기가-해당-개체가-보유한-메모리를-즉시-해제합니까)

[throw와 throws의 차이는 무엇인가요?](#throw와-throws의-차이는-무엇인가요)

[finalize()는 언제 호출됩니까? 마무리의 목적은 무엇입니까?](#finalize는-언제-호출됩니까-마무리의-목적은-무엇입니까?)

[RMI 프로그램이 작동하도록 하는 단계는 무엇입니까?](#RMI-프로그램이-작동하도록-하는-단계는-무엇입니까)

[finally 블록은 finalize() 메서드와 어떻게 다릅니까?](#finally-블록은-finalize-메서드와-어떻게-다릅니까)

[Enumeration과 Iterator 인터페이스의 차이점은 무엇입니까?](#Enumeration과-Iterator-인터페이스의-차이점은-무엇입니까)

[애플릿의 생명주기를 설명하라.](#애플릿의-생명주기를-설명하라)

[정적 컨텍스트에서 비 정적 변수에 액세스할 수 있습니까?](#정적-컨텍스트에서-비-정적-변수에-액세스할-수-있습니까-)

[정렬되지 않은 배열과 정렬된 배열을 사용하는 것 사이의 절충점은 무엇입니까?](#정렬되지-않은-배열과-정렬된-배열을-사용하는-것-사이의-절충점은-무엇입니까)

[Java 애플릿에 부과되는 제한 사항은 무엇입니까?](#Java-애플릿에-부과되는-제한-사항은-무엇입니까)

[신뢰할 수 없는 애플릿이란 무엇입니까?](#신뢰할-수-없는-애플릿이란-무엇입니까)

[서버 측 포함(SSI)이란 무엇입니까?](#서버-측-포함SSI이란-무엇입니까)

[생성자, Java 및 복사 생성자의 생성자 오버로딩이란 무엇입니까?](#생성자-Java-및-복사-생성자의-생성자-오버로딩이란-무엇입니까)

[애플릿 보안 관리자는 무엇이며 무엇을 제공합니까?](#애플릿-보안-관리자는-무엇이며-무엇을-제공합니까)

[Java 우선 순위 대기열이란 무엇입니까?](#Java-우선-순위-대기열이란-무엇입니까)

[Comparable 및 Comparator 인터페이스란 무엇입니까? 차이점을 나열하십시오.](#Comparable-및-Comparator-인터페이스란-무엇입니까-차이점을-나열하십시오)

[어떤 Swing 메서드가 스레드로부터 안전합니까?](#어떤-Swing-메서드가-스레드로부터-안전합니까)

[이벤트 수신기 인터페이스와 이벤트 어댑터 클래스 사이의 관계는 무엇입니까?](#이벤트-수신기-인터페이스와-이벤트-어댑터-클래스-사이의-관계는-무엇입니까)

[ArrayList와 LinkedList의 차이점은 무엇입니까?](#ArrayList와-LinkedList의-차이점은-무엇입니까)

[Array와 ArrayList의 차이점은 무엇입니까? 언제 ArrayList보다 Array를 사용합니까?](#Array와-ArrayList의-차이점은-무엇입니까-언제-ArrayList보다-Array를-사용합니까)

[hashCode() 및 equals() 메서드의 중요성은 무엇입니까?](#hashCode-및-equals-메서드의-중요성은-무엇입니까)

[Fail-fast와 Fail-safe의 차이점은 무엇입니까?](#Fail-fast와-Fail-safe의-차이점은-무엇입니까)

[JDBC에서 Driver의 역할을 설명하라.](#JDBC에서-Driver의-역할을-설명하라)

[Iterator와 ListIterator에는 어떤 차이점이 있습니까?](#Iterator와-ListIterator에는-어떤-차이점이-있습니까)

[Statement보다 PreparedStatement의 장점은 무엇입니까?](#Statement보다-PreparedStatement의-장점은-무엇입니까)

[CallableStatement의 용도는 무엇입니까? CallableStatement를 준비하는 데 사용되는 메서드의 이름을 지정합니다.](#CallableStatement의-용도는-무엇입니까-CallableStatement를-준비하는-데-사용되는-메서드의-이름을-지정합니다)

[doGet()과 doPost()의 차이점은 무엇입니까?](#doGet과-doPost의-차이점은-무엇입니까)

[서블릿의 생명주기를 설명하라.](#서블릿의-생명주기를-설명하라)

[GenericServlet과 HttpServlet의 차이점은 무엇입니까?](#GenericServlet과-HttpServlet의-차이점은-무엇입니까)

[JSP의 장점은 무엇입니까?](#JSP의-장점은-무엇입니까)

[교착 상태란 무엇입니까?](#교착-상태란-무엇입니까)

[애플릿과 서블릿의 차이점은 무엇입니까?](#애플릿과-서블릿의-차이점은-무엇입니까)

[스크립틀릿이란 무엇입니까?](#스크립틀릿이란-무엇입니까)

[Java는 다중 상속을 지원합니까?](#Java는-다중-상속을-지원합니까)

[스레드를 생성하는 다양한 방법을 설명합니다. 어느 것을 선호하고 그 이유는 무엇입니까?](#스레드를-생성하는-다양한-방법을-설명합니다-어느-것을-선호하고-그-이유는-무엇입니까)

[JSP 암묵적 객체가 의미하는 바는 무엇이며 어떤 객체입니까?](#JSP-암묵적-객체가-의미하는-바는-무엇이며-어떤-객체입니까)

[RMI 란 무엇입니까?](#RMI-란-무엇입니까)

[사용 가능한 스레드 상태를 개략적으로 설명합니다.](#사용-가능한-스레드-상태를-개략적으로-설명합니다)

[마샬링과 디마샬링에 대해 설명합니다.](#마샬링과-디마샬링에-대해-설명합니다)

[N 스레드가 교착 상태 없이 N 리소스에 액세스할 수 있도록 하는 방법은 무엇입니까?](#N-스레드가-교착-상태-없이-N-리소스에-액세스할-수-있도록-하는-방법은-무엇입니까)

[힙에서 Perm Gen 공간이란 무엇입니까?](#힙에서-Perm-Gen-공간이란-무엇입니까)

[연결 풀링은 무엇을 의미합니까?](#연결-풀링은-무엇을-의미합니까)

[애플릿 클래스 로더는 무엇이며 무엇을 제공합니까?](#애플릿-클래스-로더는-무엇이며-무엇을-제공합니까)

[인터넷을 통해 로드된 애플릿과 파일 시스템을 통해 로드된 애플릿의 차이점은 무엇입니까?](#인터넷을-통해-로드된-애플릿과-파일-시스템을-통해-로드된-애플릿의-차이점은-무엇입니까)

[Servlet Chaining 이란?](#Servlet-Chaining-이란)

[어떤 클라이언트 머신이 당신의 서블릿에 요청하고 있는지 어떻게 알 수 있나요?](#어떤-클라이언트-머신이-당신의-서블릿에-요청하고-있는지-어떻게-알-수-있나요)

[Java Collection 프레임워크와 관련된 모범 사례는 무엇입니까?](#Java-Collection-프레임워크와-관련된-모범-사례는-무엇입니까)

[동기화된 방법과 동기화된 블록의 차이점은 무엇입니까?](#동기화된-방법과-동기화된-블록의-차이점은-무엇입니까)

[RMI 아키텍처의 기본 원리는 무엇입니까?](#RMI-아키텍처의-기본-원리는-무엇입니까)

[RMI에서 RMISecurityManager를 사용하는 목적은 무엇입니까?](#RMI에서-RMISecurityManager를-사용하는-목적은-무엇입니까)

[RMI에서 원격 인터페이스의 역할은 무엇입니까?](#RMI에서-원격-인터페이스의-역할은-무엇입니까)

[java.rmi.Naming 클래스의 역할은 무엇입니까?](#javarmiNaming-클래스의-역할은-무엇입니까)

[RMI에서 바인딩이란 무엇을 의미합니까?](#RMI에서-바인딩이란-무엇을-의미합니까)

[직렬 및 처리량 가비지 수집기의 차이점은 무엇입니까?](#직렬-및-처리량-가비지-수집기의-차이점은-무엇입니까)

[HashSet과 TreeSet의 차이점은 무엇입니까?](#HashSet과-TreeSet의-차이점은-무엇입니까)

[JVM의 영구 생성 공간에서 Garbage Collection이 발생합니까?](#JVM의-영구-생성-공간에서-Garbage-Collection이-발생합니까)

[DGC 란 무엇입니까? 어떻게 작동합니까?](#DGC-란-무엇입니까-어떻게-작동합니까)

[RMI 아키텍처의 계층은 무엇입니까?](#RMI-아키텍처의-계층은-무엇입니까)

[스레드 동기화는 모니터 내부에서 어떻게 발생합니까? 어떤 수준의 동기화를 적용할 수 있습니까?](#스레드-동기화는-모니터-내부에서-어떻게-발생합니까-어떤-수준의-동기화를-적용할-수-있습니까)



### JVM이란 무엇입니까? Java를 "플랫폼 독립 프로그래밍 언어"라고 부르는 이유는 무엇입니까?

JVM(Java Virtual Machine)은 Java 바이트 코드를 실행할 수 있는 프로세스 가상 머신입니다. 각 Java 소스 파일은 JVM에서 실행되는 바이트 코드 파일로 컴파일됩니다. Java는 프로그래머가 각각의 개별 플랫폼에 대해 다시 작성하거나 다시 컴파일할 필요 없이 모든 플랫폼에서 실행할 수 있는 응용 프로그램을 빌드할 수 있도록 설계되었습니다. Java 가상 머신은 기본 하드웨어 플랫폼의 특정 명령어 길이 및 기타 특성을 알고 있기 때문에 이를 가능하게 합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 서블릿이란 무엇입니까?

서블릿은 클라이언트 요청을 처리하고 동적 웹 콘텐츠를 생성하는 데 사용되는 Java 프로그래밍 언어 클래스입니다. 서블릿은 주로 HTML 형식으로 제출된 데이터를 처리하거나 저장하고, 동적 콘텐츠를 제공하고, Stateless HTTP 프로토콜에 없는 상태 정보를 관리하는 데 사용됩니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### JSP 페이지란 무엇입니까?

JSP(Java Server Page)는 정적 데이터와 JSP 요소라는 두 가지 유형의 텍스트를 포함하는 텍스트 문서입니다. 정적 데이터는 HTML 또는 XML과 같은 텍스트 기반 형식으로 표현할 수 있습니다. JSP는 정적 콘텐츠와 동적으로 생성된 콘텐츠를 혼합하는 기술입니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 스윙에 대해 이야기합시다. 선택과 목록의 차이점은 무엇입니까?

선택 항목은 사용자가 사용 가능한 모든 선택 항목의 목록을 볼 수 있도록 풀다운해야 하는 압축된 형식으로 표시됩니다. 선택 항목에서 하나의 항목만 선택할 수 있습니다. 목록은 여러 목록 항목이 표시되는 방식으로 표시될 수 있습니다. 목록은 하나 이상의 목록 항목 선택을 지원합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 애플릿과 자바 애플리케이션의 차이점은 무엇입니까?

애플릿은 Java 지원 브라우저 내에서 실행되지만 Java 애플리케이션은 브라우저 외부에서 실행할 수 있는 독립 실행형 Java 프로그램입니다. 그러나 둘 다 JVM(Java Virtual Machine)이 있어야 합니다. 또한 Java 응용 프로그램은 실행을 시작하기 위해 특정 서명이 있는 기본 메서드가 필요합니다. Java 애플릿은 실행을 시작하기 위해 그러한 메소드가 필요하지 않습니다. 마지막으로 Java 애플릿은 일반적으로 제한적인 보안 정책을 사용하는 반면 Java 응용 프로그램은 일반적으로 보다 완화된 보안 정책을 사용합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### JDK와 JRE의 차이점은 무엇입니까? 

JRE(Java Runtime Environment)는 기본적으로 Java 프로그램이 실행되는 JVM(Java Virtual Machine)입니다. 여기에는 애플릿 실행을 위한 브라우저 플러그인도 포함됩니다. JDK(Java Development Kit)는 사용자가 Java 응용 프로그램을 개발, 컴파일 및 실행할 수 있도록 JRE, 컴파일러 및 도구(예: JavaDoc 및 Java Debugger)를 포함하는 모든 기능을 갖춘 Java용 소프트웨어 개발 키트입니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Java의 두 가지 예외 유형은 무엇입니까? 이들의 차이점은 무엇인가요?

Java에는 확인된 예외와 확인되지 않은 예외의 두 가지 유형의 예외가 있습니다. 확인되지 않은 예외는 메서드 또는 생성자의 실행에 의해 throw될 수 있고 메서드 또는 생성자 경계 외부로 전파될 수 있는 경우 메서드 또는 생성자의 throw 절에서 선언할 필요가 없습니다. 반면에 확인된 예외는 메서드 또는 생성자의 throw 절에서 선언되어야 합니다. [자바 예외 처리]
(http://www.javacodegeeks.com/2013/07/java-exception-handling-tutorial-with-examples-and-best-practices.html).

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 서블릿의 아키텍처를 설명합니다.

모든 서블릿이 구현해야 하는 핵심 추상화는 javax.servlet.Servlet 인터페이스입니다. 각 서블릿은 javax.servlet.GenericServlet 또는 javax.servlet.http.HTTPServlet을 확장하여 직접 또는 간접적으로 구현해야 합니다. 마지막으로 각 서블릿은 멀티스레딩을 사용하여 여러 요청을 병렬로 처리할 수 있습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 인터페이스와 추상 클래스의 차이점은 무엇입니까?

Java는 [추상 클래스](http://examples.javacodegeeks.com/java-basics/java-abstract-class-example/)와 인터페이스의 생성을 모두 제공하고 지원합니다. 두 구현 모두 몇 가지 공통된 특성을 공유하지만 다음 기능이 다릅니다:

* 인터페이스의 모든 메소드는 암시적으로 추상입니다. 반면에 추상 클래스에는 추상 메서드와 비추상 메서드가 모두 포함될 수 있습니다.
* 클래스는 여러 인터페이스를 구현할 수 있지만 하나의 추상 클래스만 확장할 수 있습니다.
* 클래스가 인터페이스를 구현하려면 선언된 모든 메소드를 구현해야 합니다. 그러나 클래스는 추상 클래스의 선언된 모든 메서드를 구현하지 않을 수 있습니다. 그러나 이 경우 하위 클래스도 추상으로 선언해야 합니다.
* 추상 클래스는 인터페이스 메소드의 구현을 제공하지 않고도 인터페이스를 구현할 수 있습니다.
* Java 인터페이스에서 선언된 변수는 기본적으로 final입니다. 추상 클래스는 최종 변수가 아닌 변수를 포함할 수 있습니다.
* Java 인터페이스의 멤버는 기본적으로 공용입니다. 추상 클래스의 멤버는 private, protected 또는 public이 될 수 있습니다.
* 인터페이스는 절대적으로 추상적이며 인스턴스화할 수 없습니다. 추상 클래스도 인스턴스화할 수 없지만 기본 메서드가 포함된 경우 호출할 수 있습니다.
*
또한 [JDK 8의 추상 클래스 및 인터페이스 차이점]을 확인하십시오.(http://www.javacodegeeks.com/2014/04/abstract-class-versus-interface-in-the-jdk-8-era.html).

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 참조에 의한 전달과 값에 의한 전달이란 무엇입니까?

개체가 값으로 전달되면 개체의 복사본이 전달됨을 의미합니다. 따라서 해당 개체가 변경되더라도 원래 값에는 영향을 미치지 않습니다. 객체가 참조로 전달되면 실제 객체가 전달되지 않고 객체의 참조가 전달됨을 의미합니다. 따라서 외부 방법에 의한 변경 사항도 모든 위치에 반영됩니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 프로세스와 스레드의 차이점은 무엇입니까?

프로세스는 프로그램의 실행이고 [Thread](http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html)는 프로세스 내의 단일 실행 시퀀스입니다. 프로세스는 여러 스레드를 포함할 수 있습니다. A [스레드](http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html) is sometimes called a lightweight process.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 직렬화와 역직렬화에 대해 설명합니다.

Java는 객체가 일련의 바이트로 표현될 수 있는 객체 직렬화라는 메커니즘을 제공하며 객체의 데이터는 물론 객체의 유형 및 객체에 저장된 데이터 유형에 대한 정보를 포함합니다. 따라서 직렬화는 디스크에 저장하고 나중에 다시 읽고 재구성하기 위해 개체를 평면화하는 방법으로 볼 수 있습니다. 역직렬화는 개체를 평평한 상태에서 라이브 개체로 변환하는 역 프로세스입니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 표현식이란 무엇입니까?

JSP 표현식은 문자열로 변환된 스크립팅 언어 표현식의 값을 웹 서버에서 클라이언트로 반환된 데이터 스트림에 삽입하는 데 사용됩니다. 표현식은 <% = 및 %> 태그 사이에 정의됩니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 선언이란 무엇입니까?

선언은 Java의 변수 선언과 유사합니다. 선언은 표현식이나 스크립틀릿에서 나중에 사용할 변수를 선언하는 데 사용됩니다. 선언을 추가하려면 시퀀스를 사용하여 선언을 묶어야 합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### JSP 작업이란 무엇입니까?

JSP 작업은 XML 구문의 구성을 사용하여 서블릿 엔진의 동작을 제어합니다. JSP 작업은 JSP 페이지가 요청될 때 실행됩니다. 파일에 동적으로 삽입하거나, JavaBeans 구성 요소를 재사용하거나, 사용자를 다른 페이지로 전달하거나, Java 플러그인용 HTML을 생성할 수 있습니다. 사용 가능한 작업 중 일부는 다음과 같습니다.

* jsp:include – JSP 페이지가 요청될 때 파일을 포함합니다.
* jsp:useBean – JavaBean을 찾거나 인스턴스화합니다.
* jsp:setProperty – JavaBean의 속성을 설정합니다.
* jsp:getProperty – JavaBean의 속성을 가져옵니다.
* jsp:forward – 요청자를 새 페이지로 전달합니다.
* jsp:plugin – 브라우저별 코드를 생성합니다.


###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 지시문이란 무엇입니까?

JSP에서 사용할 수 있는 다양한 유형의 지시문은 무엇입니까? 지시문은 페이지가 서블릿으로 컴파일될 때 JSP 엔진에 의해 처리되는 명령입니다. 지시문은 페이지 수준 지침을 설정하고, 외부 파일에서 데이터를 삽입하고, 사용자 정의 태그 라이브러리를 지정하는 데 사용됩니다. 지시문은 < %@ 및 % > 사이에 정의됩니다. 지시문 유형은 다음과 같습니다:

* Include 지시어: 파일을 포함하고 파일의 내용을 현재 페이지와 병합하는 데 사용됩니다.
* 페이지 지시문: 오류 페이지 및 버퍼와 같은 JSP 페이지의 특정 속성을 정의하는 데 사용됩니다.
* Taglib: 페이지에서 사용하는 커스텀 태그 라이브러리를 선언하기 위해 사용합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### JSP 요청은 어떻게 처리됩니까?

JSP 요청이 도착하면 브라우저는 먼저 .jsp 확장자를 가진 페이지를 요청합니다. 그런 다음 웹 서버는 요청을 읽고 JSP 컴파일러를 사용하여 웹 서버는 JSP 페이지를 서블릿 클래스로 변환합니다. JSP 파일은 페이지의 첫 번째 요청에서만 컴파일되거나 JSP 파일이 변경된 경우에만 컴파일됩니다. 브라우저의 요청을 처리하기 위해 생성된 서블릿 클래스가 호출됩니다. 요청 실행이 끝나면 서블릿은 클라이언트에 응답을 다시 보냅니다. [JSP에서 요청 매개변수를 가져오는 방법]을 참조하십시오.(http://examples.javacodegeeks.com/enterprise-java/jsp/get-request-parameter-in-jsp-page/).

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Java Collection Framework의 기본 인터페이스는 무엇입니까?

[자바 컬렉션 프레임워크](http://docs.oracle.com/javase/7/docs/technotes/guides/collections/overview.html) 개체 컬렉션에 대한 작업을 지원하는 잘 설계된 인터페이스 및 클래스 집합을 제공합니다. Java Collections Framework에 있는 가장 기본적인 인터페이스는 다음과 같습니다:

* [Collection](http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html), 이것은 원소로 알려진 개체 그룹을 나타냅니다.
* [Set](http://docs.oracle.com/javase/7/docs/api/java/util/Set.html), 중복 요소를 포함할 수 없는 컬렉션입니다.
* [List](http://docs.oracle.com/javase/7/docs/api/java/util/List.html), 이 집합은 순서가 지정된 집합이며 중복 요소를 포함할 수 있습니다.
* [Map](http://docs.oracle.com/javase/7/docs/api/java/util/Map.html), 이는 키를 값에 매핑하는 개체이며 중복 키를 포함할 수 없습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### "정적" 키워드는 무엇을 의미합니까? Java에서 개인 또는 정적 메소드를 재정의할 수 있습니까?

정적 키워드는 멤버 변수나 메서드가 속한 클래스를 인스턴스화할 필요 없이 액세스할 수 있음을 나타냅니다. 메소드 재정의가 런타임의 동적 바인딩에 기반하고 정적 메서드가 컴파일 시 정적 바인딩되기 때문에 사용자는 Java의 정적 메서드를 재정의할 수 없습니다. 정적 메서드는 클래스의 인스턴스와 연결되어 있지 않으므로 개념을 적용할 수 없습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 반복자 란 무엇입니까?

[Iterator](http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html) 인터페이스는 모든 [Collection](http: //docs.oracle.com/javase/7/docs/api/java/util/Collection.html). 각 Java [Collection](http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html)에는 [Iterator](http://docs.oracle.com/javase/ 7/docs/api/java/util/Iterator.html) [Iterator](http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html) 인스턴스를 반환하는 메서드입니다. 반복자는 반복 중에 기본 컬렉션에서 요소를 제거할 수 있습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Class.forName 메서드의 목적은 무엇입니까?

이 메서드는 지정된 클래스 이름을 가진 이 클래스의 인스턴스를 가져오는 데 사용됩니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### JDBC 란 무엇입니까?

JDBC는 사용자가 데이터베이스 중에서 선택할 수 있도록 하는 추상화 계층입니다. [JDBC를 통해 개발자는 Java로 데이터베이스 애플리케이션을 작성할 수 있습니다.](http://www.javacodegeeks.com/2014/03/java-8-friday-java-8-will-revolutionize-database-access.html), 특정 데이터베이스의 기본 세부 정보에 관심을 갖습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### HashMap은 Java에서 어떻게 작동합니까?

[자바의 HashMap은 키-값 쌍을 저장합니다](http://www.javacodegeeks.com/2014/03/how-hashmap-works-in-java.html). [HashMap](http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html)은 해시 함수가 필요하고 hashCode 및 equals 메소드를 사용하여 요소를 및 컬렉션에서 각각. put 메소드가 호출되면 [HashMap](http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html)이 키의 해시 값을 계산하고 쌍을 다음 위치에 저장합니다. 컬렉션 내부의 적절한 인덱스. 키가 있으면 해당 값이 새 값으로 업데이트됩니다. [HashMap](http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html)의 몇 가지 중요한 특성은 용량, 로드 팩터 및 임계값 크기 조정입니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Java가 모든 Swing 구성 요소에 사용하는 디자인 패턴은 무엇입니까?

Java에서 모든 Swing 구성 요소에 사용하는 디자인 패턴은 MVC(Model View Controller) 패턴입니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### HashMap과 Hashtable 사이에는 어떤 차이점이 있습니까?

[HashMap](http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html) 및 [Hashtable](http://docs.oracle.com/javase/7 /docs/api/java/util/Hashtable.html) 클래스는 Map 인터페이스를 구현하므로 매우 유사한 특성을 갖습니다. 그러나 다음과 같은 기능이 다릅니다:

* [HashMap](http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html)은 null 키와 값의 존재를 허용하는 반면, [Hashtable](http:/ /docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html) null 키나 null 값을 허용하지 않습니다.
* [Hashtable](http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html)은 동기화되고, [HashMap](http://docs.oracle.com)은 동기화됩니다. /javase/7/docs/api/java/util/HashMap.html)이 아닙니다. 따라서 단일 스레드 환경에서는 [HashMap](http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html)이 선호되는 반면 [Hashtable](http:// docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html)은 다중 스레드 환경에 적합합니다.
* [HashMap](http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html)은 키 세트를 제공하며 Java 애플리케이션은 이를 반복할 수 있습니다. 따라서 [HashMap](http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html)은 fail-fast입니다. 한편, [해시테이블](http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html)은 [열거](http://docs.oracle.html)를 제공합니다. com/javase/7/docs/api/java/util/Enumeration.html) 키.
* [Hashtable](http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html) 클래스는 레거시 클래스로 간주됩니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Java의 레이아웃 관리자는 기존 윈도우 시스템에 비해 어떤 이점을 제공합니까?

Java는 레이아웃 관리자를 사용하여 모든 윈도우 플랫폼에서 일관된 방식으로 구성 요소를 배치합니다. 레이아웃 관리자는 절대적인 크기 및 위치 지정에 얽매이지 않기 때문에 창 시스템 간의 플랫폼별 차이를 수용할 수 있습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### GUI 구성 요소는 자체 이벤트를 어떻게 처리할 수 있습니까?

GUI 구성 요소는 해당 이벤트 수신기 인터페이스를 구현하고 자체 이벤트 수신기로 자신을 추가하여 자체 이벤트를 처리할 수 있습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 레이아웃 관리자란 무엇입니까?

레이아웃 관리자는 컨테이너의 구성 요소를 구성하는 데 사용됩니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### sendRedirect와 전달 방법의 차이점은 무엇입니까?

sendRedirect 메서드는 새 요청을 생성하는 반면, forward 메서드는 요청을 새 대상으로 전달합니다. 이전 요청 범위 개체는 새 요청이 발생하기 때문에 리디렉션 후에 사용할 수 없습니다. 반면에 이전 요청 범위 개체는 전달 후에 사용할 수 있습니다. 마지막으로 일반적으로 sendRedirect 방식은 forward 방식에 비해 느리다고 여겨진다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Big-O 표기법에 대해 무엇을 알고 있으며 다른 데이터 구조와 관련하여 몇 가지 예를 제공할 수 있습니까?

Big-O 표기법은 데이터 구조의 요소 수가 증가함에 따라 최악의 시나리오에서 알고리즘이 얼마나 잘 확장되거나 수행되는지를 설명합니다. Big-O 표기법은 메모리 소비와 같은 다른 동작을 설명하는 데에도 사용할 수 있습니다. 컬렉션 클래스는 실제로 데이터 구조이기 때문에 일반적으로 Big-O 표기법을 사용하여 시간, 메모리 및 성능을 기반으로 사용할 최상의 구현을 선택합니다. Big-O 표기법은 많은 양의 데이터에 대한 성능에 대한 좋은 표시를 제공할 수 있습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Java에서 지원하는 데이터 유형은 무엇입니까? 오토박싱과 언박싱이란?

Java 프로그래밍 언어에서 지원하는 8가지 기본 데이터 유형은 다음과 같습니다.

* byte
* short
* int
* long
* float
* double
* boolean
* char

Autoboxing은 [자바 컴파일러에 의한 자동 변환](http://www.javacodegeeks.com/2013/07/java-generics-tutorial-example-class-interface-methods-wildcards-and-much-more.html)입니다. ) 기본 유형과 해당 객체 래퍼 클래스 사이. 예를 들어 컴파일러는 int를 [Integer](http://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html?is-external=true)로 변환하고 double을 a [Double](http://docs.oracle.com/javase/7/docs/api/java/lang/Double.html) 등. 변환이 다른 방향으로 진행되면 이 작업을 unboxing이라고 합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Java에서 함수 재정의 및 오버로딩이란 무엇입니까?

Java에서 메소드 오버로딩은 동일한 클래스에 있는 둘 이상의 메소드가 정확히 동일한 이름을 갖지만 다른 매개변수를 가질 때 발생합니다. 반면에, 메서드 오버라이드는 자식 클래스가 부모 클래스와 동일한 메서드를 재정의하는 경우로 정의됩니다. 재정의된 메서드는 이름, 인수 목록 및 반환 유형이 같아야 합니다. 재정의하는 메서드는 재정의하는 메서드의 액세스를 제한하지 않을 수 있습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 자바 애플릿이란 무엇입니까?

Java Applet은 HTML 페이지에 포함될 수 있고 Java 지원 클라이언트 브라우저에서 실행될 수 있는 프로그램입니다. 애플릿은 동적 및 대화형 웹 응용 프로그램을 만드는 데 사용됩니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 예외 처리 후 Exception 객체는 어떻게 됩니까?

[Exception](http://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html) 객체는 다음 가비지 컬렉션에서 가비지 수집됩니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
###  Java에서 가비지 수집의 목적은 무엇이며 언제 사용됩니까?

가비지 수집의 목적은 리소스를 회수하고 재사용할 수 있도록 애플리케이션에서 더 이상 필요하지 않은 개체를 식별하고 삭제하는 것입니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### System.gc() 및 Runtime.gc() 메서드는 무엇을 합니까?

이러한 메소드는 가비지 수집을 시작하기 위해 JVM에 대한 힌트로 사용될 수 있습니다. 그러나 가비지 수집을 즉시 또는 나중에 시작하는 것은 JVM(Java Virtual Machine)에 달려 있습니다.


###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 예외 처리에서 finally 블록의 중요성은 무엇입니까?

*finally* 블록은 예외가 실제로 발생했는지 여부에 관계없이 항상 실행됩니다. catch 문이 누락되어 예외가 발생한 경우에도 finally 블록은 계속 실행됩니다. 마지막으로 언급할 것은 finally 블록이 I/O 버퍼, 데이터베이스 연결 등과 같은 리소스를 해제하는 데 사용된다는 것입니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Java에서 예외와 오류의 차이점은 무엇입니까?

[예외](http://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html) 및 [오류](http://docs.oracle.com/javase/7/docs) /api/java/lang/Error.html) 클래스는 모두 [Throwable](http://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) 클래스의 하위 클래스입니다. [Exception](http://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html) 클래스는 사용자 프로그램이 잡아야 하는 예외적인 상황에 사용됩니다. [Error](http://docs.oracle.com/javase/7/docs/api/java/lang/Error.html) 클래스는 사용자 프로그램에 의해 catch되는 예외가 아닌 예외를 정의합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 웹 애플리케이션이란 무엇을 의미합니까?

웹 응용 프로그램은 웹 또는 응용 프로그램 서버의 동적 확장입니다. 웹 애플리케이션에는 프레젠테이션 지향과 서비스 지향의 두 가지 유형이 있습니다. 프레젠테이션 지향 웹 응용 프로그램은 요청에 대한 응답으로 다양한 유형의 마크업 언어와 동적 콘텐츠를 포함하는 대화형 웹 페이지를 생성합니다. 반면 서비스 지향 웹 애플리케이션은 웹 서비스의 끝점을 구현합니다. 일반적으로 웹 응용 프로그램은 서버 URL 네임스페이스의 특정 하위 집합 아래에 설치된 서블릿 모음으로 볼 수 있습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Java에서 객체가 가비지 수집에 적합한 시기는 언제입니까?

Java 객체는 현재 사용 중인 프로그램에 도달할 수 없을 때 가비지 수집 대상이 됩니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Collection이 Cloneable 및 Serializable 인터페이스를 확장하지 않는 이유는 무엇입니까?

[Collection](http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html) 인터페이스는 요소로 알려진 개체 그룹을 지정합니다. [Collection](http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html)의 각 구체적인 구현은 요소를 유지 관리하고 정렬하는 방법에 대한 고유한 방법을 선택할 수 있습니다. 일부 컬렉션은 중복 키를 허용하지만 다른 컬렉션은 허용하지 않습니다. 의미론과 복제 또는 직렬화의 의미는 실제 구현을 다룰 때 작용합니다. 따라서 컬렉션의 구체적인 구현은 컬렉션을 복제하거나 직렬화하는 방법을 결정해야 합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 애플릿이 로드되면 어떻게 됩니까?

우선, 애플릿의 제어 클래스의 인스턴스가 생성됩니다. 그런 다음 애플릿은 자체적으로 초기화되고 마지막으로 실행을 시작합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### RMI에서 스텁의 역할은 무엇입니까?

원격 개체에 대한 스텁은 원격 개체에 대한 클라이언트의 로컬 대리인 또는 프록시 역할을 합니다. 호출자는 원격 개체에서 메서드 실행을 담당하는 로컬 스텁에서 메서드를 호출합니다. 스텁의 메소드가 호출되면 다음 단계를 거칩니다.

* 원격 객체를 포함하는 원격 JVM에 대한 연결을 시작합니다.
* 매개변수를 원격 JVM으로 마샬링합니다.
* 메소드 호출 및 실행 결과를 기다립니다.
* 메서드가 성공적으로 실행되지 않은 경우 반환 값 또는 예외를 비정렬화합니다.
* 호출자에게 값을 반환합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Java 힙의 구조는 무엇입니까?

JVM에는 모든 클래스 인스턴스 및 배열에 대한 메모리가 할당되는 런타임 데이터 영역인 힙이 있습니다. JVM 시작 시 생성됩니다. 개체에 대한 힙 메모리는 가비지 수집기로 알려진 자동 메모리 관리 시스템에 의해 회수됩니다. 힙 메모리는 살아있는 개체와 죽은 개체로 구성됩니다. 라이브 개체는 응용 프로그램에서 액세스할 수 있으며 가비지 수집의 대상이 아닙니다. 죽은 개체는 응용 프로그램에서 액세스할 수 없지만 아직 가비지 수집기에 의해 수집되지 않은 개체입니다. 이러한 개체는 결국 가비지 수집기에 의해 수집될 때까지 힙 메모리 공간을 차지합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 개체 참조가 null로 설정된 경우 가비지 수집기가 해당 개체가 보유한 메모리를 즉시 해제합니까?

아니요, 가비지 수집기의 다음 주기에서 개체를 가비지 수집에 사용할 수 있습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### throw와 throws의 차이는 무엇인가요?

'throw' 키워드는 프로그램 내에서 명시적으로 예외를 발생시키는 데 사용됩니다. 반대로 'throws' 절은 메서드에서 처리하지 않는 예외를 나타내는 데 사용됩니다. 각 메서드는 처리하지 않는 예외를 명시적으로 지정해야 하므로 해당 메서드의 호출자가 가능한 예외로부터 보호할 수 있습니다. 마지막으로 여러 예외는 쉼표로 구분됩니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### finalize()는 언제 호출됩니까? 마무리의 목적은 무엇입니까?

finalize 메서드는 객체의 메모리를 해제하기 직전에 가비지 수집기에 의해 호출됩니다. 일반적으로 finalize 메서드 내에서 개체가 보유한 리소스를 해제하는 것이 좋습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### RMI 프로그램이 작동하도록 하는 단계는 무엇입니까?

RMI 프로그램이 제대로 작동하려면 다음 단계가 포함되어야 합니다.

* 모든 소스 파일의 편집.
* rmic을 사용한 스텁 생성.
* rmiregistry를 시작합니다.
* RMIServer를 시작합니다.
* 클라이언트 프로그램을 실행합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### finally 블록은 finalize() 메서드와 어떻게 다릅니까?

finally 블록은 예외가 발생했는지 여부에 관계없이 실행되며 애플리케이션이 보유한 리소스를 해제하는 데 사용됩니다. 'Finalize'는 객체가 가비지 수집되기 직전에 JVM(Java Virtual Machine)에 의해 호출되는 Object 클래스의 보호된 메서드입니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Enumeration과 Iterator 인터페이스의 차이점은 무엇입니까?

[Enumeration](http://docs.oracle.com/javase/7/docs/api/java/util/Enumeration.html)은 Iterator에 비해 2배 빠르고 메모리를 매우 적게 사용합니다. 그러나 [Iterator](http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html)는 [Enumeration](http://docs.oracle.html)에 비해 훨씬 안전합니다. com/javase/7/docs/api/java/util/Enumeration.html) 다른 스레드는 현재 반복자가 통과하는 컬렉션 개체를 수정할 수 없기 때문입니다. 또한 [Iterators](http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html)를 사용하면 호출자가 기본 컬렉션에서 요소를 제거할 수 있습니다. 이는 [ 열거](http://docs.oracle.com/javase/7/docs/api/java/util/Enumeration.html).

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 애플릿의 생명주기를 설명하라. 

애플릿은 다음 상태를 겪을 수 있습니다.

* 초기화: 애플릿이 로드될 때마다 초기화됩니다.
* 시작: 애플릿의 실행을 시작합니다.
* 중지: 애플릿의 실행을 중지합니다.
* 파괴: 애플릿을 언로드하기 전에 최종 정리를 수행합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 정적 컨텍스트에서 비 정적 변수에 액세스할 수 있습니까?

Java의 정적 변수는 해당 클래스에 속하며 해당 값은 모든 인스턴스에 대해 동일하게 유지됩니다. 정적 변수는 JVM에 의해 클래스가 로드될 때 초기화됩니다. 코드가 인스턴스 없이 비정적 변수에 액세스하려고 하면 해당 변수가 아직 생성되지 않았고 어떤 인스턴스와도 연결되지 않았기 때문에 컴파일러가 불평할 것입니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 정렬되지 않은 배열과 정렬된 배열을 사용하는 것 사이의 절충점은 무엇입니까? 

정렬된 배열의 주요 이점은 검색 시간이 O(n)인 정렬되지 않은 배열의 시간 복잡도에 비해 O(log n)의 시간 복잡도를 갖는다는 것입니다. 정렬된 배열의 단점은 새 요소를 위한 공간을 만들기 위해 더 높은 값을 가진 요소를 이동해야 하기 때문에 삽입 작업의 시간 복잡도가 O(n)이라는 것입니다. 대신, 정렬되지 않은 배열에 대한 삽입 작업은 O(1)의 일정한 시간이 걸립니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Java 애플릿에 부과되는 제한 사항은 무엇입니까?

대부분 보안상의 이유로 Java 애플릿에는 다음과 같은 제한 사항이 적용됩니다.

* 애플릿은 라이브러리를 로드하거나 기본 메소드를 정의할 수 없습니다.
* 애플릿은 일반적으로 실행 호스트에서 파일을 읽거나 쓸 수 없습니다.
* 애플릿은 특정 시스템 속성을 읽을 수 없습니다.
* 애플릿은 그것이 온 호스트를 제외하고는 네트워크 연결을 만들 수 없습니다.
* 애플릿은 그것을 실행하는 호스트에서 어떤 프로그램도 시작할 수 없습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 신뢰할 수 없는 애플릿이란 무엇입니까?

신뢰할 수 없는 애플릿은 로컬 시스템 파일에 액세스하거나 실행할 수 없는 Java 애플릿입니다. 기본적으로 다운로드한 모든 애플릿은 신뢰할 수 없는 것으로 간주됩니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
###  서버 측 포함(SSI)이란 무엇입니까?

SSI(Server Side Include)는 단순하게 해석되는 서버측 스크립팅 언어로, 거의 웹용으로 사용되며 서블릿 태그와 함께 포함됩니다. SSI를 가장 자주 사용하는 것은 하나 이상의 파일 내용을 웹 서버의 웹 페이지에 포함하는 것입니다. 브라우저가 웹 페이지에 액세스하면 웹 서버는 해당 웹 페이지의 서블릿 태그를 해당 서블릿에서 생성된 하이퍼 텍스트로 대체합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 생성자, Java 및 복사 생성자의 생성자 오버로딩이란 무엇입니까?

생성자는 새 객체가 생성될 때 호출됩니다. 모든 클래스에는 [생성자가 있습니다](http://www.javacodegeeks.com/2014/01/which-is-better-option-cloning-or-copy-constructors.html). 프로그래머가 클래스에 대한 생성자를 제공하지 않는 경우 Java 컴파일러(Javac)는 해당 클래스에 대한 기본 생성자를 생성합니다. 생성자 오버로딩은 Java의 메소드 오버로딩과 유사합니다. 단일 클래스에 대해 다른 생성자를 만들 수 있습니다. 각 생성자에는 고유한 매개변수 목록이 있어야 합니다. 마지막으로 Java는 C++와 같은 복사 생성자를 지원하지만 차이점은 사용자가 직접 작성하지 않으면 Java가 기본 복사 생성자를 생성하지 않는다는 사실에 있습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 애플릿 보안 관리자는 무엇이며 무엇을 제공합니까?

애플릿 보안 관리자는 Java 애플릿에 제한을 부과하는 메커니즘입니다. 브라우저에는 보안 관리자가 하나만 있을 수 있습니다. 보안 관리자는 시작 시 설정되며 이후에는 교체, 과부하, 재정의 또는 확장될 수 없습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Java 우선 순위 대기열이란 무엇입니까?

[PriorityQueue](http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html)는 우선 순위 힙을 기반으로 하는 무제한 대기열이며 해당 요소가 자연 순서대로 정렬됩니다. . 생성 시 [PriorityQueue](http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html) 요소의 순서를 지정하는 Comparator를 제공할 수 있습니다. ). [PriorityQueue](http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html)는 null 값, 자연스러운 순서를 제공하지 않는 개체 또는 연결된 비교기가 없는 개체. 마지막으로 Java [PriorityQueue](http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html)는 스레드로부터 안전하지 않으며 O(log(n)) 시간이 필요합니다. 대기열에 넣고 빼는 작업을 위해.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Comparable 및 Comparator 인터페이스란 무엇입니까? 차이점을 나열하십시오.

Java는 [compareTo](http:// docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html#compareTo(T)). 이 방법은 두 객체를 비교하여 그들 사이에 순서를 부과합니다. 특히 입력 개체가 기존 개체보다 작거나 같거나 큼을 나타내기 위해 음의 정수, 0 또는 양의 정수를 반환합니다. Java는 [compare](http://docs .oracle.com/javase/7/docs/api/java/util/Comparator.html#compare(T,%20T)) 및 [equals](http://docs.oracle.com/javase/7/docs/ API/java/util/Comparator.html#equals(java.lang.Object)). 첫 번째 방법은 두 입력 인수를 비교하고 그들 사이에 순서를 부과합니다. 음의 정수, 0 또는 양의 정수를 반환하여 첫 번째 인수가 두 번째 인수보다 작거나 같거나 큼을 나타냅니다. 두 번째 방법은 매개변수로 객체를 필요로 하며 입력 객체가 비교기와 같은지 여부를 결정하는 것을 목표로 합니다. 메서드는 지정된 개체가 비교자이기도 하고 비교자와 동일한 순서를 적용하는 경우에만 true를 반환합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 어떤 Swing 메서드가 스레드로부터 안전합니까?

스레드로부터 안전한 방법은 세 가지뿐입니다:
* repaint, 
* revalidate,
* invalidate.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 이벤트 수신기 인터페이스와 이벤트 어댑터 클래스 사이의 관계는 무엇입니까?

이벤트 수신기 인터페이스는 특정 이벤트에 대한 이벤트 핸들러가 구현해야 하는 메서드를 정의합니다. 이벤트 어댑터는 이벤트 수신기 인터페이스의 기본 구현을 제공합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### ArrayList와 LinkedList의 차이점은 무엇입니까?

[ArrayList](http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html) 및 [LinkedList](http://docs.oracle.com/javase/7 /docs/api/java/util/LinkedList.html) 클래스는 List 인터페이스를 구현하지만 다음 기능에서 다릅니다:

* [ArrayList](http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html)는 [Array](http://docs .oracle.com/javase/7/docs/api/java/lang/reflect/Array.html). O(1)과 ​​동일한 성능으로 요소에 대한 임의 액세스를 제공합니다. 반면에 [LinkedList](http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html)는 데이터를 요소 목록으로 저장하고 모든 요소는 이전 및 다음 요소. 이 경우 요소에 대한 검색 작업의 실행 시간은 O(n)과 같습니다.
* [LinkedList](http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html)에서 요소의 삽입, 추가 및 제거 작업이 [ArrayList]에 비해 더 빠릅니다. ](http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html), 임의의 배열에 요소를 추가할 때 배열의 크기를 조정하거나 인덱스를 업데이트할 필요가 없기 때문에 컬렉션 내부의 위치.
* [LinkedList](http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html)는 [ArrayList](http://docs.oracle.com)보다 메모리를 더 많이 사용합니다. /javase/7/docs/api/java/util/ArrayList.html), 왜냐하면 [LinkedList](http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList)의 모든 노드 .html)은 두 개의 참조를 저장합니다. 하나는 이전 요소에 대한 참조이고 다른 하나는 다음 요소에 대한 참조입니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Array와 ArrayList의 차이점은 무엇입니까? 언제 ArrayList보다 Array를 사용합니까?

Array 및 ArrayList 클래스는 다음 기능이 다릅니다.

* [Arrays](http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html)는 기본 또는 객체를 포함할 수 있지만 [ArrayList](http://docs.oracle .com/javase/7/docs/api/java/util/ArrayList.html)에는 개체만 포함될 수 있습니다.
* [Arrays](http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html)는 크기가 고정되어 있는 반면 [ArrayList](http://docs.oracle.com)는 /javase/7/docs/api/java/util/ArrayList.html)은 동적입니다.
* [ArrayList](http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html)는 addAll, removeAll, iterator 등과 같은 더 많은 메소드와 기능을 제공합니다.
* 원시 데이터 유형 목록의 경우 컬렉션은 자동 박싱을 사용하여 코딩 노력을 줄입니다. 그러나 이 접근 방식을 사용하면 고정 크기 기본 데이터 유형에서 작업할 때 속도가 느려집니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### hashCode() 및 equals() 메서드의 중요성은 무엇입니까?

Java의 [HashMap](http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html)은 hashCode 및 equals 메소드를 사용하여 키-값 쌍의 인덱스를 결정합니다. 이러한 메소드는 특정 키의 값을 요청할 때도 사용됩니다. 이러한 방법이 올바르게 구현되지 않으면 두 개의 다른 키가 동일한 해시 값을 생성할 수 있으므로 컬렉션에서 동일한 것으로 간주됩니다. 또한 이러한 방법은 중복을 감지하는 데에도 사용됩니다. 따라서 두 방법의 구현은 [HashMap](http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html)의 정확성과 정확성에 매우 중요합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Fail-fast와 Fail-safe의 차이점은 무엇입니까?

[Iterator의](http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html) fail-safe 속성은 기본 컬렉션의 복제본과 함께 작동하므로 영향을 받지 않습니다. 컬렉션의 모든 수정에 의해. java.util 패키지의 모든 컬렉션 클래스는 fail-fast인 반면 java.util.concurrent의 컬렉션 클래스는 fail-safe입니다. Fail-fast iterator는 [ConcurrentModificationException](http://examples.javacodegeeks.com/java-basics/exceptions/java-util-concurrentmodificationexception-how-to-handle-concurrent-modification-exception/)을 던지지만, fail-safe iterator는 그런 예외를 던지지 않습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### JDBC에서 Driver의 역할을 설명하라

JDBC 드라이버는 JDBC API에서 제공하는 추상 클래스의 공급업체별 구현을 제공합니다. 각 드라이버는 java.sql 패키지의 다음 클래스에 대한 구현을 제공해야 합니다. [Connection](http://docs.oracle.com/javase/7/docs/api/java/sql/Connection.html),[Statement](http://docs.oracle.com/javase/7/docs/api/java/sql/Statement.html), [PreparedStatement](http://docs.oracle.com/javase/7/docs/api/java/sql/PreparedStatement.html), [CallableStatement](http://docs.oracle.com/javase/7/docs/api/java/sql/CallableStatement.html), [ResultSet](http://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html) and [Driver](http://docs.oracle.com/javase/7/docs/api/java/sql/Driver.html).

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Iterator와 ListIterator에는 어떤 차이점이 있습니까?

이러한 요소의 차이점은 다음과 같습니다.

* [Iterator](http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html)는 [Set](http://docs.oracle.txt)를 순회하는 데 사용할 수 있습니다. com/javase/7/docs/api/java/util/Set.html) 및 [목록](http://docs.oracle.com/javase/7/docs/api/java/util/List.html) 컬렉션 , [ListIterator](http://docs.oracle.com/javase/7/docs/api/java/util/ListIterator.html)는 [List](http://docs.html)에 대해서만 반복하는 데 사용할 수 있습니다. oracle.com/javase/7/docs/api/java/util/List.html) .
* [Iterator](http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html)는 순방향으로만 컬렉션을 순회할 수 있지만 [ListIterator](http:/ /docs.oracle.com/javase/7/docs/api/java/util/ListIterator.html) [목록](http://docs.oracle.com/javase/7/docs/api/java/ util/List.html)을 양방향으로 사용할 수 있습니다.
* [ListIterator](http://docs.oracle.com/javase/7/docs/api/java/util/ListIterator.html)는 [Iterator](http://docs.oracle.com/javase/ 7/docs/api/java/util/Iterator.html) 인터페이스이며 요소 추가, 요소 교체, 이전 및 다음 요소에 대한 인덱스 위치 가져오기 등과 같은 추가 기능이 포함되어 있습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Statement보다 PreparedStatement의 장점은 무엇입니까?

PreparedStatements는 미리 컴파일되어 있으므로 [성능이 훨씬 더 좋습니다](http://examples.javacodegeeks.com/core-java/sql/batch-statement-execution-example/). 또한 PreparedStatement 객체는 쿼리에 대한 다른 입력 값으로 재사용될 수 있습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### CallableStatement의 용도는 무엇입니까? CallableStatement를 준비하는 데 사용되는 메서드의 이름을 지정합니다.

[CallableStatement](http://docs.oracle.com/javase/7/docs/api/java/sql/CallableStatement.html)는 저장 프로시저를 실행하는 데 사용됩니다. 저장 프로시저는 데이터베이스에 의해 저장되고 제공됩니다. 저장 프로시저는 사용자로부터 입력 값을 받아 결과를 반환할 수 있습니다. 저장 프로시저의 사용은 보안과 모듈성을 제공하므로 적극 권장됩니다. [CallableStatement]를 준비하는 메서드(http://docs.oracle.com/javase/7/docs/api/java/sql/CallableStatement.html )는 다음과 같습니다.

```java
CallableStament.prepareCall();
```


###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### doGet()과 doPost()의 차이점은 무엇입니까?

* **doGET**: GET 메소드는 요청의 URL에 이름-값 쌍을 추가합니다. 따라서 문자 수와 클라이언트 요청에 사용할 수 있는 값 수에 제한이 있습니다. 또한 요청의 값이 표시되므로 민감한 정보가 이러한 방식으로 전달되지 않아야 합니다.
* **doPOST**: POST 메서드는 요청 값을 본문 내부에 전송하여 GET 요청에 의해 부과된 제한을 극복합니다. 또한 전송할 값의 수에는 제한이 없습니다. 마지막으로 POST 요청을 통해 전달된 민감한 정보는 외부 클라이언트에 표시되지 않습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 서블릿의 생명주기를 설명하라.

모든 클라이언트의 요청에 따라 서블릿 엔진은 서블릿을 로드하고 초기화 메소드를 호출하여 서블릿을 초기화합니다. 그런 다음 Servlet 개체는 각 요청에 대해 별도로 서비스 메서드를 호출하여 해당 클라이언트에서 오는 모든 후속 요청을 처리합니다. 마지막으로 서버의 destroy 메소드를 호출하여 서블릿을 제거합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### GenericServlet과 HttpServlet의 차이점은 무엇입니까?

GenericServlet은 Servlet 및 ServletConfig 인터페이스를 구현하는 일반화된 프로토콜 독립 서블릿입니다. GenericServlet 클래스를 확장하는 서블릿은 서비스 메서드를 재정의해야 합니다. 마지막으로 HTTP 프로토콜을 사용하여 요청을 처리하는 웹에서 사용할 HTTP 서블릿을 개발하려면 서블릿이 대신 HttpServlet을 확장해야 합니다. [서블릿 예제는 여기](http://examples.javacodegeeks.com/tag/servlet/)를 확인하세요.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### JSP의 장점은 무엇입니까?

JSP 기술 사용의 이점은 다음과 같습니다.

* JSP 페이지는 동적으로 서블릿으로 컴파일되므로 개발자는 프레젠테이션 코드를 쉽게 업데이트할 수 있습니다.
* JSP 페이지는 미리 컴파일될 수 있습니다.
* JSP 페이지는 동적 콘텐츠를 생성하는 코드를 사용하여 HTML 또는 XML 조각을 포함한 정적 템플릿에 쉽게 결합될 수 있습니다.
* 개발자는 XML과 유사한 구문을 사용하여 페이지 작성자가 액세스하는 사용자 정의된 JSP 태그 라이브러리를 제공할 수 있습니다.
* 개발자는 응용 프로그램의 논리를 사용하는 개별 페이지를 편집하지 않고 구성 요소 수준에서 논리를 변경할 수 있습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 교착 상태란 무엇입니까?

[두 프로세스가 서로 완료되기를 기다리고 있을 때](http://www.javacodegeeks.com/2013/01/java-deadlock-example-how-to-analyze-deadlock-situation.html) 때 발생하는 조건, 진행하기 전에. 결과는 두 프로세스가 끝없이 대기한다는 것입니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 애플릿과 서블릿의 차이점은 무엇입니까?

애플릿은 클라이언트 시스템의 웹 브라우저 내에서 실행되는 클라이언트 측 Java 프로그램입니다. 반면에 서블릿은 웹 서버에서 실행되는 서버 측 구성 요소입니다. 애플릿은 사용자 인터페이스 클래스를 사용할 수 있지만 서블릿에는 사용자 인터페이스가 없습니다. 대신 서블릿은 클라이언트의 HTTP 요청을 기다리고 모든 요청에서 응답을 생성합니다. 

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 스크립틀릿이란 무엇입니까?

JSP(Java Server Pages) 기술에서 스크립틀릿은 JSP 페이지에 포함된 Java 코드 조각입니다. 스크립틀릿은 태그 안에 있는 모든 것입니다. 이러한 태그 사이에 사용자는 유효한 스크립틀릿을 추가할 수 있습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Java는 다중 상속을 지원합니까?

아니요, Java는 다중 상속을 지원하지 않습니다. 각 클래스는 하나의 클래스에서만 확장할 수 있지만 둘 이상의 인터페이스를 구현할 수 있습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 스레드를 생성하는 다양한 방법을 설명합니다. 어느 것을 선호하고 그 이유는 무엇입니까?

[Thread](http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html)를 생성하기 위해 사용할 수 있는 세 가지 방법이 있습니다.

* 클래스는 [Thread](http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html) 클래스를 확장할 수 있습니다.
* 클래스는 [Runnable](http://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html) 인터페이스를 구현할 수 있습니다.
* 응용 프로그램은 스레드 풀을 생성하기 위해 [Executor](http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executor.html) 프레임워크를 사용할 수 있습니다.

[Runnable](http://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html) 인터페이스는 [Thread](http //docs.oracle.com/javase/7/docs/api/java/lang/Thread.html) 클래스. 애플리케이션 디자인에 다중 상속이 필요한 경우 인터페이스만 도움이 될 수 있습니다. 또한 스레드 풀은 매우 효율적이며 구현 및 사용이 매우 쉽습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### JSP 암묵적 객체가 의미하는 바는 무엇이며 어떤 객체입니까?

JSP 암시적 개체는 JSP 컨테이너가 각 페이지의 개발자에게 제공하는 Java 개체입니다. 개발자는 명시적으로 선언하지 않고 직접 호출할 수 있습니다. JSP 암시적 개체는 미리 정의된 변수라고도 합니다. 다음 개체는 JSP 페이지에서 암시적으로 간주됩니다:

* application
* page
* request
* response
* session
* exception
* out
* config
* pageContext

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### RMI 란 무엇입니까?

Java RMI(Java Remote Method Invocation)는 직렬화된 Java 클래스 및 분산 가비지 수집의 직접 전송을 지원하여 RPC(원격 프로시저 호출)와 동일한 객체 지향을 수행하는 Java API입니다. 원격 메서드 호출(RMI)은 원격으로 실행 중인 개체에서 메서드를 활성화하는 프로세스로도 볼 수 있습니다. RMI는 사용자가 메소드가 로컬에서 실행되는 객체에서 실행된다고 느끼기 때문에 위치 투명성을 제공합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 사용 가능한 스레드 상태를 개략적으로 설명합니다.

실행 중에 스레드는 다음 상태 중 하나에 있을 수 있습니다.

* Runnable: 스레드가 실행할 준비가 되지만 반드시 즉시 실행을 시작할 필요는 없습니다.
* 실행 중: 프로세서가 스레드 코드를 능동적으로 실행하고 있습니다.
* Waiting: 스레드가 일부 외부 처리가 완료되기를 기다리는 차단된 상태입니다.
* Sleeping: 스레드가 강제로 휴면 상태가 됩니다.
* I/O에서 차단됨: I/O 작업이 완료될 때까지 대기 중입니다.
* 동기화 시 차단됨: 잠금 획득을 기다리는 중입니다.
* Dead: 스레드가 실행을 완료했습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 마샬링과 디마샬링에 대해 설명합니다.

응용 프로그램이 네트워크를 통해 메모리 개체를 다른 호스트로 전달하거나 저장소에 유지하려는 경우 메모리 내 표현을 적절한 형식으로 변환해야 합니다. 이 프로세스를 마샬링이라고 하고 되돌리기 작업을 디마샬링이라고 합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### N 스레드가 교착 상태 없이 N 리소스에 액세스할 수 있도록 하는 방법은 무엇입니까?

N 스레드를 사용하는 동안 교착 상태를 피하는 매우 간단한 방법은 잠금에 순서를 지정하고 각 스레드가 해당 순서를 따르도록 하는 것입니다. 따라서 모든 스레드가 동일한 순서로 뮤텍스를 잠그고 잠금 해제하면 교착 상태가 발생할 수 없습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 힙에서 Perm Gen 공간이란 무엇입니까?

Perm Gen은 영구 생성을 의미합니다. 사용자 클래스(Java 언어의 일부가 아닌 클래스)를 설명하는 메타 데이터를 보유하는 Java 힙의 공간입니다. 이러한 메타 데이터의 예로는 클래스와 메서드를 설명하는 개체가 있으며 영구 세대에 저장됩니다. 코드 기반이 큰 애플리케이션은 ```-Xmx```(메모리의 최대 크기)에 상관없이 ```java.lang.OutOfMemoryError: PermGen```이 발생하는 이 힙 세그먼트를 빠르게 채울 수 있습니다. 할당 풀) 및 컴퓨터에 있는 메모리 양.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 연결 풀링은 무엇을 의미합니까?

데이터베이스와의 상호 작용은 데이터베이스 연결의 열기 및 닫기와 관련하여 비용이 많이 들 수 있습니다. 특히, 데이터베이스 클라이언트의 수가 증가하면 이 비용이 매우 높고 많은 자원이 소모된다. 데이터베이스 연결 풀은 애플리케이션 서버에 의해 시작될 때 얻어지고 풀에서 유지된다. 연결 요청은 [풀에 있는 연결]

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 애플릿 클래스 로더는 무엇이며 무엇을 제공합니까?

애플릿이 인터넷을 통해 로드될 때 애플릿은 애플릿 클래스 로더에 의해 로드됩니다. 클래스 로더는 Java 이름 공간 계층 구조를 적용합니다. 또한 클래스 로더는 로컬 파일 시스템에서 가져온 클래스에 대해 고유한 네임스페이스가 존재하고 각 네트워크 소스에 대해 고유한 네임스페이스가 존재함을 보장합니다. 브라우저가 네트를 통해 애플릿을 로드할 때 해당 애플릿의 클래스는 애플릿의 원본과 관련된 개인 이름 공간에 배치됩니다. 그런 다음 클래스 로더에 의해 로드된 클래스는 검증자를 통해 전달됩니다. 검증자는 클래스 파일이 Java 언어 사양을 준수하는지 확인합니다. 무엇보다도 검증자는 스택 오버플로나 언더플로가 없고 모든 바이트코드 명령어에 대한 매개변수가 올바른지 확인합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
###  인터넷을 통해 로드된 애플릿과 파일 시스템을 통해 로드된 애플릿의 차이점은 무엇입니까?

애플릿이 인터넷을 통해 로드되는 경우 애플릿은 애플릿 클래스 로더에 의해 로드되며 애플릿 보안 관리자가 적용하는 제한 사항이 적용됩니다. 애플릿이 클라이언트의 로컬 디스크에서 로드되는 경우 애플릿은 파일 시스템 로더에 의해 로드됩니다. 파일 시스템을 통해 로드된 애플릿은 파일을 읽고, 파일을 쓰고, 클라이언트에서 라이브러리를 로드할 수 있습니다. 또한 파일 시스템을 통해 로드된 애플릿은 프로세스를 실행할 수 있으며 마지막으로 파일 시스템을 통해 로드된 애플릿은 바이트 코드 검증기를 거치지 않습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Servlet Chaining 이란?

Servlet Chaining은 한 서블릿의 출력을 두 번째 서블릿으로 보내는 방법입니다. 두 번째 서블릿의 출력은 세 번째 서블릿으로 보내지는 식으로 계속될 수 있습니다. 체인의 마지막 서블릿은 클라이언트에 응답을 보내는 역할을 합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 어떤 클라이언트 머신이 당신의 서블릿에 요청하고 있는지 어떻게 알 수 있나요?

ServletRequest 클래스에는 클라이언트 시스템의 IP 주소 또는 호스트 이름을 찾는 기능이 있습니다. getRemoteAddr()은 클라이언트 시스템의 IP 주소를 가져오고 getRemoteHost()는 클라이언트 시스템의 호스트 이름을 가져옵니다. [여기](http://examples.javacodegeeks.com/enterprise-java/servlet/get-client-s-address-and-hostname-in-servlet/) 예제를 참조하세요.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### Java Collection 프레임워크와 관련된 모범 사례는 무엇입니까?

* 응용 프로그램의 요구 사항에 따라 사용할 올바른 유형의 컬렉션을 선택하는 것은 성능에 매우 중요합니다. 예를 들어 요소의 크기가 고정되어 있고 선험적으로 알고 있는 경우 [Array](http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Array.html ), [ArrayList](http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html) 대신.
* 일부 컬렉션 클래스에서는 초기 용량을 지정할 수 있습니다. 따라서 저장될 요소의 수에 대한 추정이 있는 경우 이를 사용하여 재해시 또는 크기 조정을 피할 수 있습니다.
* 유형 안전성, 가독성 및 견고성을 위해 항상 Generics를 사용하십시오. 또한 Generics를 사용하면 런타임 중에 [ClassCastException](http://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html)을 피할 수 있습니다.
* [hashCode](http://docs.oracle.com/javase/7/docs/api/)의 구현을 피하기 위해 JDK(Java Development Kit)에서 제공하는 변경할 수 없는 클래스를 Map의 키로 사용합니다. java/lang/Object.html#hashCode%28%29) 및 사용자 정의 클래스에 대한 equals 메소드.
* 구현이 아닌 인터페이스 측면에서 프로그램.
* 기본 컬렉션이 실제로 비어 있는 경우 null을 반환하는 것과 달리 길이가 0인 컬렉션이나 배열을 반환합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 동기화된 방법과 동기화된 블록의 차이점은 무엇입니까?

Java 프로그래밍에서 각 객체에는 잠금이 있습니다. 스레드는 동기화된 키워드를 사용하여 개체에 대한 잠금을 획득할 수 있습니다. 동기화된 키워드는 메서드 수준(거친 잠금) 또는 코드의 블록 수준(세밀한 잠금)에 적용할 수 있습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### RMI 아키텍처의 기본 원리는 무엇입니까?

RMI 아키텍처는 동작의 정의와 해당 동작의 구현이 별개의 개념이라는 매우 중요한 원칙에 기반합니다. RMI를 사용하면 동작을 정의하는 코드와 동작을 구현하는 코드가 별도로 유지되고 별도의 JVM에서 실행될 수 있습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### RMI에서 RMISecurityManager를 사용하는 목적은 무엇입니까?

RMISecurityManager는 다운로드된 코드를 사용하는 RMI 애플리케이션에서 사용할 수 있는 보안 관리자를 제공합니다. RMI의 클래스 로더는 보안 관리자가 설정되지 않은 경우 원격 위치에서 클래스를 다운로드하지 않습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### RMI에서 원격 인터페이스의 역할은 무엇입니까?

원격 인터페이스는 로컬이 아닌 가상 머신에서 호출될 수 있는 메서드의 인터페이스를 식별하는 역할을 합니다. 원격 개체인 모든 개체는 이 인터페이스를 직접 또는 간접적으로 구현해야 합니다. 원격 인터페이스를 구현하는 클래스는 구현되는 원격 인터페이스를 선언하고, 각 원격 개체에 대한 생성자를 정의하고, 모든 원격 인터페이스에서 각 원격 메서드에 대한 구현을 제공해야 합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### java.rmi.Naming 클래스의 역할은 무엇입니까?

java.rmi.Naming 클래스는 원격 객체 레지스트리에 원격 객체에 대한 참조를 저장하고 획득하기 위한 메소드를 제공합니다. Naming 클래스의 각 메소드는 URL 형식의 문자열인 이름을 인수 중 하나로 취합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### RMI에서 바인딩이란 무엇을 의미합니까?

바인딩은 원격 개체를 찾기 위해 나중에 사용할 수 있는 원격 개체의 이름을 연결하거나 등록하는 프로세스입니다. 원격 객체는 Naming 클래스의 bind 또는 rebind 메소드를 사용하여 이름과 연관될 수 있습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 직렬 및 처리량 가비지 수집기의 차이점은 무엇입니까?

처리량 가비지 수집기는 젊은 세대 수집기의 병렬 버전을 사용하며 중간에서 대규모 데이터 세트가 있는 응용 프로그램과 함께 사용됩니다. 반면에 직렬 수집기는 일반적으로 대부분의 소규모 응용 프로그램(최신 프로세서에서 최대 약 100MB의 힙이 필요한 응용 프로그램)에 적합합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### HashSet과 TreeSet의 차이점은 무엇입니까?

[HashSet](http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html)은 해시 테이블을 사용하여 구현되므로 요소가 정렬되지 않습니다. [HashSet](http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html)의 추가, 제거 및 포함 메소드는 일정한 시간 복잡도 O(1)를 갖습니다. 한편, [TreeSet](http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html)은 트리 구조로 구현되어 있다. [TreeSet](http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html)의 요소는 정렬되어 있으므로 추가, 제거 및 포함 메서드에 시간이 있습니다. O(log n)의 복잡도.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### JVM의 영구 생성 공간에서 Garbage Collection이 발생합니까?

가비지 수집은 PermGen 공간에서 발생하며 PermGen 공간이 가득 차거나 임계값을 초과하면 전체 가비지 수집을 트리거할 수 있습니다. 가비지 수집기의 출력을 주의 깊게 살펴보면 PermGen 공간도 가비지 수집됨을 알 수 있습니다. 이것이 PermGen 공간의 정확한 크기가 빈번한 전체 가비지 수집을 피하기 위해 중요한 이유입니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### DGC 란 무엇입니까? 어떻게 작동합니까??

DGC는 Distributed Garbage Collection의 약자입니다. RMI(Remote Method Invocation)는 자동 가비지 수집을 위해 DGC를 사용합니다. RMI는 JVM 전반에 걸친 원격 객체 참조를 포함하기 때문에 가비지 수집이 상당히 어려울 수 있습니다. DGC는 참조 카운팅 알고리즘을 사용하여 원격 개체에 대한 자동 메모리 관리를 제공합니다.


###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### RMI 아키텍처의 계층은 무엇입니까?

RMI 아키텍처는 다음 계층으로 구성됩니다.

* 스텁 및 스켈레톤 레이어: 이 레이어는 개발자 보기 바로 아래에 있습니다. 이 계층은 클라이언트가 인터페이스에 대해 만든 메서드 호출을 가로채고 이러한 호출을 원격 RMI 서비스로 리디렉션하는 역할을 합니다.
* 원격 참조 계층: RMI 아키텍처의 두 번째 계층은 클라이언트에서 서버의 원격 개체에 대한 참조 해석을 처리합니다. 이 계층은 클라이언트에서 원격 서비스 개체에 대한 참조를 해석하고 관리합니다. 연결은 일대일(유니캐스트) 링크입니다.
* Transport layer: 서비스에 참여하는 두 개의 JVM을 연결하는 역할을 하는 계층이다. 이 계층은 네트워크에 있는 시스템 간의 TCP/IP 연결을 기반으로 합니다. 기본 연결과 일부 방화벽 침투 전략을 제공합니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
### 스레드 동기화는 모니터 내부에서 어떻게 발생합니까? 어떤 수준의 동기화를 적용할 수 있습니까?

JVM은 모니터와 함께 잠금을 사용합니다. 모니터는 기본적으로 동기화된 코드 시퀀스를 감시하고 한 번에 하나의 스레드만 동기화된 코드 조각을 실행하도록 하는 보호자입니다. 각 모니터는 개체 참조와 연결됩니다. 스레드는 잠금을 얻을 때까지 코드를 실행할 수 없습니다.

###### Source

* https://github.com/snowdream/115-Java-Interview-Questions-and-Answers

[[↑] 맨 위로](#Java)
