## JavaScript

[JavaScript에서 강제 변환이란 무엇입니까?](#JavaScript에서-강제-변환이란-무엇입니까)

[typeof 연산자는 무엇입니까?](#typeof-연산자는-무엇입니까)

[개체 유형은 무엇입니까?](#개체-유형은-무엇입니까)

[JavaScript에서 배열 설명](#JavaScript에서-배열-설명)

[JavaScript에서 equality 설명](#JavaScript에서-equality-설명)

[JavaScript에서 스코프란?](#JavaScript에서-스코프란?)

[JavaScript에서 let 키워드는 무엇입니까?](#JavaScript에서-let-키워드는-무엇입니까)

[콜백 함수가 무엇인지 설명하고 간단한 예제를 설명하시오](#콜백-함수가-무엇인지-설명하고-간단한-예제를-설명하시오)

[Strict Mode는 무엇입니까?](#Strict-Mode는-무엇입니까)

["use strict"은 무엇을 합니까?](#use-strict은-무엇을-합니까)

[Polyfill이란?](#Polyfill이란)

[숫자가 정수인지 어떻게 확인합니까?](#숫자가-정수인지-어떻게-확인합니까)

[JavaScript의 값과 유형 설명](#JavaScript의-값과-유형-설명)

[정렬되지 않은 배열에 (n - 1)개의 연속된 숫자가 포함되어 있다고 하면(한계가 정의된 경우), O(n) 시간에서 결측 수를 찾습니다.](#정렬되지-않은-배열에-n---1개의-연속된-숫자가-포함되어-있다고-하면한계가-정의된-경우-On-시간에서-결측-수를-찾습니다)

[배열의 중복을 제거하고 고유한 요소의 배열만 반환합니다.](#배열의-중복을-제거하고-고유한-요소의-배열만-반환합니다)

[문자열이 주어지면 문장의 각 단어를 뒤집습니다.](#문자열이-주어지면-문장의-각-단어를-뒤집습니다)

[이것을 할 수 있는 함수를 작성하세요.](#이것을-할-수-있는-함수를-작성하세요)

[두 개의 스택만 사용하여 enqueue 및 dequeue 구현](#두-개의-스택만-사용하여-enqueue-및-dequeue-구현)

[closure를 사용하여 개인 카운터를 만드는 방법은 무엇입니까?](#closure를-사용하여-개인-카운터를-만드는-방법은-무엇입니까)

[JavaScript에서 Null 및 Undefined 설명](#JavaScript에서-Null-및-Undefined-설명)

[Event bubbling 및 이를 방지할 수 있는 방법 설명](#Event-bubbling-및-이를-방지할-수-있는-방법-설명)

[객체가 배열인지 확인하는 방법은 무엇입니까? 코드를 제공하십시오.](#객체가-배열인지-확인하는-방법은-무엇입니까?-코드를-제공하십시오)

[아래 구문과 같이 호출될 때 제대로 작동하는 "mul" 함수를 작성하십시오.](#아래-구문과-같이-호출될-때-제대로-작동하는-mul-함수를-작성하십시오)

[JavaScript에서 배열을 비우는 방법은 무엇입니까?](#JavaScript에서-배열을-비우는-방법은-무엇입니까)

[JavaScript에서 두 객체를 비교하는 방법은 무엇입니까?](#JavaScript에서-두-객체를-비교하는-방법은-무엇입니까)

[정수 배열이 주어지면 두 요소 사이의 가장 큰 차이를 구하여 값이 작은 요소가 큰 요소보다 앞에 와야 합니다.](#정수-배열이-주어지면-두-요소-사이의-가장-큰-차이를-구하여-값이-작은-요소가-큰-요소보다-앞에-와야 합니다)

[두 배열의 교집합을 찾습니다. 교차는 두 배열 내에 존재하는 공통 요소입니다. 이 경우 이러한 요소는 고유해야 합니다!](#두-배열의-교집합을-찾습니다-교차는-두-배열-내에-존재하는-공통-요소입니다-이-경우-이러한-요소는-고유해야-합니다)

[이 작업을 수행할 수 있는 함수를 작성하십시오.](#이-작업을-수행할-수-있는-함수를-작성하십시오)

[두 개의 문자열이 주어지면 서로의 아나그램이면 true를 반환합니다.](#두-개의-문자열이-주어지면-서로의-아나그램이면-true를-반환합니다)

[주어진 문자열이 회문인지 확인하십시오. 대소문자 구분을 고려해야 합니다.](#주어진-문자열이-회문인지-확인하십시오-대소문자-구분을-고려해야-합니다)

[shim과 polyfill의 차이점은 무엇입니까?](#shim과-polyfill의-차이점은-무엇입니까)

[다음 코드는 무엇을 출력할까요?](#다음-코드는-무엇을-출력할까요)

[ES5와 ES6의 차이점을 설명해 주시겠습니까?](#ES5와-ES6의-차이점을-설명해-주시겠습니까)

[IIFE(즉시 호출된 함수 표현식)란 무엇입니까?](#IIFE즉시-호출된-함수-표현식란-무엇입니까)

[다음 코드의 출력은 무엇입니까?](#다음-코드의-출력은-무엇입니까)

[다음 코드의 출력은 무엇입니까?](#다음-코드의-출력은-무엇입니까)

[부울 값을 부울 값으로 강제 변환하는 몇 가지 예를 제공합니다.](#provide-some-examples-of-non-boolean-value-coercion-to-a-boolean-one)

[JavaScript에서 "정의되지 않음"과 "정의되지 않음"의 차이점 설명](#부울-값을-부울-값으로-강제-변환하는-몇-가지-예를-제공합니다)

[다음 코드의 출력은 무엇입니까?](#다음-코드의-출력은-무엇입니까)

[JavaScript에서 진정한 private을 생성할 때의 단점은 무엇입니까?](#JavaScript에서-진정한-private을-생성할-때의-단점은-무엇입니까)

[익명 함수와 명명 함수의 차이점은 무엇입니까? ](#익명-함수와-명명-함수의-차이점은-무엇입니까-)

[정수 배열이 주어졌을 때 세 개의 정수에서 가장 큰 곱을 찾습니다.](#정수-배열이-주어졌을-때-세-개의-정수에서-가장-큰-곱을-찾습니다)

[알고있는 만큼 JavaScript에서 closure 개념을 설명하십시오.](#알고있는-만큼-JavaScript에서-closure-개념을-설명하십시오)

[주어진 십진수의 이진 문자열을 반환하는 재귀 함수를 작성하십시오.](#주어진-십진수의-이진-문자열을-반환하는-재귀-함수를-작성하십시오)

[자바 스크립트에서 "closure"이란 무엇입니까? 예를 들어주시겠습니까?](#자바-스크립트에서-closure이란-무엇입니까-예를-들어주시겠습니까)

[Javascript에서 hoisting이 무엇인지 설명](#Javascript에서-hoisting이-무엇인지-설명)

[정수가 주어지면 2의 거듭제곱인지 확인합니다. 그렇다면 해당 숫자를 반환하고, 그렇지 않으면 -1을 반환합니다.](#정수가-주어지면-2의-거듭제곱인지-확인합니다-그렇다면-해당-숫자를-반환하고-그렇지-않으면--1을-반환합니다)

[다음 코드의 출력은 무엇입니까?](#다음-코드의-출력은-무엇입니까)

[JS 모듈 디자인 패턴 설명](#JS-모듈-디자인-패턴-설명)

[JavaScript에서 private variable를 어떻게 만듭니까?](#JavaScript에서-private-variable를-어떻게-만듭니까)

[프로토타입 디자인 패턴 설명](#프로토타입-디자인-패턴-설명)

[이진 검색을 수행하는 재귀 함수 작성](#이진-검색을-수행하는-재귀-함수-작성)

[주어진 표현식에 스택을 사용하여 균형 잡힌 괄호가 있는지 평가하는 함수를 만듭니다.](#주어진-표현식에-스택을-사용하여-균형-잡힌-괄호가-있는지-평가하는-함수를-만듭니다)

[다음 코드의 출력은 무엇입니까?](#다음-코드의-출력은 무엇입니까)

[JavaScript에서 프로토타입 상속을 설명하시겠습니까?](#JavaScript에서-프로토타입-상속을-설명하시겠습니까)

["Transpiling"는 무엇을 의미합니까?](#Transpiling는-무엇을-의미합니까)

[JavaScript에서 "new" 키워드는 무엇입니까?](#JavaScript에서-new-키워드는-무엇입니까)

[언제 "바인드" 기능을 사용하시겠습니까?](#언제-바인드-기능을-사용하시겠습니까)

["this" 키워드는 어떻게 작동합니까? 몇 가지 코드 예제를 제공하십시오.](#this-키워드는-어떻게-작동합니까-몇-가지-코드-예제를-제공하십시오)

[다음 코드가 작동하도록 Array 객체에 고유한 메서드를 어떻게 추가하시겠습니까?](#다음-코드가-작동하도록-Array-객체에-고유한-메서드를-어떻게-추가하시겠습니까)

[JavaScript에서 Hoisting은 무엇입니까?](#JavaScript에서-Hoisting은-무엇입니까)

[다음 코드의 출력은 무엇입니까?](#다음-코드의-출력은-무엇입니까)

[주어진 문자열이 동형인지 확인](#주어진-문자열이-동형인지-확인)

[Revealing Module Pattern 디자인 패턴 설명](#Revealing-Module-Pattern-디자인-패턴-설명)



### JavaScript에서 강제 변환이란 무엇입니까??

JavaScript에서 'coercion'이라고 하는 서로 다른 두 가지 기본 제공 유형 간의 변환. 강제는 JavaScript에서 *explicit* 및 *implicit*의 두 가지 형식으로 제공됩니다.

다음은 explicit coercion의 예입니다:
```js
var a = "42";

var b = Number( a );

a;				// "42"
b;				// 42 -- the number!
```
다음은 implicit coercion의 예입니다.
```js
var a = "42";

var b = a * 1;	// "42" implicitly coerced to 42 here

a;				// "42"
b;				// 42 -- the number!
``` 



[[↑] 맨 위로](#JavaScript)
### typeof 연산자 란 무엇입니까?

JavaScript는 값을 검사하고 어떤 유형인지 알려주는 `typeof` 연산자를 제공합니다:
```js
var a;
typeof a;				// "undefined"

a = "hello world";
typeof a;				// "string"

a = 42;
typeof a;				// "number"

a = true;
typeof a;				// "boolean"

a = null;
typeof a;				// "object" -- weird, bug

a = undefined;
typeof a;				// "undefined"

a = { b: "c" };
typeof a;				// "object"
```




[[↑] 맨 위로](#JavaScript)
### 개체 유형은 무엇입니까?

개체 유형은 각 유형의 고유한 값을 보유하는 속성(명명된 위치)을 설정할 수 있는 복합 값을 나타냅니다.

```js
var obj = {
	a: "hello world", // property
	b: 42,
	c: true
};

obj.a;		// "hello world", accessed with doted notation
obj.b;		// 42
obj.c;		// true

obj["a"];	// "hello world", accessed with bracket notation
obj["b"];	// 42
obj["c"];	// true
```
대괄호 표기법은 속성/키에 액세스하고 싶지만 이름이 다음과 같은 다른 변수에 저장되어 있는 경우에도 유용합니다:
```js
var obj = {
	a: "hello world",
	b: 42
};

var b = "a";

obj[b];			// "hello world"
obj["b"];		// 42
```



[[↑] 맨 위로](#JavaScript)
### JavaScript에서 배열 설명

'배열'은 특별히 명명된 속성/키가 아니라 숫자로 인덱싱된 위치에 값(모든 유형의)을 보유하는 객체입니다.

```js
var arr = [
	"hello world",
	42,
	true
];

arr[0];			// "hello world"
arr[1];			// 42
arr[2];			// true
arr.length;		// 3

typeof arr;		// "object"
```




[[↑] 맨 위로](#JavaScript)
### JavaScript에서 equality 설명

JavaScript에는 엄격한 비교와 유형 변환 비교가 모두 있습니다.
* **Strict comparison (e.g., ===)** *coercion*을 허용하지 않고 값이 같은지 확인합니다.
* **Abstract comparison (e.g. ==)** *coercion*이 허용되는 값이 같은지 확인합니다.

```js
var a = "42";
var b = 42;

a == b;			// true
a === b;		// false
```

몇 가지 간단한 equality 규칙:
* 비교해서 어느 한 값(사이드)이 '참' 또는 '거짓' 값이 될 수 있는 경우 '=='를 피하고 '==='를 사용하십시오.
* 비교의 값 중 하나가 이러한 특정 값(`0`, `""` 또는 `[]` -- 빈 배열)일 수 있는 경우 `==`를 피하고 `===`를 사용하세요.
* 다른 모든 경우에는 `==`를 사용하는 것이 안전합니다. 안전할 뿐만 아니라 많은 경우 가독성을 높이는 방식으로 코드를 단순화합니다.



[[↑] 맨 위로](#JavaScript)
### JavaScript에서 스코프란?

JavaScript에서 각 함수는 고유한 *범위*를 갖습니다. 범위는 기본적으로 변수의 모음과 이러한 변수에 이름으로 액세스하는 방법에 대한 규칙입니다. 해당 함수 내부의 코드만 해당 함수의 범위 변수에 액세스할 수 있습니다.


변수 이름은 동일한 범위 내에서 고유해야 합니다. 범위는 다른 범위 안에 중첩될 수 있습니다. 한 범위가 다른 범위 안에 중첩되어 있으면 가장 안쪽 범위 내의 코드가 두 범위의 변수에 액세스할 수 있습니다.



[[↑] 맨 위로](#JavaScript)
### JavaScript에서 let 키워드는 무엇입니까?

함수 수준에서 변수에 대한 선언을 생성하는 것 외에도 ES6에서는 `let` 키워드를 사용하여 개별 블록({ .. } 쌍)에 속하는 변수를 선언할 수 있습니다.

###### Source

* https://github.com/getify/You-Dont-Know-JS/blob/master/up%20%26%20going/ch2.md

[[↑] 맨 위로](#JavaScript)
### 콜백 함수가 무엇인지 설명하고 간단한 예제를 설명하시오

'콜백' 함수는 다른 함수에 인수로 전달되고 일부 작업이 완료된 후 실행되는 함수입니다. 다음은 일부 작업이 완료된 *후* 콘솔에 기록하는 간단한 콜백 함수의 예입니다.

```js
function modifyArray(arr, callback) {
  // do something to arr here
  arr.push(100);
  // then execute the callback function that was passed
  callback();
}

var arr = [1, 2, 3, 4, 5];

modifyArray(arr, function() {
  console.log("array has been modified", arr);
});
```

###### Source

* https://coderbyte.com/algorithm/10-common-javascript-interview-questions

[[↑] 맨 위로](#JavaScript)
### Strict Mode는 무엇입니까?

*Strict Mode*는 ECMAScript 5의 새로운 기능으로 프로그램이나 기능을 "strict" 작동 컨텍스트에 배치할 수 있습니다. 이 엄격한 컨텍스트는 특정 작업이 수행되는 것을 방지하고 더 많은 예외를 발생시킵니다.

```js
// Non-strict code...

(function(){
  "use strict";

  // Define your library strictly...
})();

// Non-strict code...
```



[[↑] 맨 위로](#JavaScript)
### "use strict"은 무엇을 합니까?

'use strict' 리터럴은 자바스크립트 프로그램 상단이나 함수 상단에 입력되며, 실수로 전역 변수를 생성할 경우 오류를 발생시켜 보다 안전한 자바스크립트 코드를 작성할 수 있도록 도와줍니다. 예를 들어 다음 프로그램은 오류를 발생시킵니다.

```js
function doSomething(val) {
  "use strict"; 
  x = val + 10;
}`
```

`x`가 정의되지 않았고 전역 범위에서 일부 값으로 설정되고 있기 때문에 오류가 발생합니다. 이는 `use strict'로 허용되지 않습니다. 아래의 작은 변경이 발생하는 오류를 수정합니다:

```js
function doSomething(val) {
  "use strict"; 
  var x = val + 10;
}
```

###### Source

* https://coderbyte.com/algorithm/10-common-javascript-interview-questions

[[↑] 맨 위로](#JavaScript)
### Polyfill 이란?

polyfill은 본질적으로 현재 또는 "최신" 브라우저에서 기대하는 특정 기능을 내장하여 해당 기능을 지원하지 않는 다른 브라우저에서도 작동하도록 하는 특정 코드(또는 플러그인)입니다.
* Polyfill은 HTML5 표준의 일부가 아닙니다.
* Polyfilling은 Javascript에 국한되지 않습니다.

###### Source

* http://www.programmerinterview.com/index.php/html5/html5-polyfill/

[[↑] 맨 위로](#JavaScript)
### 숫자가 정수인지 어떻게 확인합니까?

숫자가 소수인지 정수인지 확인하는 매우 간단한 방법은 1로 나눌 때 나머지가 남아 있는지 확인하는 것입니다.

```js
function isInt(num) {
  return num % 1 === 0;
}

console.log(isInt(4)); // true
console.log(isInt(12.2)); // false
console.log(isInt(0.3)); // false
```

###### Source

* https://coderbyte.com/algorithm/10-common-javascript-interview-questions

[[↑] 맨 위로](#JavaScript)
### JavaScript의 값과 유형 설명

JavaScript에는 유형이 지정된 변수가 아니라 유형이 지정된 값이 있습니다. 다음 기본 제공 유형을 사용할 수 있습니다:
* `string`
* `number`
* `boolean`
* `null` and `undefined`
* `object`
* `symbol` (new to ES6)



[[↑] 맨 위로](#JavaScript)
### 정렬되지 않은 배열에 (n - 1)개의 연속된 숫자가 포함되어 있다고 하면(한계가 정의된 경우), O(n) 시간에서 결측 수를 찾습니다.

```js
// The output of the function should be 8
var arrayOfIntegers = [2, 5, 1, 4, 9, 6, 3, 7];
var upperBound = 9;
var lowerBound = 1;

findMissingNumber(arrayOfIntegers, upperBound, lowerBound); // 8

function findMissingNumber(arrayOfIntegers, upperBound, lowerBound) {
  // Iterate through array to find the sum of the numbers
  var sumOfIntegers = 0;
  for (var i = 0; i < arrayOfIntegers.length; i++) {
    sumOfIntegers += arrayOfIntegers[i];
  }

  // Find theoretical sum of the consecutive numbers using a variation of Gauss Sum.
  // Formula: [(N * (N + 1)) / 2] - [(M * (M - 1)) / 2];
  // N is the upper bound and M is the lower bound

  upperLimitSum = (upperBound * (upperBound + 1)) / 2;
  lowerLimitSum = (lowerBound * (lowerBound - 1)) / 2;

  theoreticalSum = upperLimitSum - lowerLimitSum;

  return theoreticalSum - sumOfIntegers;
}
```

###### Source

* https://github.com/kennymkchan/interview-questions-in-javascript

[[↑] 맨 위로](#JavaScript)
### 배열의 중복을 제거하고 고유한 요소의 배열만 반환합니다.

```js
// ES6 Implementation
var array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];

Array.from(new Set(array)); // [1, 2, 3, 5, 9, 8]

// ES5 Implementation
var array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];

uniqueArray(array); // [1, 2, 3, 5, 9, 8]

function uniqueArray(array) {
  var hashmap = {};
  var unique = [];

  for(var i = 0; i < array.length; i++) {
    // If key returns undefined (unique), it is evaluated as false.
    if(!hashmap.hasOwnProperty(array[i])) {
      hashmap[array[i]] = 1;
      unique.push(array[i]);
    }
  }

  return unique;
}
```

###### Source

* https://github.com/kennymkchan/interview-questions-in-javascript

[[↑] 맨 위로](#JavaScript)
### 문자열이 주어지면 문장의 각 단어를 뒤집습니다.

```js
var string = "Welcome to this Javascript Guide!";

// Output becomes !ediuG tpircsavaJ siht ot emocleW
var reverseEntireSentence = reverseBySeparator(string, "");

// Output becomes emocleW ot siht tpircsavaJ !ediuG
var reverseEachWord = reverseBySeparator(reverseEntireSentence, " ");

function reverseBySeparator(string, separator) {
  return string.split(separator).reverse().join(separator);
}
```

###### Source

* https://github.com/kennymkchan/interview-questions-in-javascript

[[↑] 맨 위로](#JavaScript)
### 이것을 할 수 있는 함수를 작성하세요.

```js
var addSix = createBase(6);
addSix(10); // returns 16
addSix(21); // returns 27
```

내부 함수가 반환된 후에도 `createBase` 함수에 전달된 값을 유지하기 위해 closure를 만들 수 있습니다. 반환되는 내부 함수는 외부 함수 내에서 생성되어 closure가 되며 외부 함수 내의 변수(이 경우 변수 'baseNumber')에 액세스할 수 있습니다.

```js
function createBase(baseNumber) {
  return function(N) {
    // we are referencing baseNumber here even though it was declared
    // outside of this function. Closures allow us to do this in JavaScript
    return baseNumber + N;
  }
}

var addSix = createBase(6);
addSix(10);
addSix(21);
```

###### Source

* https://coderbyte.com/algorithm/3-common-javascript-closure-questions

[[↑] 맨 위로](#JavaScript)
### 두 개의 스택만 사용하여 enqueue 및 dequeue 구현

*Enqueue*는 요소를 추가하는 것을 의미하고 *dequeue*는 요소를 제거하는 것을 의미합니다.

```js
var inputStack = []; // First stack
var outputStack = []; // Second stack

// For enqueue, just push the item into the first stack
function enqueue(stackInput, item) {
  return stackInput.push(item);
}

function dequeue(stackInput, stackOutput) {
  // Reverse the stack such that the first element of the output stack is the
  // last element of the input stack. After that, pop the top of the output to
  // get the first element that was ever pushed into the input stack
  if (stackOutput.length <= 0) {
    while(stackInput.length > 0) {
      var elementToOutput = stackInput.pop();
      stackOutput.push(elementToOutput);
    }
  }

  return stackOutput.pop();
}
```

###### Source

* https://github.com/kennymkchan/interview-questions-in-javascript

[[↑] 맨 위로](#JavaScript)
### closure를 사용하여 개인 카운터를 만드는 방법은 무엇입니까?

개인 변수를 업데이트할 수 있도록 하는 외부 함수(closure) 내에서 함수를 만들 수 있지만 도우미 함수를 사용하지 않고는 함수 외부에서 변수에 액세스할 수 없습니다.

```js
function counter() {
  var _counter = 0;
  // return an object with several functions that allow you
  // to modify the private _counter variable
  return {
    add: function(increment) { _counter += increment; },
    retrieve: function() { return 'The counter is currently at: ' + _counter; }
  }
}

// error if we try to access the private variable like below
// _counter;

// usage of our counter function
var c = counter();
c.add(5); 
c.add(9); 

// now we can access the private variable in the following way
c.retrieve(); // => The counter is currently at: 14
```

###### Source

* https://coderbyte.com/algorithm/3-common-javascript-closure-questions

[[↑] 맨 위로](#JavaScript)
### JavaScript에서 Null 및 Undefined 설명

JavaScript(및 TypeScript 확장)에는 'null'과 'undefined'라는 두 가지 하단 유형이 있습니다. 그들은 *의도가* 다른 것을 의미합니다:
* 초기화되지 않은 항목이 있습니다 : `undefined`.
* 현재 사용할 수 없는 항목이 있습니다: `null`.



[[↑] 맨 위로](#JavaScript)
### Event bubbling 및 이를 방지할 수 있는 방법 설명

**Event bubbling** 는 이벤트가 가능한 가장 깊은 요소에서 트리거되고 상위 요소에서 중첩 순서로 트리거되는 개념입니다. 결과적으로 자식 요소를 클릭하면 활성화되는 부모의 핸들러가 나타날 수 있습니다.

Event bubbling을 방지하는 한 가지 방법은 IE < 9에서 `event.stopPropagation()` 또는 `event.cancelBubble`을 사용하는 것입니다.

###### Source

* https://github.com/kennymkchan/interview-questions-in-javascript

[[↑] 맨 위로](#JavaScript)
### 객체가 배열인지 확인하는 방법은 무엇입니까? 코드를 제공하십시오.

> `Object.prototype`의 `toString` 메소드를 사용하여 객체가 특정 클래스의 인스턴스인지 여부를 찾는 가장 좋은 방법

```javascript
var arrayList = [1 , 2, 3];
```

객체의 타입 체크를 할 때 가장 좋은 사용 사례 중 하나는 자바스크립트에서 메소드 오버로딩을 할 때입니다. 이를 이해하기 위해 하나의 문자열과 하나의 문자열 목록을 포함하는 `greet`이라는 방법이 있다고 가정하자. 따라서 `greet` 방법을 사용할 수 있게 만드는 것은 단일 값 또는 가치 목록 중 어떤 종류의 매개 변수가 전달되는지 알아야 한다.

```javascript
function greet(param) {
  if() {
    // here have to check whether param is array or not
  }
  else {
  }
}
```

그러나 위의 구현에서는 배열 유형을 확인할 필요가 없을 수 있습니다. 단일 값 문자열을 확인하고 배열 논리 코드를 else 블록에 넣을 수 있습니다. 아래 코드에서 동일한 내용을 참조하십시오.

```javascript
 function greet(param) {
   if(typeof param === 'string') {
   }
   else {
     // If param is of type array then this block of code would execute
   }
 }
```

이제 위의 두 가지 구현으로 갈 수 있지만 매개변수와 같은 상황이 'single value', 'array' 및 'object' 유형일 수 있는 경우 문제가 발생합니다.

객체 유형 확인으로 돌아가서 `Object.prototype.toString`을 사용할 수 있다고 언급했습니다.

```javascript
if(Object.prototype.toString.call(arrayList) === '[object Array]') {
  console.log('Array!');
}
```

`jQuery`를 사용하는 경우 jQuery `isArray` 메소드를 사용할 수도 있습니다:

```javascript
if($.isArray(arrayList)) {
  console.log('Array');
} else {
  console.log('Not an array');
}
```

참고로 jQuery는 내부적으로 `Object.prototype.toString.call`을 사용하여 객체가 배열인지 여부를 확인합니다.

최신 브라우저에서는 다음을 사용할 수도 있습니다:

```javascript
Array.isArray(arrayList);
```

`Array.isArray`는 Chrome 5, Firefox 4.0, IE 9, Opera 10.5 및 Safari 5에서 지원됩니다.

###### Source

* https://github.com/ganqqwerty/123-Essential-JavaScript-Interview-Question/blob/master/README.md

[[↑] 맨 위로](#JavaScript)
### 아래 구문과 같이 호출될 때 제대로 작동하는 "mul" 함수를 작성하십시오.

```javascript
function mul (x) {
  return function (y) { // anonymous function
    return function (z) { // anonymous function
      return x * y * z;
    };
  };
}
```

여기서 `mul` 함수는 첫 번째 인수를 받아들이고 두 번째 매개변수를 사용하는 익명 함수를 반환하고 세 번째 매개변수를 사용하고 연속적으로 전달되는 인수의 곱을 반환하는 익명 함수를 반환합니다.

JavaScript에서 내부에 정의된 함수는 외부 함수 변수에 접근할 수 있으며 함수는 첫 번째 클래스 객체이므로 함수에서도 반환되고 다른 함수의 인수로 전달할 수 있습니다.
- 함수는 Object 유형의 인스턴스입니다.
- 함수는 속성을 가질 수 있으며 생성자 메서드에 대한 링크가 있습니다.
- 함수를 변수로 저장할 수 있습니다.
- 함수는 다른 함수에 매개변수로 전달할 수 있습니다.
- 함수에서 함수를 반환할 수 있습니다.

###### Source

* https://github.com/ganqqwerty/123-Essential-JavaScript-Interview-Question/blob/master/README.md

[[↑] 맨 위로](#JavaScript)
### JavaScript에서 배열을 비우는 방법은 무엇입니까?

**첫번째 방법**

```javascript
arrayList = [];
```

위의 코드는 `arrayList` 변수를 새로운 빈 배열로 설정합니다. 이것은 실제로 새로운 빈 배열을 생성하기 때문에 **원래 배열에 대한 참조** `arrayList`가 다른 곳에 없는 경우 권장됩니다. 다른 변수에서 이 배열을 참조한 경우 원래 참조 배열이 변경되지 않은 상태로 유지되기 때문에 배열을 비우는 이 방법에 주의해야 합니다. 원래 변수 'arrayList'로만 배열을 참조한 경우에만 이 방법을 사용합니다.

예를 들어:

```javascript
var arrayList = ['a', 'b', 'c', 'd', 'e', 'f']; // Created array
var anotherArrayList = arrayList;  // Referenced arrayList by another variable
arrayList = []; // Empty the array
console.log(anotherArrayList); // Output ['a', 'b', 'c', 'd', 'e', 'f']
```

**두번째 방법**

```javascript
arrayList.length = 0;
```

위의 코드는 길이를 0으로 설정하여 기존 배열을 지울 것입니다. 이 방법으로 배열을 비우면 원래 배열을 가리키는 모든 참조 변수도 업데이트됩니다. 배열을 비우는 이 방법은 `arrayList`를 가리키는 다른 모든 참조 변수를 업데이트하려는 경우에 유용합니다.

예를 들어:

```javascript
var arrayList = ['a', 'b', 'c', 'd', 'e', 'f']; // Created array
var anotherArrayList = arrayList;  // Referenced arrayList by another variable
arrayList.length = 0; // Empty the array by setting length to 0
console.log(anotherArrayList); // Output []
```

**세번째 방법**

```javascript
arrayList.splice(0, arrayList.length);
```

위의 구현도 완벽하게 작동합니다. 이 방법으로 배열을 비우면 원래 배열의 모든 참조도 업데이트됩니다.

```javascript
var arrayList = ['a', 'b', 'c', 'd', 'e', 'f']; // Created array
var anotherArrayList = arrayList;  // Referenced arrayList by another variable
arrayList.splice(0, arrayList.length); // Empty the array by setting length to 0
console.log(anotherArrayList); // Output []
```

**네번째 방법**

```javascript
while(arrayList.length) {
  arrayList.pop();
}
```

위의 구현은 배열을 비울 수도 있습니다. 그러나 자주 사용하는 것은 권장하지 않습니다.

###### Source

* https://github.com/ganqqwerty/123-Essential-JavaScript-Interview-Question/blob/master/README.md

[[↑] 맨 위로](#JavaScript)
### JavaScript에서 두 객체를 비교하는 방법은 무엇입니까?

참조에 의해 유지되는 객체(함수 및 배열 포함)와 같은 두 개의 기본이 아닌 값, 따라서 `==` 및 `===` 비교는 기본 값에 대한 것이 아니라 참조가 일치하는지 여부를 단순히 확인합니다.

예를 들어 '배열'은 기본적으로 모든 값을 사이에 쉼표(`,`)로 결합하여 문자열로 강제 변환됩니다. 따라서 동일한 내용을 가진 두 배열은 `==` 같지 않습니다:

```js
var a = [1,2,3];
var b = [1,2,3];
var c = "1,2,3";

a == c;		// true
b == c;		// true
a == b;		// false
```
*deep object comparison*를 위해 `deep-equal`과 같은 외부 라이브러리를 사용하거나 고유한 재귀 동등 알고리즘을 구현하십시오.




[[↑] 맨 위로](#JavaScript)
### 정수 배열이 주어지면 두 요소 사이의 가장 큰 차이를 구하여 값이 작은 요소가 큰 요소보다 앞에 와야 합니다.

```js
var array = [7, 8, 4, 9, 9, 15, 3, 1, 10];
// [7, 8, 4, 9, 9, 15, 3, 1, 10] would return `11` based on the difference between `4` and `15`
// Notice: It is not `14` from the difference between `15` and `1` because 15 comes before 1.

findLargestDifference(array);

function findLargestDifference(array) {
  // If there is only one element, there is no difference
  if (array.length <= 1) return -1;

  // currentMin will keep track of the current lowest
  var currentMin = array[0];
  var currentMaxDifference = 0;

  // We will iterate through the array and keep track of the current max difference
  // If we find a greater max difference, we will set the current max difference to that variable
  // Keep track of the current min as we iterate through the array, since we know the greatest
  // difference is yield from `largest value in future` - `smallest value before it`

  for (var i = 1; i < array.length; i++) {
    if (array[i] > currentMin && (array[i] - currentMin > currentMaxDifference)) {
      currentMaxDifference = array[i] - currentMin;
    } else if (array[i] <= currentMin) {
      currentMin = array[i];
    }
  }

  // If negative or 0, there is no largest difference
  if (currentMaxDifference <= 0) return -1;

  return currentMaxDifference;
}
```

###### Source

* https://github.com/kennymkchan/interview-questions-in-javascript

[[↑] 맨 위로](#JavaScript)
### 두 배열의 교집합을 찾습니다. 교차는 두 배열 내에 존재하는 공통 요소입니다. 이 경우 이러한 요소는 고유해야 합니다!

```js
var firstArray = [2, 2, 4, 1];
var secondArray = [1, 2, 0, 2];

intersection(firstArray, secondArray); // [2, 1]

function intersection(firstArray, secondArray) {
  // The logic here is to create a hashmap with the elements of the firstArray as the keys.
  // After that, you can use the hashmap's O(1) look up time to check if the element exists in the hash
  // If it does exist, add that element to the new array.

  var hashmap = {};
  var intersectionArray = [];

  firstArray.forEach(function(element) {
    hashmap[element] = 1;
  });

  // Since we only want to push unique elements in our case... we can implement a counter to keep track of what we already added
  secondArray.forEach(function(element) {
    if (hashmap[element] === 1) {
      intersectionArray.push(element);
      hashmap[element]++;
    }
  });

  return intersectionArray;

  // Time complexity O(n), Space complexity O(n)
}
```

###### Source

* https://github.com/kennymkchan/interview-questions-in-javascript

[[↑] 맨 위로](#JavaScript)
### 이 작업을 수행할 수 있는 함수를 작성하십시오.

내부 함수가 반환된 후에도 의 값을 유지하기 위해 *closure*를 만들 수 있습니다. 반환되는 내부 함수는 외부 함수 내에서 생성되어 closure가 되며 외부 함수 내의 변수(이 경우 변수 'a')에 액세스할 수 있습니다.

```js
function multiply(a) {
  return function(b) {
    return a * b;
  }
}

multiply(5)(6);
```



###### Source

* https://coderbyte.com/algorithm/10-common-javascript-interview-questions

[[↑] 맨 위로](#JavaScript)
### 두 개의 문자열이 주어지면 서로의 아나그램이면 true를 반환합니다.

```js
var firstWord = "Mary";
var secondWord = "Army";

isAnagram(firstWord, secondWord); // true

function isAnagram(first, second) {
  // For case insensitivity, change both words to lowercase.
  var a = first.toLowerCase();
  var b = second.toLowerCase();

  // Sort the strings, and join the resulting array to a string. Compare the results
  a = a.split("").sort().join("");
  b = b.split("").sort().join("");

  return a === b;
}
```

###### Source

* https://github.com/kennymkchan/interview-questions-in-javascript

[[↑] 맨 위로](#JavaScript)
### 주어진 문자열이 회문인지 확인하십시오. 대소문자 구분을 고려해야 합니다.

**palindrome** 는 앞뒤로 같은 단어, 구, 숫자 또는 기타 일련의 문자입니다.

```js
isPalindrome("racecar"); // true
isPalindrome("race Car"); // true

function isPalindrome(word) {
  // Replace all non-letter chars with "" and change to lowercase
  var lettersOnly = word.toLowerCase().replace(/\s/g, "");

  // Compare the string with the reversed version of the string
  return lettersOnly === lettersOnly.split("").reverse().join("");
}
```
또한 표준 답변보다 '25배' 빠름
```js
function isPalindrome(s,i) {
   return (i=i||0)<0||i>=s.length>>1||s[i]==s[s.length-1-i]&&isPalindrome(s,++i);
}
```


###### Source

* https://github.com/kennymkchan/interview-questions-in-javascript

[[↑] 맨 위로](#JavaScript)
### shim과 polyfill의 차이점은 무엇입니까?

* **shim**은 API 호출을 가로채고 추상화 계층을 제공하는 코드입니다. 반드시 웹 애플리케이션이나 HTML5/CSS3으로 제한되는 것은 아닙니다.

* **polyfill**은 일반적으로 Javascript 또는 Flash를 사용하는 최신 HTML5/CSS3 기능으로 기존 브라우저를 개조하는 일종의 shim입니다.

shim은 해당 환경의 수단만을 사용하여 기존 환경에 새로운 API를 제공하는 라이브러리입니다. 따라서 폴리필은 브라우저 API용 shim입니다.

###### Source

* https://stackoverflow.com/questions/6599815/what-is-the-difference-between-a-shim-and-a-polyfill

[[↑] 맨 위로](#JavaScript)

### 다음 코드는 무엇을 출력할까요?

```js
(function() {
  var a = b = 5;
})();

console.log(b);
```

위의 코드는 변수가 함수 내에서 선언되고 함수 외부에서 액세스할 수 없는 것처럼 보이지만 5를 출력합니다. 이 때문입니다

```js
var a = b = 5;
```

다음과 같이 해석됩니다:

```js
var a = b;
b = 5;
```

그러나 `b`는 `var`가 있는 함수의 어느 곳에서도 선언되지 않았으므로 *전역 범위*에서 5와 동일하게 설정됩니다.

###### Source

* https://coderbyte.com/algorithm/10-common-javascript-interview-questions

[[↑] 맨 위로](#JavaScript)
### ES5와 ES6의 차이점을 설명해 주시겠습니까?

* **ECMAScript 5 (ES5)**: 2009년에 표준화된 ECMAScript 5판. 이 표준은 모든 최신 브라우저에서 상당히 완벽하게 구현되었습니다.

* **ECMAScript 6 (ES6)/ ECMAScript 2015 (ES2015)**: 2015년에 표준화된 ECMAScript 6판. 이 표준은 대부분의 최신 브라우저에서 부분적으로 구현되었습니다.

ES5와 ES6의 주요 차이점은 다음과 같습니다:
* **Arrow functions** & **string interpolation**:<br/>
고려하다:
```js
const greetings = (name) => {
      return `hello ${name}`;
}
```
게다가:
```js
const greetings = name => `hello ${name}`;
```
* **Const**. <br>
Const는 여러 면에서 다른 언어에서 상수처럼 작동하지만 몇 가지 주의 사항이 있습니다. Const는 값에 대한 'constant reference'를 나타냅니다. 따라서 const를 사용하면 변수가 참조하는 객체의 속성을 실제로 변경할 수 있습니다. 참조 자체를 변경할 수는 없습니다.
```js
const NAMES = [];
NAMES.push("Jim");
console.log(NAMES.length === 1); // true
NAMES = ["Steve", "John"]; // error
```
* **Block-scoped variables**.<br>
새로운 ES6 키워드 'let'을 사용하면 개발자가 블록 수준에서 변수 범위를 지정할 수 있습니다.
'Let'은 'var'와 같은 방식으로 호이스트하지 않습니다.
* **Default parameter values**
기본 매개변수를 사용하면 기본값으로 함수를 초기화할 수 있습니다. 인수가 생략되거나 정의되지 않은 경우 기본값이 사용됩니다. 즉, null이 유효한 값입니다.
```js
// Basic syntax
function multiply (a, b = 2) {
     return a * b;
}
multiply(5); // 10
```
* **Class Definition and Inheritance**<br>
ES6에서는 클래스(`class` 키워드), 생성자(`constructor` 키워드) 및 상속을 위한 `extend` 키워드에 대한 언어 지원을 도입했습니다.

* **for-of operator**<br>
for...of 문은 반복 가능한 객체를 반복하는 루프를 만듭니다.
* **Spread Operator**
개체 병합의 경우
```js
const obj1 = { a: 1, b: 2 }
const obj2 = { a: 2, c: 3, d: 4}
const obj3 = {...obj1, ...obj2}
```
* **Promises**<br>
Promise는 비동기 작업의 결과와 오류를 처리하는 메커니즘을 제공합니다. 콜백으로도 동일한 작업을 수행할 수 있지만 Promise는 메서드 체인 및 간결한 오류 처리를 통해 가독성을 향상시킵니다.
```js
const isGreater = (a, b) => {
  return new Promise ((resolve, reject) => {
    if(a > b) {
      resolve(true)
    } else {
      reject(false)
    }
    })
}
isGreater(1, 2)
  .then(result => {
    console.log('greater')
  })
 .catch(result => {
    console.log('smaller')
 })
```
* **Modules exporting & importing**
모듈 내보내기 고려:
```js
const myModule = { x: 1, y: () => { console.log('This is ES5') }}
export default myModule;
```
및 가져오기:
```js
import myModule from './myModule';
```




[[↑] 맨 위로](#JavaScript)
### IIFE(즉시 호출된 함수 표현식)란 무엇입니까?

즉시 호출된 함수 표현식, 줄여서 IIFE입니다. 생성 직후 실행됩니다:
```js
(function IIFE(){
	console.log( "Hello!" );
})();
// "Hello!"
```

이 패턴은 IIFE 내부에서 사용되는 모든 변수(다른 일반 함수와 마찬가지로)가 범위 외부에서 보이지 않기 때문에 전역 이름 공간을 오염시키는 것을 피하려고 할 때 자주 사용됩니다.

###### Source

* https://stackoverflow.com/questions/8228281/what-is-the-function-construct-in-javascript

[[↑] 맨 위로](#JavaScript)
### 다음 코드의 출력은 무엇입니까?

```js
var x = { foo : 1};
var output = (function() {
  delete x.foo;
  return x.foo;
})();

console.log(output);
```

위의 코드는 'undefined'를 출력으로 출력합니다. 'delete' 연산자는 객체에서 속성을 삭제하는 데 사용됩니다. 여기서 `x`는 속성으로 foo를 갖는 객체이고 자체 호출 함수에서 객체 `x`의 foo 속성을 삭제하고 삭제 후 삭제된 속성 `foo`를 참조하려고 하여 `undefined`가 됩니다.

###### Source

* https://github.com/ganqqwerty/123-Essential-JavaScript-Interview-Question/blob/master/README.md

[[↑] 맨 위로](#JavaScript)

### 다음 코드의 출력은 무엇입니까?

```js
var x = 1;
var output = (function() {
  delete x;
  return x;
})();

console.log(output);
```

위의 코드는 '1'을 출력으로 출력합니다. 'delete' 연산자는 객체에서 속성을 삭제하는 데 사용됩니다. 여기서 `x`는 객체가 아니라 `number` 유형의 **전역 변수**입니다.


###### Source

* https://github.com/ganqqwerty/123-Essential-JavaScript-Interview-Question/blob/master/README.md

[[↑] 맨 위로](#JavaScript)
### 부울 값을 부울 값으로 강제 변환하는 몇 가지 예를 제공합니다.

문제는 부울이 아닌 값이 부울로 강제 변환될 때 각각 'true' 또는 'false'가 됩니까?

JavaScript에서 "falsy" 값의 특정 목록은 다음과 같습니다:

* `""` (empty string)
* `0`, `-0`, `NaN` (invalid number)
* `null`, `undefined`
* `false`

이 "falsy" 목록에 없는 값은 "truthy"입니다. 다음은 그 중 몇 가지 예입니다:

* `"hello"`
* `42`
* `true`
* `[ ]`, `[ 1, "2", 3 ]` (arrays)
* `{ }`, `{ a: 42 }` (objects)
* `function foo() { .. }` (functions)




[[↑] 맨 위로](#JavaScript)
### JavaScript에서 "정의되지 않음"과 "정의되지 않음"의 차이점 설명

JavaScript에서 존재하지 않고 선언되지 않은 변수를 사용하려고 하면 JavaScript에서 'var name is not defined' 오류가 발생하고 이후 스크립트 실행이 중지됩니다. 그러나 `typeof undeclared_variable`을 사용하면 `undefined`를 반환합니다.

추가 논의를 시작하기 전에 선언과 정의의 차이점을 이해합시다.

'var x'는 아직 어떤 값을 보유하고 있는지 정의하지 않았기 때문에 선언입니다. 그러나 당신은 그것의 존재와 메모리 할당의 필요성을 선언하고 있습니다.

```javascript
var x; // declaring x
console.log(x); //output: undefined
```

`var x = 1`은 선언이자 정의입니다(초기화를 수행하고 있다고 말할 수 있음). 여기서 선언과 값 할당은 변수 x에 대해 인라인으로 발생합니다. JavaScript에서 모든 변수 선언과 함수 선언은 현재 범위의 맨 위로 가져옵니다. 선언된 다음 할당은 이 용어를 '호이스팅'이라고 하는 순서대로 발생합니다.

선언되었지만 정의되지 않은 변수에 액세스하려고 하면 'undefined'이 됩니다.

```javascript
var x; // Declaration
if(typeof x === 'undefined') // Will return true
```

> 이러한 변수를 참조하려고 할 때 선언도 정의도 되지 않은 변수는 'not defined'이 됩니다.

```javascript
console.log(y);  // Output: ReferenceError: y is not defined
```

###### Source

* http://stackoverflow.com/questions/20822022/javascript-variable-definition-declaration

[[↑] 맨 위로](#JavaScript)
### 다음 코드의 출력은 무엇입니까?

```js
var y = 1;

if (function f(){}) {
  y += typeof f;
}

console.log(y);
```

위의 코드는 `1undefined`를 출력합니다. If 조건문은 `eval`을 사용하여 평가하므로 `eval(function f() {})`은 true인 `function f() {}`를 반환하므로 if 문 코드가 실행됩니다. 'typeof f'는 정의되지 않은 값을 반환합니다. if 문 코드가 런타임에 실행되므로 'if' 조건 안의 문이 런타임에 평가되기 때문입니다.

```js
var k = 1;
if (1) {
  eval(function foo() {});
  k += typeof foo;
}
console.log(k);
```

위의 코드는 '1undefined'도 출력합니다.

```js
var k = 1;
if (1) {
  function foo() {};
  k += typeof foo;
}
console.log(k); // output 1function
```

###### Source

* https://www.codementor.io/nihantanu/21-essential-javascript-tech-interview-practice-questions-answers-du107p62z

[[↑] 맨 위로](#JavaScript)
### JavaScript에서 진정한 private을 생성할 때의 단점은 무엇입니까?

JavaScript에서 진정한 개인 메서드를 만드는 것의 단점 중 하나는 메서드의 새 복사본이 각 인스턴스에 대해 만들어지기 때문에 메모리가 매우 비효율적이라는 것입니다.

```javascript
var Employee = function (name, company, salary) {
  this.name = name || "";       //Public attribute default value is null
  this.company = company || ""; //Public attribute default value is null
  this.salary = salary || 5000; //Public attribute default value is null

  // Private method
  var increaseSalary = function () {
    this.salary = this.salary + 1000;
  };

  // Public method
  this.dispalyIncreasedSalary = function() {
    increaseSalary();
    console.log(this.salary);
  };
};

// Create Employee class object
var emp1 = new Employee("John","Pluto",3000);
// Create Employee class object
var emp2 = new Employee("Merry","Pluto",2000);
// Create Employee class object
var emp3 = new Employee("Ren","Pluto",2500);
```

여기서 각 인스턴스 변수 'emp1', 'emp2', 'emp3'에는 increaseSalary private method의 copy가 있다

따라서 권장 사항으로 필요한 경우가 아니면 개인 방법을 사용하지 마십시오.

###### Source

* https://github.com/ganqqwerty/123-Essential-JavaScript-Interview-Question/blob/master/README.md

[[↑] 맨 위로](#JavaScript)
### 익명 함수와 명명 함수의 차이점은 무엇입니까?

Consider:
```js
var foo = function() { // anonymous function assigned to variable foo
	// ..
};

var x = function bar(){ // named function (bar) assigned to variable x 
	// ..
};

foo(); // actual function execution
x();
```



[[↑] 맨 위로](#JavaScript)
### 정수 배열이 주어졌을 때 세 개의 정수에서 가장 큰 곱을 찾습니다.

 ```javascript
var unsortedArray = [-10, 7, 29, 30, 5, -10, -70];

computeProduct(unsortedArray); // 21000

function sortIntegers(a, b) {
    return a - b;
}

// Greatest product is either (min1 * min2 * max1 || max1 * max2 * max3)
function computeProduct(unsorted) {
    var sortedArray = unsorted.sort(sortIntegers),
        product1 = 1,
        product2 = 1,
        array_n_element = sortedArray.length - 1;

    // Get the product of three largest integers in sorted array
    for (var x = array_n_element; x > array_n_element - 3; x--) {
        product1 = product1 * sortedArray[x];
    }

    product2 = sortedArray[0] * sortedArray[1] * sortedArray[array_n_element];

    if (product1 > product2) return product1;

    return product2;
}
```

###### Source

* https://github.com/kennymkchan/interview-questions-in-javascript

[[↑] 맨 위로](#JavaScript)
### 알고있는 만큼 JavaScript에서 closure 개념을 설명하십시오.

Consider:
```js
function makeAdder(x) {
	// parameter `x` is an inner variable

	// inner function `add()` uses `x`, so
	// it has a "closure" over `x`
	function add(y) {
		return y + x;
	};

	return add;
}
```
반환된 내부 `add` 함수에 대한 참조는 makeAdder 함수 호출에 전달된 `x` 값을 기억할 수 있습니다.

```js
var plusOne = makeAdder( 1 ); // x is 1, plusOne has a reference to add(y)
var plusTen = makeAdder( 10 ); // x is 10

plusOne(3); // 1 (x) + 3 (y) = 4
plusTen(13); // 10 (x) + 13 (y) = 23 

```
C 및 대부분의 다른 공용 언어에서 함수가 반환된 후 스택 프레임이 파괴되기 때문에 모든 지역 변수에 더 이상 액세스할 수 없습니다.

JavaScript에서 다른 함수 내에서 함수를 선언하면 호출한 함수에서 반환된 후에도 지역 변수에 계속 액세스할 수 있습니다.

closure는 함수가 실행을 시작할 때 할당되고 함수가 반환된 후에 해제되지 않는 스택 프레임입니다('스택 프레임'이 스택이 아닌 힙에 할당된 것처럼!). JavaScript에서 함수 참조 변수는 함수에 대한 포인터와 closure에 대한 숨겨진 포인터를 모두 갖는 것으로 생각할 수 있습니다.




[[↑] 맨 위로](#JavaScript)
### 주어진 십진수의 이진 문자열을 반환하는 재귀 함수를 작성하십시오.

4가 10진수 입력으로 주어지면 함수는 100을 반환해야 합니다.

```js
decimalToBinary(3); // 11
decimalToBinary(8); // 1000
decimalToBinary(1000); // 1111101000

function decimalToBinary(digit) {
  if(digit >= 1) {
    // If digit is not divisible by 2 then recursively return proceeding
    // binary of the digit minus 1, 1 is added for the leftover 1 digit
    if (digit % 2) {
      return decimalToBinary((digit - 1) / 2) + 1;
    } else {
      // Recursively return proceeding binary digits
      return decimalToBinary(digit / 2) + 0;
    }
  } else {
    // Exit condition
    return '';
  }
}
```

###### Source

* https://github.com/kennymkchan/interview-questions-in-javascript

[[↑] 맨 위로](#JavaScript)
### 자바 스크립트에서 "closure"이란 무엇입니까? 예를 들어주시겠습니까?

*closure*는 다른 함수(상위 함수라고 함) 내부에 정의된 함수이며 상위 함수 범위에서 선언되고 정의된 변수에 액세스할 수 있습니다.

closure는 세 가지 범위에서 변수에 액세스할 수 있습니다.
- 자신의 범위에서 선언된 변수
- 상위 함수 범위에서 선언된 변수
- 전역 네임스페이스에 선언된 변수

```javascript
var globalVar = "abc";

// Parent self invoking function
(function outerFunction (outerArg) { // begin of scope outerFunction
  // Variable declared in outerFunction function scope
  var outerFuncVar = 'x';    
  // Closure self-invoking function
  (function innerFunction (innerArg) { // begin of scope innerFunction
    // variable declared in innerFunction function scope
    var innerFuncVar = "y";
    console.log(         
      "outerArg = " + outerArg + "\n" +
      "outerFuncVar = " + outerFuncVar + "\n" +
      "innerArg = " + innerArg + "\n" +
      "innerFuncVar = " + innerFuncVar + "\n" +
      "globalVar = " + globalVar);
  // end of scope innerFunction
  })(5); // Pass 5 as parameter
// end of scope outerFunction
})(7); // Pass 7 as parameter
```

'innerFunction'은 'outerFunction' 내부에 정의된 closure이며 outerFunction 범위에서 선언 및 정의된 모든 변수에 액세스할 수 있습니다. closure로 함수 내부에 정의된 이 함수 외에도 'global namespace'에 선언된 변수에 액세스할 수 있습니다.

위 코드의 출력은 다음과 같습니다:

```javascript
outerArg = 7
outerFuncVar = x
innerArg = 5
innerFuncVar = y
globalVar = abc
```

###### Source

* https://github.com/ganqqwerty/123-Essential-JavaScript-Interview-Question/blob/master/README.md

[[↑] 맨 위로](#JavaScript)
### Javascript에서 hoisting이 무엇인지 설명

**Hoisting** 는 기본적으로 Javascript가 모든 선언을 현재 범위의 맨 위로 이동하는 개념입니다. 따라서 변수는 선언되기 전에 사용할 수 있습니다.

Javascript는 선언만 hoists하고 초기화는 하지 않습니다.

###### Source

* https://github.com/kennymkchan/interview-questions-in-javascript

[[↑] 맨 위로](#JavaScript)
### 정수가 주어지면 2의 거듭제곱인지 확인합니다. 그렇다면 해당 숫자를 반환하고, 그렇지 않으면 -1을 반환합니다.

 참고로 0은 2의 거듭제곱이 아닙니다.

```js
isPowerOfTwo(4); // true
isPowerOfTwo(64); // true
isPowerOfTwo(1); // true
isPowerOfTwo(0); // false
isPowerOfTwo(-1); // false

// For the non-zero case:
function isPowerOfTwo(number) {
  // `&` uses the bitwise n.
  // In the case of number = 4; the expression would be identical to:
  // `return (4 & 3 === 0)`
  // In bitwise, 4 is 100, and 3 is 011. Using &, if two values at the same
  // spot is 1, then result is 1, else 0. In this case, it would return 000,
  // and thus, 4 satisfies are expression.
  // In turn, if the expression is `return (5 & 4 === 0)`, it would be false
  // since it returns 101 & 100 = 100 (NOT === 0)

  return number & (number - 1) === 0;
}

// For zero-case:
function isPowerOfTwoZeroCase(number) {
  return (number !== 0) && ((number & (number - 1)) === 0);
}
```

###### Source

* https://github.com/kennymkchan/interview-questions-in-javascript

[[↑] 맨 위로](#JavaScript)
### 다음 코드의 출력은 무엇입니까?

```js
var Employee = {
  company: 'xyz'
}
var emp1 = Object.create(Employee);
delete emp1.company
console.log(emp1.company);
```

위의 코드는 'xyz'를 출력으로 출력합니다
여기서 `emp1` 객체는 회사를 **prototype** 속성으로 받았습니다.
'delete' 연산자는 프로토타입 속성을 삭제하지 않습니다.

`emp1` 개체에는 **company** 자체 속성으로 없습니다. 다음과 같이 테스트할 수 있습니다:

```js
console.log(emp1.hasOwnProperty('company')); //output : false
``` 

그러나 `delete Employee.company`를 사용하여 `Employee` 객체에서 회사 속성을 직접 삭제할 수도 있고 `__proto__` 속성 `delete emp1.__proto__.company`를 사용하여 `emp1` 객체에서 삭제할 수도 있습니다.

###### Source

* https://github.com/ganqqwerty/123-Essential-JavaScript-Interview-Question/blob/master/README.md

[[↑] 맨 위로](#JavaScript)
### JS 모듈 디자인 패턴 설명

**JavaScript modules** 는 특정 코드 조각을 다른 구성 요소와 독립적으로 유지하기 위해 가장 널리 사용되는 **design patterns**입니다. 이것은 잘 구조화된 코드를 지원하기 위해 느슨한 결합을 제공합니다.

모듈은 개인 범위를 허용하기 위해 *Immediately-Invoked-Function-Expressions(IIFE)*이어야 합니다. 즉, 변수와 메서드를 보호하는 closure입니다(그러나 함수 대신 객체를 반환함). 다음과 같습니다.

```js
(function() {
    // declare private variables and/or functions
    return {
      // declare public variables and/or functions
    }
})();
```
여기서 우리는 반환하려는 객체를 반환하기 전에 개인 변수 및/또는 함수를 인스턴스화합니다. closure 외부의 코드는 동일한 범위에 있지 않기 때문에 이러한 개인 변수에 액세스할 수 없습니다.


###### Source

* https://scotch.io/bar-talk/4-javascript-design-patterns-you-should-know

[[↑] 맨 위로](#JavaScript)
### JavaScript에서 private variable를 어떻게 만듭니까?

JavaScript에서 변경할 수 없는 private 변수를 생성하려면 함수 내에서 로컬 변수로 생성해야 합니다. 함수가 실행되더라도 함수 외부에서 변수에 접근할 수 없습니다. 예를 들어:

```js
function func() {
  var priv = "secret code";
}

console.log(priv); // throws error
```

변수에 액세스하려면 개인 변수를 반환하는 도우미 함수를 만들어야 합니다.

```js
function func() {
  var priv = "secret code";
  return function() {
    return priv;
  }
}

var getPriv = func();
console.log(getPriv()); // => secret code
```

###### Source

* https://coderbyte.com/algorithm/10-common-javascript-interview-questions

[[↑] 맨 위로](#JavaScript)
### 프로토타입 디자인 패턴 설명

*The Prototype Pattern* 는 새 객체를 생성하지만 초기화되지 않은 객체를 생성하는 대신 프로토타입 또는 샘플 객체에서 *복사된* 값으로 초기화된 객체를 반환합니다. 프로토타입 패턴은 속성 패턴이라고도 합니다.

프로토타입 패턴이 유용한 예는 데이터베이스의 기본값과 일치하는 값으로 비즈니스 개체를 초기화하는 것입니다. 프로토타입 객체는 새로 생성된 비즈니스 객체에 복사된 기본값을 보유합니다.

Classical languages는 프로토타입 패턴을 거의 사용하지 않지만, 프로토타입 언어인 JavaScript는 새로운 객체와 프로토타입을 구성할 때 이 패턴을 사용합니다.

###### Source

* http://www.dofactory.com/javascript/prototype-design-pattern

[[↑] 맨 위로](#JavaScript)
### 이진 검색을 수행하는 재귀 함수 작성

```js
function recursiveBinarySearch(array, value, leftPosition, rightPosition) {
  // Value DNE
  if (leftPosition > rightPosition) return -1;

  var middlePivot = Math.floor((leftPosition + rightPosition) / 2);
  if (array[middlePivot] === value) {
    return middlePivot;
  } else if (array[middlePivot] > value) {
    return recursiveBinarySearch(array, value, leftPosition, middlePivot - 1);
  } else {
    return recursiveBinarySearch(array, value, middlePivot + 1, rightPosition);
  }
}
```

###### Source

* https://github.com/kennymkchan/interview-questions-in-javascript

[[↑] 맨 위로](#JavaScript)
### 주어진 표현식에 스택을 사용하여 균형 잡힌 괄호가 있는지 평가하는 함수를 만듭니다.

이 예시에서는 `{}`만 유효한 괄호로 간주할 것입니다. `{}{}`는 균형 조정으로 간주됩니다. `{{{}}`이 균형이 맞지 않습니다.

```js
var expression = "{{}}{}{}"
var expressionFalse = "{}{{}";

isBalanced(expression); // true
isBalanced(expressionFalse); // false
isBalanced(""); // true

function isBalanced(expression) {
  var checkString = expression;
  var stack = [];

  // If empty, parentheses are technically balanced
  if (checkString.length <= 0) return true;

  for (var i = 0; i < checkString.length; i++) {
    if(checkString[i] === '{') {
      stack.push(checkString[i]);
    } else if (checkString[i] === '}') {
      // Pop on an empty array is undefined
      if (stack.length > 0) {
        stack.pop();
      } else {
        return false;
      }
    }
  }

  // If the array is not empty, it is not balanced
  if (stack.pop()) return false;
  return true;
}
```

###### Source

* https://github.com/kennymkchan/interview-questions-in-javascript

[[↑] 맨 위로](#JavaScript)

### 다음 코드의 출력은 무엇입니까?

```js
var output = (function(x) {
  delete x;
  return x;
})(0);

console.log(output);
```

위의 코드는 '0'을 출력으로 출력합니다. 'delete' 연산자는 객체에서 속성을 삭제하는 데 사용됩니다. 여기서 `x`는 객체가 아니라 **local variable**입니다. 'delete' 연산자는 지역 변수에 영향을 미치지 않습니다.

###### Source

* https://github.com/ganqqwerty/123-Essential-JavaScript-Interview-Question/blob/master/README.md

[[↑] 맨 위로](#JavaScript)

### JavaScript에서 프로토타입 상속을 설명하시겠습니까?

Java, C# 또는 C++와 같은 클래식 상속을 구현하는 언어에서는 클래스를 만드는 것(객체의 Blueprint)으로 시작한 다음 해당 클래스에서 새 개체를 생성하거나 클래스를 확장하여 원래 클래스를 확장할 수 있습니다.

JavaScript에서 객체를 먼저 작성한 후(클래스의 개념이 없음) 오브젝트를 확장하거나 오브젝트에서 새 오브젝트를 작성할 수 있습니다.

자바스크립트의 모든 객체에는 *prototype*이 있습니다. JavaScript의 상속 시스템은 프로토타입이며 클래스 기반이 아닙니다. 메시지가 객체에 도달하면 JavaScript는 먼저 해당 객체에서 속성을 찾으려고 시도하고 찾지 못하면 메시지가 객체의 프로토타입으로 전송됩니다. 그 행동을 *prototype chain* 또는 *prototype inheritance*이라고 합니다.

*Constructor functions* JavaScript에서 프로토타입 체인을 구성하는 데 가장 많이 사용되는 방법입니다. `new`를 사용할 때 JavaScript는 `this` 키워드의 형태로 생성되는 새 객체에 대한 암시적 참조를 주입합니다. 또한 함수 끝에서 암시적으로 이 참조를 반환합니다.

```js
function Foo() {
  this.kind = ‘foo’
}

var foo = new Foo(); 
foo.kind //=> ‘foo’
```



###### Source

* http://sporto.github.io/blog/2013/02/22/a-plain-english-guide-to-javascript-prototypes/

[[↑] 맨 위로](#JavaScript)
### "Transpiling"는 무엇을 의미합니까?

언어에 추가된 새 구문을 폴리필할 방법이 없습니다. 따라서 더 나은 옵션은 최신 코드를 이전 코드로 변환하는 도구를 사용하는 것입니다. 이 프로세스는 일반적으로 *transforming + compiling*의 용어인 **Transpiling**이라고 합니다.

일반적으로 코드 린터 또는 축소기와 유사하게 *transpiler*를 빌드 프로세스에 삽입합니다.
선택할 수 있는 몇 가지 훌륭한 transpiler가 있습니다:
* **Babel**: ES6+를 ES5로 변환
* **Traceur**: ES6, ES7 및 그 이상을 ES5로 트랜스파일

###### Source

* https://github.com/getify/You-Dont-Know-JS/blob/master/up%20%26%20going/ch2.md

[[↑] 맨 위로](#JavaScript)
### JavaScript에서 "new" 키워드는 무엇입니까?

1. 새로운 객체를 생성합니다. 이 객체의 유형은 단순히 '객체'입니다.
2. 이것은 이 새로운 객체의 내부, 접근 불가, [[prototype]] (즉, ` __proto__`) 속성을 생성자 함수의 접근 가능한 외부 프로토타입 객체로 설정합니다(모든 함수 객체는 자동으로 프로토타입 속성을 가집니다).
3. `this` 변수가 새로 생성된 객체를 가리키도록 합니다.
4. 이것이 언급될 때마다 새로 생성된 객체를 사용하여 생성자 함수를 실행합니다.
5. 생성자 함수가 null이 아닌 객체 참조를 반환하지 않는 한 새로 생성된 객체를 반환합니다. 이 경우 해당 개체 참조가 대신 반환됩니다.

Consider:
```js
function New(func) {
    var res = {};
    if (func.prototype !== null) {
        res.__proto__ = func.prototype;
    }
    var ret = func.apply(res, Array.prototype.slice.call(arguments, 1));
    if ((typeof ret === "object" || typeof ret === "function") && ret !== null) {
        return ret;
    }
    return res;
}
```

###### Source

* https://stackoverflow.com/questions/1646698/what-is-the-new-keyword-in-javascript

[[↑] 맨 위로](#JavaScript)
### 언제 "바인드" 기능을 사용하시겠습니까?

The `bind()` 메서드는 호출될 때 `this` 키워드가 제공된 값으로 설정되고 새 함수가 호출될 때 제공된 인수 앞에 주어진 시퀀스가 있는 새 함수를 만듭니다.

`bind` 함수의 좋은 사용은 특정 this 값으로 호출하려는 특정 함수가 있을 때입니다. 그런 다음 `bind`를 사용하여 `this` 참조를 사용하는 함수에 특정 객체를 전달할 수 있습니다.

```js
function fullName() {
  return "Hello, this is " + this.first + " " + this.last;
}

console.log(fullName()); // => Hello this is undefined undefined

// create a person object and pass its values to the fullName function
var person = {first: "Foo", last: "Bar"};
console.log(fullName.bind(person)()); // => Hello this is Foo Bar
```

###### Source

* https://coderbyte.com/algorithm/10-common-javascript-interview-questions

[[↑] 맨 위로](#JavaScript)
### "this" 키워드는 어떻게 작동합니까? 몇 가지 코드 예제를 제공하십시오.

JavaScript에서 *this*는 항상 우리가 실행하고 있는 함수의 "소유자", 또는 오히려 함수가 메서드인 객체를 나타냅니다.

Consider:
```js
function foo() {
	console.log( this.bar );
}

var bar = "global";

var obj1 = {
	bar: "obj1",
	foo: foo
};

var obj2 = {
	bar: "obj2"
};

foo();		 	// "global"
obj1.foo();	    // "obj1"
foo.call( obj2 );  // "obj2"
new foo();	     // undefined
```

###### Source

* https://www.quirksmode.org/js/this.html

[[↑] 맨 위로](#JavaScript)
### 다음 코드가 작동하도록 Array 객체에 고유한 메서드를 어떻게 추가하시겠습니까?

JavaScript는 클래스 기반이 아니라 프로토타입 기반 언어입니다. 이것은 각 객체가 다른 객체인 프로토타입에 연결되어 있고 해당 메서드를 상속한다는 것을 의미합니다. 프로토타입이 없는 'null' 오브젝트에 도달할 때까지 각 오브젝트의 프로토타입 체인을 따라갈 수 있습니다. 전역 `Array` 객체에 메소드를 추가해야 하며 `Array prototype`을 수정하여 이를 수행합니다.

```js
Array.prototype.average = function() {
  // calculate sum
  var sum = this.reduce(function(prev, cur) { return prev + cur; });
  // return sum divided by number of elements
  return sum / this.length;
}

var arr = [1, 2, 3, 4, 5];
var avg = arr.average();
console.log(avg); // => 3
```

###### Source

* https://coderbyte.com/algorithm/10-common-javascript-interview-questions

[[↑] 맨 위로](#JavaScript)
### JavaScript에서 Hoisting은 무엇입니까?

*Hoisting* 는 모든 변수 및 함수 선언을 현재 범위의 맨 위로 이동하는 JavaScript 인터프리터의 작업입니다. *hoisting*에는 두 가지 유형이 있습니다.
* variable hoisting - rare
* function hoisting - more common

'var'(또는 함수 선언)가 범위 내에서 나타날 때마다 해당 선언은 전체 범위에 속하는 것으로 간주되고 어디에서나 액세스할 수 있습니다.

```js
var a = 2;
foo();	// works because `foo()`
        // declaration is "hoisted"

function foo() {
	a = 3;
	console.log( a );   // 3
	var a;              // declaration is "hoisted"
                            // to the top of `foo()`
}

console.log( a ); // 2
```

[[↑] 맨 위로](#JavaScript)

### 다음 코드의 출력은 무엇입니까?

```js
0.1 + 0.2 === 0.3
```

특정 숫자를 내부적으로 표현할 때 부동 소수점 오류로 인해 놀랍게도 'false'가 출력됩니다. '0.1 + 0.2'는 '0.3'으로 잘 나오지 않지만 컴퓨터가 내부적으로 정확한 숫자를 표현할 수 없기 때문에 결과는 실제로 '0.30000000000000004'입니다. 이 문제를 해결하는 한 가지 솔루션은 10진수로 산술을 수행할 때 결과를 반올림하는 것입니다.

###### Source

* https://coderbyte.com/algorithm/10-common-javascript-interview-questions

[[↑] 맨 위로](#JavaScript)
### 주어진 문자열이 동형인지 확인

두 문자열이 *동형*이 되도록 하려면 문자열 A에 있는 모든 문자를 다른 문자로 바꿔서 문자열 B를 얻을 수 있습니다. 문자의 순서는 유지되어야 합니다. 문자열 A의 모든 문자와 문자열 B의 모든 문자에 대해 일대일 매핑이 있어야 합니다.

* 'paper' 및 'title'은 true를 반환합니다.
* `egg` 및 `sad`는 false를 반환합니다.
* `dgg` 및 `add`는 true를 반환합니다.

```js
isIsomorphic("egg", 'add'); // true
isIsomorphic("paper", 'title'); // true
isIsomorphic("kick", 'side'); // false

function isIsomorphic(firstString, secondString) {

  // Check if the same lenght. If not, they cannot be isomorphic
  if (firstString.length !== secondString.length) return false

  var letterMap = {};

  for (var i = 0; i < firstString.length; i++) {
    var letterA = firstString[i],
        letterB = secondString[i];

    // If the letter does not exist, create a map and map it to the value
    // of the second letter
    if (letterMap[letterA] === undefined) {
      letterMap[letterA] = letterB;
    } else if (letterMap[letterA] !== letterB) {
      // Eles if letterA already exists in the map, but it does not map to
      // letterB, that means that A is mapping to more than one letter.
      return false;
    }
  }
  // If after iterating through and conditions are satisfied, return true.
  // They are isomorphic
  return true;
}
```

###### Source

* https://github.com/kennymkchan/interview-questions-in-javascript

[[↑] 맨 위로](#JavaScript)
### Revealing Module Pattern 디자인 패턴 설명

**module pattern**의 변형을 **Revealing Module Pattern**이라고 합니다. 목적은 캡슐화를 유지하고 개체 리터럴에서 반환된 특정 변수와 메서드를 표시하는 것입니다. 직접 구현은 다음과 같습니다.

```js
var Exposer = (function() {
  var privateVariable = 10;

  var privateMethod = function() {
    console.log('Inside a private method!');
    privateVariable++;
  }

  var methodToExpose = function() {
    console.log('This is a method I want to expose!');
  }

  var otherMethodIWantToExpose = function() {
    privateMethod();
  }

  return {
      first: methodToExpose,
      second: otherMethodIWantToExpose
  };
})();

Exposer.first();        // Output: This is a method I want to expose!
Exposer.second();       // Output: Inside a private method!
Exposer.methodToExpose; // undefined
```
An obvious disadvantage of it is unable to reference the private methods

###### Source

* https://scotch.io/bar-talk/4-javascript-design-patterns-you-should-know

[[↑] 맨 위로](#JavaScript)
