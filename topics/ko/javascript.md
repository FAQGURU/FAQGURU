## JavaScript
 
  [Что такое приведение в JavaScript?](#что-такое-приведение-в-javascript)
 
  [Что такое оператор typeof?](#что-такое-оператор-typeof)
 
  [Что такое тип объекта?](#что-такое-тип-объекта)
 
  [Что такое массивы в JavaScript](#что-такое-массивы-в-javascript)
   
  [Что такое равенство в JavaScript](#что-такое-равенство-в-javascript)

  [Что такое область видимости в JavaScript?](#что-такое-область-видимости-в-javascript)

  [Что означает ключевое слово let в JavaScript?](#что-означает-ключевое-слово-let-в-javascript)

  [Что такое функция обратного вызова, и приведите простой пример.](#что-такое-функция-обратного-вызова-и-приведите-простой-пример)
  
  [Что такое строгий режим?](#что-такое-строгий-режим)

  [Что делает "use strict"?](#что-делает-use-strict)

  [Что такое полифилл?](#что-такое-полифилл)

  [Как бы вы проверили, является ли число целым?](#как-бы-вы-проверили-является-ли-число-целым)
  
  [Объясните значения и типы в JavaScript](#объясните-значения-и-типы-в-javascript)

  [Несортированный массив содержит (n - 1) из n последовательных чисел (где определены границы), найдите недостающее число за O (n) раз](#несортированный-массив-содержит-(n---1)-из-n-последовательных-чисел-(где-определены-границы)-найдите-недостающее-число-за-O-(n)-раз)

  [Удалите дубликаты в массиве и верните массив только уникальных элементов](#удалите-дубликаты-в-массиве-и-верните-массив-только-уникальных-элементов)

  [Верните строку, перевернув каждое слово в предложении](#верните-строку-перевернув-каждое-слово-в-предложении)

  [Напишите функцию, которая позволит вам сделать это](#напишите-функцию-которая-позволит-вам-сделать-это)

  [Реализуйте enqueue и dequeue, используя только два стека](#реализуйте-enqueue-и-dequeue-используя-только-два-стека)

  
  ### Что такое приведение в JavaScript?
 
  В JavaScript преобразование между двумя разными встроенными типами называется `приведение`.  Приведение в JavaScript бывает двух типов: *явное* и *неявное*.
 
  Вот пример явного приведения:
 ```js
 var a = "42";
 
 var b = Number( a );
 
 a;				// "42"
 b;				// 42 -- число!
 ```
 А вот пример неявного приведения:
 ```js
 var a = "42";
 
 var b = a * 1;	// "42" неявно приведено к 42
 
 a;				// "42"
 b;				// 42 -- число!
 ``` 
 
  
  
  [[↑] Вернуться к началу](#JavaScript)
 ### Что такое оператор typeof?
 
  JavaScript предоставляет оператор `typeof` который может проверить значение и сказать, какой это тип:
 ```js
 var a;
 typeof a;				// "undefined"
 
 a = "hello world";
 typeof a;				// "string"
 
 a = 42;
 typeof a;				// "number"
 
 a = true;
 typeof a;				// "boolean"
 
 a = null;
 typeof a;				// "object" -- странно, ошибка
 
 a = undefined;
 typeof a;				// "undefined"
 
 a = { b: "c" };
 typeof a;				// "object"
 ```
 
  
  
  
  [[↑] Вернуться к началу](#JavaScript)
 ### Что такое тип объекта?
 
  Тип объекта относится к составному значению, где вы можете установить свойства (именованные местоположения), каждое из которых содержит свои собственные значения любого типа. 
 
  ```js
 var obj = {
 	a: "hello world", // свойство
 	b: 42,
 	c: true
 };
 
 obj.a;		// "hello world", обращение через нотацию с точкой
 obj.b;		// 42
 obj.c;		// true
 
 obj["a"];	// "hello world", обращение через нотацию со скобками
 obj["b"];	// 42
 obj["c"];	// true
 ```
 Обращение через нотацию со скобками также полезно, если вы хотите получить доступ к свойству / ключу, но имя хранится в другой переменной, например как:
 ```js
 var obj = {
 	a: "hello world",
 	b: 42
 };
 
 var b = "a";
 
 obj[b];			// "hello world"
 obj["b"];		// 42
 ```
 
  
  
  [[↑] Вернуться к началу](#JavaScript)
 ### Что такое массивы в JavaScript
 
  `Массив` - это объект, который содержит значения (любого типа) не в именованных свойствах / ключах, а в числовых индексированных позициях:
 
  ```js
 var arr = [
 	"hello world",
 	42,
 	true
 ];
 
 arr[0];			// "hello world"
 arr[1];			// 42
 arr[2];			// true
 arr.length;		// 3
 
 typeof arr;		// "object"
 ```
 
  
  
  
  [[↑] Вернуться к началу](#JavaScript)
  ### Что такое равенство в JavaScript

JavaScript имеет как строгие сравнения, так и сравнения типов: 
* **Строгое сравнение (===)** проверяет равенство значений, не применяя *принуждение*
* **Абстрактное сравнение (==)** проверяет равенство значений применяя *принуждение*

```js
var a = "42";
var b = 42;

a == b;			// true
a === b;		// false
```
Некоторые простые равенства:
* Eсли какое-либо значение в сравнении может иметь значение `true` или `false`, избегайте `==` и используйте `===`.
* Если какое-либо значение в сравнении может иметь эти конкретные значения (`0`, `""`, или `[]` -- пустой массив), избегайте `==` и используйте `===`.
* Во всех остальных случаях вы можете безопасно использовать `==`. Это не только безопасно, но и во многих случаях упрощает ваш код с точки зрения читаемости.



[[↑] Вернуться к началу](#JavaScript)
### Что такое область видимости в JavaScript?

В JavaScript каждая функция получает свою собственную *область видимости*. Область видимости - это в основном набор переменных, а также правила доступа к этим переменным по имени. Только код внутри этой функции может получить доступ к переменным области видимости этой функции.

Имя переменной должно быть уникальным в той же области видимости. Область видимости может быть вложена в другую область. Если одна область вложена в другую, код внутри самой внутренней области может получить доступ к переменным из любой внешней области видимости.



[[↑] Вернуться к началу](#JavaScript)
### Что означает ключевое слово let в JavaScript?

В дополнение к созданию объявлений для переменных на уровне функций, ES6 позволяет объявлять переменные, принадлежащие отдельным блокам (парам { .. }), используя ключевое слово `let`. 

###### Источник

* https://github.com/getify/You-Dont-Know-JS/blob/master/up%20%26%20going/ch2.md

[[↑] Вернуться к началу](#JavaScript)
### Что такое функция обратного вызова, и приведите простой пример.

`callback` является функцией, которая передается другой функции в качестве аргумента и выполняется после завершения какой-либо операции. Ниже приведен пример простой функции обратного вызова, которая регистрируется в консоли *после* завершения некоторых операций.

```js
function modifyArray(arr, callback) {
  // делаем что-то с массивом
  arr.push(100);
  // затем выполнияем функцию обратного вызова, которая была передана
  callback();
}

var arr = [1, 2, 3, 4, 5];

modifyArray(arr, function() {
  console.log("массив был изменен", arr);
});
```

###### Источник

* https://coderbyte.com/algorithm/10-common-javascript-interview-questions

[[↑] Вернуться к началу](#JavaScript)
### Что такое строгий режим?

*Строгий режим* - это новая функция в ECMAScript 5, которая позволяет вам помещать программу или функцию в «строгий» рабочий контекст. Этот строгий контекст предотвращает выполнение определенных действий и вызывает больше исключений.

```js
// Нестрогий код...

(function(){
  "use strict";

  // Определяет вашу библиотеку строго...
})();

// Нестрогий код...
```



[[↑] Вернуться к началу](#JavaScript)
### Что делает "use strict"?

Литерал `use strict` вводится вверху программы JavaScript или вверху функции, и он помогает вам писать более безопасный код JavaScript, выдавая ошибку, если глобальная переменная создана по ошибке. Например, следующая программа выдаст ошибку:

```js
function doSomething(val) {
  "use strict"; 
  x = val + 10;
}`
```

Он выдаст ошибку, потому что `x` не был определен, и ему присваивается какое-то значение в глобальной области видимости, что недопустимо для `use strict`. Небольшое изменение, приведенное ниже, исправляет выдаваемую ошибку:

```js
function doSomething(val) {
  "use strict"; 
  var x = val + 10;
}
```

###### Источник

* https://coderbyte.com/algorithm/10-common-javascript-interview-questions

[[↑] Вернуться к началу](#JavaScript)
### Что такое полифилл?

По сути, полифилл - это конкретный код (или плагин), который позволит вам иметь некоторые специфические функциональные возможности, которые, как вы ожидаете, будут работать в разных нынешних или «современных» браузерах, которые не имеют встроенной поддержки этой функциональности.
* Полифиллы не являются частью стандарта HTML5
* Polyfilling не ограничивается Javascript

###### Источник

* http://www.programmerinterview.com/index.php/html5/html5-polyfill/

[[↑] Вернуться к началу](#JavaScript)
### Как бы вы проверили, является ли число целым?

Очень простой способ проверить, является ли число десятичным или целым, состоит в том, чтобы увидеть, остался ли остаток при делении на 1.

```js
function isInt(num) {
  return num % 1 === 0;
}

console.log(isInt(4)); // true
console.log(isInt(12.2)); // false
console.log(isInt(0.3)); // false
```

###### Источник

* https://coderbyte.com/algorithm/10-common-javascript-interview-questions

[[↑] Вернуться к началу](#JavaScript)  
### Объясните значения и типы в JavaScript

JavaScript имеет типизированные значения, а не типизированные переменные. Доступны следующие встроенные типы:
* `string`
* `number`
* `boolean`
* `null` и `undefined`
* `object`
* `symbol` (новое в ES6)



[[↑] Вернуться к началу](#JavaScript)
### Несортированный массив содержит (n - 1) из n последовательных чисел (где определены границы), найдите недостающее число за O (n) раз

```js
// Вывод функции должен быть 8
var arrayOfIntegers = [2, 5, 1, 4, 9, 6, 3, 7];
var upperBound = 9;
var lowerBound = 1;

findMissingNumber(arrayOfIntegers, upperBound, lowerBound); // 8

function findMissingNumber(arrayOfIntegers, upperBound, lowerBound) {
  // Выполните итерацию по массиву, чтобы найти сумму чисел
  var sumOfIntegers = 0;
  for (var i = 0; i < arrayOfIntegers.length; i++) {
    sumOfIntegers += arrayOfIntegers[i];
  }

  // Найдите теоретическую сумму последовательных чисел, используя вариацию суммы Гаусса.
  // формула: [(N * (N + 1)) / 2] - [(M * (M - 1)) / 2];
  // N - верхняя граница, а M - нижняя граница

  upperLimitSum = (upperBound * (upperBound + 1)) / 2;
  lowerLimitSum = (lowerBound * (lowerBound - 1)) / 2;

  theoreticalSum = upperLimitSum - lowerLimitSum;

  return theoreticalSum - sumOfIntegers;
}
```

###### Источник

* https://github.com/kennymkchan/interview-questions-in-javascript

[[↑] Вернуться к началу](#JavaScript)
### Удалите дубликаты в массиве и верните массив только уникальных элементов

```js
// ES6 реализация
var array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];

Array.from(new Set(array)); // [1, 2, 3, 5, 9, 8]

// ES5 реализация
var array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];

uniqueArray(array); // [1, 2, 3, 5, 9, 8]

function uniqueArray(array) {
  var hashmap = {};
  var unique = [];

  for(var i = 0; i < array.length; i++) {
    // Если ключ возвращает undefined (уникальный), он оценивается как ложный.
    if(!hashmap.hasOwnProperty(array[i])) {
      hashmap[array[i]] = 1;
      unique.push(array[i]);
    }
  }

  return unique;
}
```

###### Источник

* https://github.com/kennymkchan/interview-questions-in-javascript

[[↑] Вернуться к началу](#JavaScript)
### Верните строку, перевернув каждое слово в предложении

```js
var string = "Welcome to this Javascript Guide!";

// Должно вернуть !ediuG tpircsavaJ siht ot emocleW
var reverseEntireSentence = reverseBySeparator(string, "");

// Возвращает emocleW ot siht tpircsavaJ !ediuG
var reverseEachWord = reverseBySeparator(reverseEntireSentence, " ");

function reverseBySeparator(string, separator) {
  return string.split(separator).reverse().join(separator);
}
```

###### Источник

* https://github.com/kennymkchan/interview-questions-in-javascript

[[↑] Вернуться к началу](#JavaScript)
### Напишите функцию, которая позволит вам сделать это

Вы можете создать замыкание, чтобы сохранить значение, переданное функции `createBase`, даже после того, как внутренняя функция возвращена. Возвращаемая внутренняя функция создается внутри внешней функции, делая ее закрытой, и она имеет доступ к переменным внутри внешней функции, в данном случае к переменной `baseNumber`.

```js
function createBase(baseNumber) {
  return function(N) {
    // мы ссылаемся на baseNumber здесь, даже если он был объявлен
    // вне этой функции. Замыкания позволяют нам делать это в JavaScript
    return baseNumber + N;
  }
}

var addSix = createBase(6);
addSix(10);
addSix(21);
```

###### Источник

* https://coderbyte.com/algorithm/3-common-javascript-closure-questions

[[↑] Вернуться к началу](#JavaScript)
### Реализуйте enqueue и dequeue, используя только два стека

*Enqueue* означает добавить элемент(поставить в очередь), *dequeue*, означает удалить элемент( убрать из очереди).

```js
var inputStack = []; // Первый стек
var outputStack = []; // Второй стек

// Для постановки в очередь просто поместите предмет в первый стек
function enqueue(stackInput, item) {
  return stackInput.push(item);
}

function dequeue(stackInput, stackOutput) {
  // Обратный стек, так что первый элемент выходного стека является
  // последний элемент входного стека. После этого откройте верхнюю часть вывода и
  // получите первый элемент, который когда-либо был помещен в стек ввода
  if (stackOutput.length <= 0) {
    while(stackInput.length > 0) {
      var elementToOutput = stackInput.pop();
      stackOutput.push(elementToOutput);
    }
  }

  return stackOutput.pop();
}
```

###### Источник

* https://github.com/kennymkchan/interview-questions-in-javascript

[[↑] Вернуться к началу](#JavaScript)
