## Ruby

[개체 모델에서 가장 높은 수준은 무엇입니까?](#개체-모델에서-가장-높은-수준은-무엇입니까)

["커널" 모듈이 포함된 핵심 개체는 무엇입니까?](#커널-모듈이-포함된-핵심-개체는-무엇입니까)

[대문자로 시작하는 식별자에 대해 무엇을 말할 수 있습니까?](#대문자로-시작하는-식별자에-대해-무엇을-말할-수-있습니까)

[Ruby가 유연성의 언어로 알려진 이유는 무엇입니까?](#Ruby가-유연성의-언어로-알려진-이유는-무엇입니까)

[개체란 무엇입니까?](#개체란-무엇입니까)

[class란 무엇입니까?](#class란-무엇입니까)

[루비젬이란?](#루비젬이란)

[Ruby에 "continue"와 동일한 기능이 있습니까?](#Ruby에-continue와-동일한-기능이-있습니까)

[Ruby의 모든 것이 객체입니까?](#Ruby의-모든-것이-객체입니까)

[Ruby의 redo 문 설명](#Ruby의-redo-문-설명)

[기호가 일반적으로 문자열 대신 해시 키로 사용되는 이유는 무엇입니까?](#기호가-일반적으로-문자열-대신-해시-키로-사용되는-이유는-무엇입니까)

[해시의 기본값을 어떻게 지정할 수 있습니까?](#해시의-기본값을-어떻게-지정할-수-있습니까)

[Ruby에서 nil과 false의 차이점은 무엇입니까?](#Ruby에서-nil과-false의-차이점은-무엇입니까)

[해시 값을 쿼리할 때 `Hash#[]` 대신 `Hash#fetch`를 사용하는 이유는 무엇입니까?](#해시-값을-쿼리할-때-Hash-대신-Hashfetch를-사용하는-이유는-무엇입니까)

[Ruby와 Python의 몇 가지 차이점 설명](#Ruby와-Python의-몇-가지-차이점-설명)

[splat 연산자의 두 가지 용도는 무엇입니까?](#splat-연산자의-두-가지-용도는-무엇입니까)

[인스턴스 변수와 클래스 변수의 차이점은 무엇입니까?](#인스턴스-변수와-클래스-변수의-차이점은-무엇입니까)

[반환 값은 무엇입니까 ...](#반환-값은-무엇입니까-)

[`#==`와 `#===`의 차이점은 무엇인가요?](#와-의-차이점은-무엇인가요)

[루비를 사용하여 배열에서 'nil' 값을 어떻게 제거합니까?](#루비를-사용하여-배열에서-nil-값을-어떻게-제거합니까)

[Ruby 클래스 외부에서 해당 객체를 사용하여 private 메소드를 호출할 수 있습니까?](#Ruby-클래스-외부에서-해당-객체를-사용하여-private-메소드를-호출할-수-있습니까)

[...의 가치는 무엇입니까?](#의-가치는-무엇입니까)

[다음 연산자 각각과 언제 어떻게 사용해야 하는지 설명하십시오.](#다음-연산자-각각과-언제-어떻게-사용해야-하는지-설명하십시오)

[해시의 키를 문자열로 키의 길이로 정렬하는 함수를 작성하십시오.](#해시의-키를-문자열로-키의-길이로-정렬하는-함수를-작성하십시오)

[아래 나열된 표현식 중 "거짓"이 되는 것은 무엇입니까?](#아래-나열된-표현식-중-거짓이-되는-것은-무엇입니까)

[왜 `for/in` 대신 `#each`를 사용할까요?](#왜-forin-대신-each를-사용할까요)

[루비에서 메소드를 호출하는 세 가지 방법이 있습니다. 최소 두 개 주실 수 있나요?](#루비에서-메소드를-호출하는-세-가지-방법이-있습니다-최소-두-개-주실-수-있나요)

[모듈이란 무엇입니까? 클래스와 모듈의 차이점을 말씀해 주시겠습니까?](#모듈이란-무엇입니까-클래스와-모듈의-차이점을-말씀해-주시겠습니까)

[DSL이란 무엇이며 Ruby와 어떤 관련이 있습니까?](#DSL이란-무엇이며-Ruby와-어떤-관련이-있습니까)

[duck typing이란 무엇이며 Ruby와 어떤 관련이 있습니까?](#duck-typing이란-무엇이며-Ruby와-어떤-관련이-있습니까)

[Ruby는 정적으로 유형이 지정되는 언어입니까 아니면 동적으로 유형이 지정되는 언어입니까?](#Ruby는-정적으로-유형이-지정되는-언어입니까-아니면-동적으로-유형이-지정되는-언어입니까)

[인스턴스 메서드는 공개 방식입니까, 비공개 방식입니까?](#인스턴스-메서드는-공개-방식입니까-비공개-방식입니까)

[Ruby 메서드 명명 규칙의 맥락에서 술어는 무엇입니까?](#Ruby-메서드-명명-규칙의-맥락에서-술어는-무엇입니까)

[Ruby는 강력한 유형의 언어입니까 아니면 약한 유형의 언어입니까?](#Ruby는-강력한-유형의-언어입니까-아니면-약한-유형의-언어입니까)

[Ruby의 배열에 값이 있는지 확인](#Ruby의-배열에-값이-있는지-확인)

[private 와 protected methods의 차이점은 무엇입니까?](#private-와-protected-methods의-차이점은-무엇입니까)

[클래스 변수는 상속됩니까?](#클래스-변수는-상속됩니까)

[클래스 변수와 클래스 인스턴스 변수의 차이점은 무엇입니까?](#클래스-변수와-클래스-인스턴스-변수의-차이점은-무엇입니까)

[대상을 강요한다는 것은 무엇을 의미합니까? 그리고 왜 하는겁니까?](#대상을-강요한다는-것은-무엇을-의미합니까-그리고-왜-하는겁니까)

[아래 코드가 실행된 후 val1과 val2는 어떻게 됩니까? 당신의 대답을 설명하십시오.](#아래-코드가-실행된-후-val1과-val2는-어떻게-됩니까-당신의-대답을-설명하십시오)

[redo vs retry 사용법 설명](#redo-vs-retry-사용법-설명)

[루프 내에서 문자열 리터럴을 사용하지 않으려는 이유는 무엇입니까?](#루프-내에서-문자열-리터럴을-사용하지-않으려는-이유는-무엇입니까)

[Proc 호출과 람다 호출의 차이점은 무엇입니까?](#Proc-호출과-람다-호출의-차이점은-무엇입니까)

[프로시저와 람다의 주요 차이점은 무엇입니까?](#프로시저와-람다의-주요-차이점은-무엇입니까)

[문자열이 변경 가능하더라도 문자열을 해시 키로 안전하게 사용할 수 있는 이유는 무엇입니까?](#문자열이-변경-가능하더라도-문자열을-해시-키로-안전하게-사용할-수-있는-이유는-무엇입니까)

[범위의 두 가지 용도는 무엇입니까?](#범위의-두-가지-용도는-무엇입니까)

[`Module#remove_method`와 `Module#undef_method`의 차이점은 무엇입니까?](#Moduleremovemethod와-Moduleundefmethod의-차이점은-무엇입니까)

['Comparable' 모듈을 구현하려면 어떤 연산자를 정의해야 하나요?](#Comparable-모듈을-구현하려면-어떤-연산자를-정의해야-하나요)

[`Kernel#require`와 `Kernel#load`의 차이점은 무엇입니까?](#Kernel#require와-Kernel#load의-차이점은-무엇입니까)

[private 메소드의 호출은 정의 클래스 내에서 public 메소드의 호출과 어떻게 다릅니까?](#private-메소드의-호출은-정의-클래스-내에서-public-메소드의-호출과-어떻게-다릅니까)

[메서드에 별칭을 지정하려는 이유는 무엇입니까?](#메서드에-별칭을-지정하려는-이유는-무엇입니까)

[...의 가치는 무엇일까?](#의-가치는-무엇일까)

[메소드 끝의 쾅 '!'은 무엇을 의미합니까?](#메소드-끝의-쾅-은-무엇을-의미합니까)

[아래 코드에서 "upcased" 변수의 값은 무엇입니까?](#아래-코드에서-upcased-변수의-값은-무엇입니까)

[블록 호출은 메서드 호출과 어떻게 다릅니까?](#블록-호출은-메서드-호출과-어떻게-다릅니까)

[클래스와 모듈에 대한 세 가지 수준의 메서드 액세스 제어를 알려주실 수 있습니까? 그들은 방법에 대해 무엇을 의미합니까?](#클래스와-모듈에-대한-세-가지-수준의-메서드-액세스-제어를-알려주실-수-있습니까-그들은-방법에-대해-무엇을-의미합니까)

[`#==`와 `#equal?`의 차이점은 무엇인가요?](#와-equal의-차이점은-무엇인가요)

[이 루비 관용구를 설명하라: a | = b](#이-루비-관용구를-설명하라-a---b)

[self은 무슨 뜻인가요?](#self은-무슨-뜻인가요)

[Proc란?](#Proc란)

[`#==`와 `#eql?`의 차이점은 무엇인가요?](#와-eql의-차이점은-무엇인가요)

[Ruby에서 closure 설명](#Ruby에서-closure-설명)

[`Array#map`과 `Array#each`의 차이점은 무엇인가요?](#Array#map과-Array#each의-차이점은-무엇인가요)

[반복자 란 무엇입니까?](#반복자-란-무엇입니까)

[`throw/catch` and `raise/rescue`의 차이점은 무엇입니까?](#throwcatch-and-raiserescue의-차이점은-무엇입니까)

[반복되는 'elsif' 문에 비해 case 문의 단점은 무엇입니까?](#반복되는-elsif-문에-비해-case-문의-단점은-무엇입니까)

["super"를 호출하는 것과 "super()"를 호출하는 것의 차이점은 무엇입니까?](#super를-호출하는-것과-super를-호출하는-것의-차이점은-무엇입니까)

[블록에 중괄호 구문을 사용하는 것과 비교하여 언제 `do`/`end` 구문을 사용할 수 있습니까?](#블록에-중괄호-구문을-사용하는-것과-비교하여-언제-doend-구문을-사용할-수-있습니까)

[차이점을 설명하시오](#차이점을-설명하시오)

[블록에 두 개의 인수가 전달되었지만 하나의 인수만 허용하면 어떻게 됩니까?](#블록에-두-개의-인수가-전달되었지만-하나의-인수만-허용하면-어떻게-됩니까)

[정확히 어떻게 작동합니까?](#정확히-어떻게-작동합니까)

[아래 코드 줄이 유효한 Ruby 코드입니까? 그렇다면 어떤 역할을 합니까?](#아래-코드-줄이-유효한-Ruby-코드입니까-그렇다면-어떤-역할을-합니까)

[다음 각 코드 줄의 결과는 무엇입니까?](#다음-각-코드-줄의-결과는-무엇입니까)

[할당되지 않은 상수는 어떻게 됩니까?](#할당되지-않은-상수는-어떻게-됩니까)

[블록이 객체입니까?](#블록이-객체입니까)

[이 두 코드 조각의 주요 차이점은 무엇입니까?](#이-두-코드-조각의-주요-차이점은-무엇입니까)

[임의의 길이의 피보나치 수열을 배열로 출력하는 Ruby 코드 한 줄을 작성하십시오.](#임의의-길이의-피보나치-수열을-배열로-출력하는-Ruby-코드-한-줄을-작성하십시오)

[Ruby가 메소드 오버로딩을 지원하지 않는 이유는 무엇입니까?](#Ruby가-메소드-오버로딩을-지원하지-않는-이유는-무엇입니까)

[메소드는 객체인가?](#메소드는-객체인가)

[`BasicObject#instance_eval`과 `BasicObject#instance_exec`의 차이점은 무엇인가요?](#BasicObjectinstanceeval과-BasicObjectinstanceexec의-차이점은-무엇인가요)

[`Object#dup`과 `#clone`의 차이점은 무엇입니까?](#Objectdup과-clone의-차이점은-무엇입니까)

[고유 클래스 란 무엇입니까?](#고유-클래스-란-무엇입니까)

[언제 `LocalJumpError`가 발생합니까?](#언제-LocalJumpError가-발생합니까)

[루비에서 '확장'과 '포함'의 차이점은 무엇입니까?](#루비에서-확장과-포함의-차이점은-무엇입니까)



### 개체 모델에서 가장 높은 수준은 무엇입니까?

`BasicObject`

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### "커널" 모듈이 포함된 핵심 개체는 무엇입니까?

`Object`

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 대문자로 시작하는 식별자에 대해 무엇을 말할 수 있습니까?

상수입니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### Ruby가 유연성의 언어로 알려진 이유는 무엇입니까?

Ruby는 작성자가 프로그래밍 요소를 쉽게 변경할 수 있도록 하기 때문에 유연성의 언어로 알려져 있습니다. 언어의 특정 부분을 제거하거나 재정의할 수 있습니다. Ruby는 사용자를 제한하지 않습니다. 예를 들어, 두 개의 숫자를 더하기 위해 Ruby는 `+` 기호 또는 단어 `더하기`를 사용할 수 있습니다. 이 변경은 Ruby의 내장 클래스 Numeric을 사용하여 수행할 수 있습니다.

###### Source

* https://www.javatpoint.com/ruby-interview-questions

[[↑] 맨 위로](#Ruby)
### 개체란 무엇입니까?

클래스의 인스턴스입니다. 누군가에게는 루비(Object)의 루트 클래스이기도 합니다. 클래스 자체는 Object 루트 클래스의 자손입니다.

###### Source

* https://stackoverflow.com/questions/4010039/equivalent-of-continue-in-ruby

[[↑] 맨 위로](#Ruby)
### class란 무엇입니까?

클래스에는 **데이터**가 있고 해당 데이터와 상호 작용하는 **메서드**가 있으며 **객체를 인스턴스화**하는 데 사용됩니다.

```ruby
class WhatAreClasses
  def initialize
    @data = "I'm instance data of this object. Hello."
  end

  def method
    puts @data.gsub("instance", "altered")
  end
end

object = WhatAreClasses.new
object.method
 #=> I'm altered data of this object. Hello.
```

###### Source

* https://stackoverflow.com/questions/4010039/equivalent-of-continue-in-ruby

[[↑] 맨 위로](#Ruby)
### 루비젬이란?

**rubygems**는 루비 라이브러리(예: gem)용 패키지 관리자 소프트웨어입니다. 패키지 관리자에는 기본 CRUD 작업, 종속성 트리가 있으며 여러 gem 서버 간의 비동기 통신을 지원합니다.

###### Source

* https://stackoverflow.com/questions/4010039/equivalent-of-continue-in-ruby

[[↑] 맨 위로](#Ruby)
### Ruby에 "continue"와 동일한 기능이 있습니까?

네, 그것은 'next'이라고 불립니다.

```js
for i in 0..5
   if i < 2
     next
   end
   puts "Value of local variable is #{i}"
end
```

###### Source

* https://stackoverflow.com/questions/4010039/equivalent-of-continue-in-ruby

[[↑] 맨 위로](#Ruby)
### Ruby의 모든 것이 객체입니까? 

메소드는 객체가 아닙니다. 블록은 객체가 아닙니다. 키워드는 객체가 아닙니다. 그러나 Method 객체와 Proc 객체가 존재하며 일부 키워드는 객체를 참조합니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### Ruby의 redo 문 설명

Ruby `redo` 문은 루프의 현재 반복을 반복하는 데 사용됩니다. redo 문은 루프의 상태를 평가하지 않고 실행됩니다.

###### Source

* https://www.javatpoint.com/ruby-interview-questions

[[↑] 맨 위로](#Ruby)
### 기호가 일반적으로 문자열 대신 해시 키로 사용되는 이유는 무엇입니까?

문자열은 *변경 가능*하지만 기호는 *불변*입니다. Ruby는 해시 키로 사용될 때 내부적으로 문자열의 변경할 수 없는 복사본을 만들지만 두 개의 기호를 비교하는 것이 두 개의 `String` 객체를 비교하는 것보다 빠릅니다. 이것은 또한 협약입니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 해시의 기본값을 어떻게 지정할 수 있습니까?

초기화 시 기본값을 `::new`에 인수로 전달하거나 `Hash#default` 메소드를 사용하여 기본값을 직접 변경합니다. 또한 'Hash#fetch'를 사용하여 쿼리 시 기본값을 제공할 수도 있습니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### Ruby에서 nil과 false의 차이점은 무엇입니까?

**nil**:
* nil은 값이 될 수 없습니다.
* 술어가 없는 경우 nil이 반환됩니다.
* nil은 부울 데이터 유형이 아닙니다.
* nil은 nilclass의 객체입니다.

**false**:
* false는 값이 될 수 있습니다.
* 술어의 경우 메소드에서 true 또는 false를 반환합니다.
* false는 부울 데이터 유형입니다.
* false는 falseclass의 객체입니다.


###### Source

* https://www.javatpoint.com/ruby-interview-questions

[[↑] 맨 위로](#Ruby)
### 해시 값을 쿼리할 때 `Hash#[]` 대신 `Hash#fetch`를 사용하는 이유는 무엇입니까?

'Hash#fetch'는 해시에 키가 없는 경우를 처리하는 옵션을 제공합니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### Ruby와 Python의 몇 가지 차이점 설명

유사점:

* 고급 언어
* 여러 플랫폼 지원
* irb라는 대화형 프롬프트 사용
* 서버 측 스크립팅 언어

차이점:

* Ruby는 완전히 객체 지향적인 반면 Python은 그렇지 않습니다.
* Ruby는 EclipseIDE를 지원하지만 Python은 여러 IDE를 지원합니다.
* Ruby는 Mixins를 사용하지만 Python은 사용하지 않습니다.
* Ruby는 블록, 프로시저 및 람다를 지원하지만 Python은 지원하지 않습니다.

###### Source

* https://www.javatpoint.com/ruby-interview-questions

[[↑] 맨 위로](#Ruby)
### splat 연산자의 두 가지 용도는 무엇입니까?

* 배열의 요소를 분해하거나 확장합니다.
* 매개변수 목록의 인수를 배열로 수집합니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 인스턴스 변수와 클래스 변수의 차이점은 무엇입니까?

클래스 변수는 둘러싸는 클래스 정의에 의해 생성된 클래스 객체를 참조하여 평가되는 반면 인스턴스 변수는 'self'를 참조하여 평가됩니다. 인스턴스 변수는 인스턴스 메소드 외부에서 참조할 수 없습니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 반환 값은 무엇입니까 ...

개체를 통한 xyz 메서드 호출에 대한 모든 명령문이 유효합니다.

'IRB'를 통해 실행할 때:

```ruby
irb(main):001:0> ABC::new::xyz
xyz in ABC
=> nil
irb(main):002:0> ABC::new.xyz
xyz in ABC
=> nil
irb(main):003:0> ABC.new::xyz
xyz in ABC
=> nil
irb(main):004:0> ABC.new.xyz
xyz in ABC
=> nil
```

###### Source

* https://www.toptal.com/ruby/interview-questions

[[↑] 맨 위로](#Ruby)
### `#==`와 `#===`의 차이점은 무엇인가요?

`#==`는 일반 비교를 수행하는 반면 `#===`는 대소문자 동일성 비교를 수행하며 case 문에서 의미 있는 의미를 제공하는 데 유용합니다.


###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 루비를 사용하여 배열에서 'nil' 값을 어떻게 제거합니까?

`Array#compact`는 `nil` 값을 제거합니다.

```ruby
>> [nil,123,nil,"test"].compact
=> [123, "test"]
```

###### Source

* https://www.toptal.com/ruby/interview-questions

[[↑] 맨 위로](#Ruby)
### Ruby 클래스 외부에서 해당 객체를 사용하여 private 메소드를 호출할 수 있습니까?

예, `send` 메소드의 도움으로.

'Test' 클래스가 주어졌을 때:
```ruby
class Test
   private
       def method
         p "I am a private method"
      end
end
```
    
`send`를 사용하여 private 메소드를 실행할 수 있습니다:

```ruby
>> Test.new.send(:method)
"I am a private method"
```

###### Source

* https://www.toptal.com/ruby/interview-questions

[[↑] 맨 위로](#Ruby)
### ...의 가치는 무엇입니까?

* var1은 `nil`과 같습니다.
* var2는 `4`와 같습니다.

Ruby의 조건문은 조건이 '거짓'이면 'nil'을 반환하는 표현식입니다. Ruby 메소드는 메소드 본문의 마지막 표현식을 리턴합니다.

###### Source

* https://www.toptal.com/ruby/interview-questions

[[↑] 맨 위로](#Ruby)
### 다음 연산자 각각과 언제 어떻게 사용해야 하는지 설명하십시오.

* `==` – 두 피연산자의 _value_가 같은지 확인합니다(종종 동등성에 대한 클래스별 정의를 제공하기 위해 재정의됨).

* `===` – 특히 `case` 문의 `when` 절 내에서 동등성을 테스트하는 데 사용됩니다(또한 case 문에서 의미 있는 클래스별 의미를 제공하기 위해 종종 재정의됨).

* `eql?` – 두 피연산자의 _value_ 및 _type_이 동일한지 확인합니다(값을 비교하지만 유형을 무시하는 `==` 연산자와 반대). 예를 들어 '1 == 1.0'은 'true'로 평가되는 반면, '1.eql?(1.0)'은 'false'로 평가됩니다.

* `equal?` – 두 객체의 `identity`를 비교합니다. 즉, 두 피연산자의 객체 ID가 동일한 경우(즉, 둘 다 _같은 객체_를 참조하는 경우) 'true'를 반환합니다. 동일한 객체의 동일한 _복사본_ 두 개를 비교할 때 '거짓'을 반환합니다.


###### Source

* https://www.toptal.com/ruby/interview-questions

[[↑] 맨 위로](#Ruby)
### 해시의 키를 문자열로 키의 길이로 정렬하는 함수를 작성하십시오.

프로그래밍에서 항상 그렇듯이 실제로 이를 수행하는 방법은 여러 가지가 있습니다.
가장 간단한 대답은 다음과 같은 형식일 것입니다:
```ruby
hsh.keys.map(&:to_s).sort_by(&:length)
```    
or:
```ruby
hsh.keys.collect(&:to_s).sort_by { |key| key.length }
```

또는 Ruby의 [`Enumerable` mixin](http://ruby-doc.org/core-2.1.2/Enumerable.html)은 컬렉션에서 작동하는 다양한 방법을 제공합니다. 여기서 핵심은 해시 키를 컬렉션으로 변환하고 모두 문자열로 변환한 다음 배열을 정렬하는 것입니다.

```ruby
def key_sort hsh
   hsh.keys.collect(&:to_s).sort { |a, b| a.length <=> b.length }
end
```

[`collect` 메소드](http://www.tutorialspoint.com/ruby/ruby_iterators.htm)의 동등한 호출은 다음과 같은 일반적인 블록 구문으로 수행됩니다.

```ruby
collect { |x| x.to_s }
```

###### Source

* https://www.toptal.com/ruby/interview-questions

[[↑] 맨 위로](#Ruby)
### 아래 나열된 표현식 중 "거짓"이 되는 것은 무엇입니까?

Ruby에서 false로 평가되는 _only_ 값은 'false'와 'nil'입니다. _다른 모든 것_ - 영(0)과 빈 배열(\[\])도 true로 평가됩니다.

이것은 이전에 JavaScript와 같은 다른 언어로 작업한 프로그래머에게 정말 놀라운 일입니다.

###### Source

* https://www.toptal.com/ruby/interview-questions

[[↑] 맨 위로](#Ruby)
### 왜 `for/in` 대신 `#each`를 사용할까요?

"Ruby way"입니다. Ruby가 자연어 개념을 모방하는 메서드를 정의하는 방법의 예입니다. `#each`와 같은 반복자 메서드가 더 자연스럽게 읽힙니다. `#each`는 블록이므로 새로운 변수 범위를 정의합니다. 'for/in'은 '#each'가 언어의 보다 근본적인 측면임을 암시하는 '#each'의 존재에 따라 다릅니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 루비에서 메소드를 호출하는 세 가지 방법이 있습니다. 최소 두 개 주실 수 있나요?

**점 연산자**(또는 마침표 연산자), **Object#send** 메서드 또는 **method(:foo).call**을 찾고 있습니다.

```ruby
object = Object.new
puts object.object_id
 #=> 282660

puts object.send(:object_id)
 #=> 282660

puts object.method(:object_id).call # (Kudos to Ezra)
 #=> 282660
```

###### Source

* https://gist.github.com/ryansobol/5252653#file-gistfile1-md

[[↑] 맨 위로](#Ruby)
### 모듈이란 무엇입니까? 클래스와 모듈의 차이점을 말씀해 주시겠습니까?

모듈은 **네임스페이스**의 메커니즘 역할을 합니다.

```ruby
module ANamespace
  class AClass
    def initialize
      puts "Another object, coming right up!"
    end
  end
end

ANamespace::AClass.new
 #=> Another object, coming right up!
```

또한 모듈은 **믹스인**을 통해 다중 상속을 위한 메커니즘을 제공하며 클래스처럼 **인스턴스화할 수 없습니다**.

```ruby
module AMixIn
  def who_am_i?
    puts "An existentialist, that's who."
  end
end

# String is already the parent class
class DeepString < String
  # extend adds instance methods from AMixIn as class methods
  extend AMixIn
end

DeepString.who_am_i?
 #=> An existentialist, that's who.

AMixIn.new
 #=> NoMethodError: undefined method ‘new’ for AMixIn:Module
```

###### Source

* https://gist.github.com/ryansobol/5252653#file-gistfile1-md

[[↑] 맨 위로](#Ruby)
### DSL이란 무엇이며 Ruby와 어떤 관련이 있습니까?

**Domain Specific Language**는 개발자가 다른 방법보다 더 자연스럽게 문제를 해결하거나 데이터를 표현할 수 있게 해주는 API입니다. Ruby 구문의 유연한 특성과 기존 메서드와 클래스를 별칭으로 지정하고 변경할 수 있는 기능은 풍부한 DSL을 만드는 데 도움이 됩니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### duck typing이란 무엇이며 Ruby와 어떤 관련이 있습니까?

개체가 예상된 개체처럼 보이고 동작하는 한 예상 유형이 아니더라도 해당 개체에 대해 작업을 수행할 수 있습니다. 이것은 매개변수의 유형 검사가 없기 때문에 효과적인 프로그래밍 기술이 되기 때문에 Ruby의 특징입니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### Ruby는 정적으로 유형이 지정되는 언어입니까 아니면 동적으로 유형이 지정되는 언어입니까?

런타임에 유형 검사가 수행되므로 동적으로 유형이 지정됩니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 인스턴스 메서드는 공개 방식입니까, 비공개 방식입니까?

기본적으로 공개되어 있습니다. `Module#private`, `Module#protected`를 사용하여 가시성을 변경하거나 `Module#public`을 사용하여 다시 되돌릴 수 있습니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### Ruby 메서드 명명 규칙의 맥락에서 술어는 무엇입니까?

메소드 호출 또는 메소드 이름에 의해 제기된 질문에 답하는 메소드. 술어는 일반적으로 부울을 반환합니다.

```js
$ irb
> 5.odd?
=> true

> 5.even?
=> false

> 5.between?(1, 10)
=> true

> 5.between?(11, 20)
=> false
```

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### Ruby는 강력한 유형의 언어입니까 아니면 약한 유형의 언어입니까?

개체에 대한 작업이 수행되기 전에 개체의 유형이 확인되므로 강력한 형식입니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### Ruby의 배열에 값이 있는지 확인

include을 찾고 계십니까?:
```js
>> ['Cat', 'Dog', 'Bird'].include? 'Dog'
=> true
```

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### private 와 protected methods의 차이점은 무엇입니까?

private 메소드는 정의하는 클래스 또는 서브클래스의 인스턴스 메소드에 의해서만 호출될 수 있으며 `self.my_method`와 같이 `self`에 대해 명시적으로가 아니라 기능적 스타일로 호출되어야 합니다. 보호된 메서드는 정의 클래스의 모든 인스턴스에 의해 명시적으로 호출될 수 있으며 'self'에 대한 암시적 호출로 제한되지 않습니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 클래스 변수는 상속됩니까?

아니요. 동작은 상속과 다릅니다. 하위 클래스에 의한 클래스 변수의 변경은 상위 클래스의 해당 클래스 변수와 상위 클래스의 다른 모든 하위 클래스에 영향을 줍니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 클래스 변수와 클래스 인스턴스 변수의 차이점은 무엇입니까?

클래스 인스턴스 변수는 클래스의 인스턴스 변수입니다. 클래스 인스턴스 변수는 인스턴스 메소드 내에서 사용할 수 없습니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 대상을 강요한다는 것은 무엇을 의미합니까? 그리고 왜 하는겁니까?

*객체를 강제 실행*한다는 것은 대상을 예상 유형으로 강제 실행한다는 의미입니다. 알 수 없는 개체 유형을 작업에 필요한 예상 유형 또는 형식으로 강제 적용하기 위해 이 작업을 수행할 수 있습니다. 이것은 *덕 타이핑*과 관련된 일반적인 관행입니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 아래 코드가 실행된 후 val1과 val2는 어떻게 됩니까? 당신의 대답을 설명하십시오.

이 두 명령문이 동일한 것처럼 보일 수 있지만 작업 순서로 인해 같지 않습니다. 구체적으로, `and` 및 `or` 연산자는 `=` 연산자보다 _낮은_ 우선순위를 갖는 반면, `&&` 및 `||` 연산자는 연산 순서에 따라 `=` 연산자보다 _높은_ 우선순위를 갖습니다.

이를 명확히 하기 위해 동일한 코드가 있지만 기본 작업 순서를 명확히 하기 위해 괄호를 사용합니다.

```ruby
(val1 = true) and false    # results in val1 being equal to true
val2 = (true && false)     # results in val2 being equal to false
```

부수적으로 이것은 의도를 명확하게 지정하기 위해 괄호를 사용하는 것이 모든 언어에서 일반적으로 좋은 습관인 이유를 보여주는 좋은 예입니다. 그러나 괄호를 사용하든 사용하지 않든 이러한 작업 순서 규칙을 인식하고 `and` / `or` 대 `&&` / `||`를 사용할 시기를 적절하게 결정하는 것이 중요합니다.

###### Source

* https://www.toptal.com/ruby/interview-questions

[[↑] 맨 위로](#Ruby)
### redo vs retry 사용법 설명

`redo`와 `retry`는 둘 다 루프의 일부를 재실행하는 데 사용됩니다. 그러나 다시 실행하는 정도는 다릅니다.
* `redo`는 현재 반복만 반복하는 반면
* `retry`는 전체 루프를 처음부터 반복합니다.

###### Source

* http://rubyquicktips.com/post/1122838559/redo-vs-retry

[[↑] 맨 위로](#Ruby)
### 루프 내에서 문자열 리터럴을 사용하지 않으려는 이유는 무엇입니까?

값이 동일한 경우에도 모든 문자열 리터럴에 대해 새 개체가 생성됩니다. 대신 변수나 기호를 사용하는 것이 좋습니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### Proc 호출과 람다 호출의 차이점은 무엇입니까?

블록은 람다 호출과 연결되어야 합니다. Lambda는 메서드 호출에 필요한 것과 같은 정확한 수의 인수로 호출해야 하는 반면 procs는 인수를 수신하는 데 더 유연합니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
###  프로시저와 람다의 주요 차이점은 무엇입니까?

람다를 호출하는 것은 프로시저가 하는 것처럼 어휘를 둘러싸는 메서드에서 반환하는 대신 람다의 return 문이 람다 자체에서 반환되는 메서드를 호출하는 것과 더 유사합니다. 이 개념에 추가하여 람다는 메서드 호출에 필요한 것과 같은 정확한 인수 수로 호출해야 하는 반면 프로시저는 인수를 수신하는 데 더 유연합니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 문자열이 변경 가능하더라도 문자열을 해시 키로 안전하게 사용할 수 있는 이유는 무엇입니까?

인터프리터는 해시 키로 사용되는 문자열의 개인 복사본을 만들기 때문입니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 범위의 두 가지 용도는 무엇입니까?

* comparison
* iteration

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### `Module#remove_method`와 `Module#undef_method`의 차이점은 무엇입니까?

`Module#undef_method`는 클래스의 인스턴스를 통한 메서드 호출을 방지하는 반면, `Module#remove_method`는 클래스에서 메서드 정의를 제거하지만 동일한 이름의 상속된 메서드가 호출되는 것을 방지하지는 않습니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 'Comparable' 모듈을 구현하려면 어떤 연산자를 정의해야 하나요?

`<=>`

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### `Kernel#require`와 `Kernel#load`의 차이점은 무엇입니까?

'Kernel#require'는 바이너리 확장을 로드할 수 있습니다. 'Kernel#require'에는 파일 이름 확장자가 필요하지 않습니다. 'Kernel#require'는 동일한 파일 경로의 다중 로드를 방지합니다. `Kernel#load`는 현재 `$SAFE` 레벨에서 지정된 파일을 로드하는 반면, `Kernel#require`는 `$SAFE` 레벨이 0인 지정된 파일을 로드합니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### private 메소드의 호출은 정의 클래스 내에서 public 메소드의 호출과 어떻게 다릅니까?

클래스 객체 자체나 현재 객체 `self`가 아니라 명시적 수신자 객체 없이 기능적으로 참조해야 합니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 메서드에 별칭을 지정하려는 이유는 무엇입니까?

일부 문제의 맥락에서 더 읽기 쉽고 적절한 기존 방법에 대한 동의어를 생성하거나 기존 방법에 기능을 추가합니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### ...의 가치는 무엇일까?

```ruby
defined? foo
#=> "local-variable"
defined? bar
#=> nil
```
    
`foo`는 적어도 인터프리터에 의해 읽혀졌으므로 정의되고 `nil` 값이 할당됩니다. 그러나 `bar`는 작성된 적이 없기 때문에 처음부터 정의된 적이 없습니다.

###### Source

* https://www.toptal.com/ruby/interview-questions

[[↑] 맨 위로](#Ruby)
### 메소드 끝의 쾅 '!'은 무엇을 의미합니까?

조심해야 한다는 것입니다. 이 명명 규칙을 사용하는 메서드는 일반적으로 수신기 개체에서 *mutation을 수행합니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 아래 코드에서 "upcased" 변수의 값은 무엇입니까?

아래와 같이 'puts'를 살펴보겠습니다.

```ruby
>> puts "Hi"
Hi
=> nil
```

끝에 'nil'이 있음을 주목하세요. 이것은 'puts'의 반환 값입니다. 결국 'puts'는 '메소드'이므로 무언가를 반환해야 합니다. 발생하면 항상 'nil'을 반환합니다. 문자열 출력은 메서드가 수행하는 작업입니다.

마찬가지로 문제의 코드를 평가하면 결과가 `["ONE", "TWO", "THREE"]`일 것으로 예상하는 것이 일반적인 학습자 실수이지만 이해할 수 있습니다. 실은 `[무,무,무]'입니다. 블록을 통과할 때마다 블록은 `puts`의 반환 값이 `nil`이 되도록 평가합니다.

###### Source

* https://www.toptal.com/ruby/interview-questions

[[↑] 맨 위로](#Ruby)
### 블록 호출은 메서드 호출과 어떻게 다릅니까?

예상보다 많은 인수가 메서드에 전달되면 Ruby에서 예외가 발생합니다. 블록은 단순히 추가 값을 무시합니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 클래스와 모듈에 대한 세 가지 수준의 메서드 액세스 제어를 알려주실 수 있습니까? 그들은 방법에 대해 무엇을 의미합니까?

**모든 메서드**는 액세스 제어와 상관없이 **클래스 내에서** 액세스할 수 있습니다. 그러나 외부 발신자는 어떻습니까?

* _Public_ 메서드는 **액세스 제어 없음**을 적용합니다. 모든 범위에서 호출할 수 있습니다.
* _Protected_ 메서드는 **동일한 클래스의 다른 개체**에만 액세스할 수 있습니다.
* _Private_ 메서드는 **현재 개체의 컨텍스트** 내에서만 액세스할 수 있습니다.

```ruby
class AccessLevel
  def something_interesting
    another = AccessLevel.new
    another.public_method
    another.protected_method
    another.private_method
  end

  def public_method
    puts "Public method. Nice to meet you."
  end

  protected

  def protected_method
    puts "Protected method. Sweet!"
  end

  private 

  def private_method
    puts "Incoming exception!"
  end
end

AccessLevel.new.something_interesting
 #=> Public method.  Nice to meet you.
 #=> Protected method.  Sweet!
 #=> NoMethodError: private method ‘private_method’ called for
 #=>  #<AccessLevel:0x898c8>
```

###### Source

* https://gist.github.com/ryansobol/5252653#file-gistfile1-md

[[↑] 맨 위로](#Ruby)
### `#==`와 `#equal?`의 차이점은 무엇인가요?

`#==`는 일반 비교를 수행하고 클래스 간에 다르게 구현되는 반면 `#equal?`은 `BasicObject`에 정의되어 개체 ID를 비교합니다. 따라서 `#equal?`은 하위 클래스에서 재정의되어서는 안 됩니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 이 루비 관용구를 설명하라: a | = b

강력한 루비 개발자가 항상 사용하는 일반적인 관용구입니까?
```ruby
# a = b when a == false
# otherwise a remains unchanged
a || a = b # (Kudos to Markus Prinz)
```

```ruby
a = 1
b = 2
a ||= b #=> a = 1
```

```ruby
a = nil
b = 2
a ||= b #=> a = 2
```

```ruby
a = false
b = 2
a ||= b #=> a = 2
```

###### Source

* https://gist.github.com/ryansobol/5252653#file-gistfile1-md

[[↑] 맨 위로](#Ruby)
### self은 무슨 뜻인가요?

`self` _always_는 현재 객체를 나타냅니다. 그러나 이 질문은 루비에서 **클래스도 객체이기 때문에 보기보다 어렵습니다.

```ruby
class WhatIsSelf
  def test
    puts "At the instance level, self is #{self}"
  end

  def self.test
    puts "At the class level, self is #{self}"
  end
end

WhatIsSelf.test 
 #=> At the class level, self is WhatIsSelf

WhatIsSelf.new.test 
 #=> At the instance level, self is #<WhatIsSelf:0x28190>
```

이 짧은 스니펫은 두 가지를 나타냅니다.

- _class 수준_에서 self는 **class**이며 이 경우 WhatIsSelf입니다.
- _인스턴스 수준_에서 self는 **컨텍스트의 인스턴스**입니다. 이 경우 메모리 위치 0x28190에 있는 WhatIsSelf의 인스턴스입니다.

###### Source

* https://gist.github.com/ryansobol/5252653#file-gistfile1-md

[[↑] 맨 위로](#Ruby)
### Proc란?

기본적으로 Procs는 코드를 포함하는 **익명 메서드**(또는 이름 없는 함수)입니다. 그것들은 변수 안에 배치될 수 있고 다른 객체나 스칼라 값처럼 **전달**할 수 있습니다. **Proc.new**, **lambda** 및 **blocks**(yield 키워드에 의해 호출됨)에 의해 생성됩니다.

**참고:** Procs와 람다는 ruby ​​v1.8.6에서 미묘하지만 중요한 [차이점](http://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Method_Calls#Understanding_blocks.2C_Procs_and_methods)이 있습니다. 그러나 면접에서 후보자가 이러한 핵심적인 세부 사항에 대해 이야기할 것이라고는 기대하지 않습니다. (Noah Thorp에게 경의를 표합니다)

```ruby
# wants a proc, a lambda, AND a block
def three_ways(proc, lambda, &block)
  proc.call
  lambda.call
  yield # like block.call
  puts "#{proc.inspect} #{lambda.inspect} #{block.inspect}"
end

anonymous = Proc.new { puts "I'm a Proc for sure." }
nameless  = lambda { puts "But what about me?" }

three_ways(anonymous, nameless) do
  puts "I'm a block, but could it be???"
end
 #=> I'm a Proc for sure.
 #=> But what about me?
 #=> I'm a block, but could it be???
 #=> #<Proc:0x00089d64> #<Proc:0x00089c74> #<Proc:0x00089b34>
```

###### Source

* https://gist.github.com/ryansobol/5252653#file-gistfile1-md

[[↑] 맨 위로](#Ruby)
### `#==`와 `#eql?`의 차이점은 무엇인가요?

`#eql?`은 때때로 대체 같음입니다. `Hash`는 `#eql?`을 사용하여 해시 키 동등성을 테스트합니다. `Numeric` 유형은 `#==`에서 유형 변환을 수행하지만 `#eql?`에서는 그렇지 않으므로 `#eql?`이 이 경우 `#==`보다 더 엄격한 비교를 수행합니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### Ruby에서 closure 설명

클로저는 변수 바인딩과 함께 호출 가능한 함수인 객체입니다. 개체는 개체 정의 시 범위에 있던 지역 변수에 대한 액세스를 유지합니다.

Ruby의 클로저는 참조로 변수를 유지합니다. 클로저는 또한 변수의 수명을 연장합니다. 변수에 대한 클로저의 참조는 동적으로 바인딩됩니다. 즉, 'Proc' 개체가 실행될 때 변수 값이 확인됩니다.

폐쇄를 변경하는 것도 가능합니다. 클로저의 바인딩은 `#binding`을 사용하여 변경할 수 있습니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### `Array#map`과 `Array#each`의 차이점은 무엇인가요?

* `Array#each` 메소드는 배열의 요소를 반복하고 매번 제공된 블록을 실행합니다. 그러나 영향을 받지 않은 원래 배열을 반환합니다.
* `Array#map`은 제공된 블록에서 반환된 값을 포함하는 요소의 새 배열을 반환합니다. 또한 원래 배열에는 영향을 미치지 않습니다.

###### Source

* https://www.toptal.com/ruby/interview-questions

[[↑] 맨 위로](#Ruby)
### 반복자 란 무엇입니까?

컨테이너 요소의 순회를 허용하는 개체입니다. Ruby에서 반복자는 일반적으로 yield 문을 사용하는 모든 메서드로 간주됩니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### `throw/catch` and `raise/rescue`의 차이점은 무엇입니까?

'throw' 및 'catch'는 일치하는 기호를 인수로 받아들이고 'raise' 및 'rescue'가 예외를 발생시키고 처리하는 데 사용되는 제어 흐름 구조로 간주되어야 합니다. 'throw'와 'catch'는 일반적으로 사용되지 않지만 'raise'와 'rescue'를 사용한 예외 처리는 자주 사용됩니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 반복되는 'elsif' 문에 비해 case 문의 단점은 무엇입니까?

명령문은 일반적으로 전체 제어 구조의 완전한 리팩토링 없이 수정에 저항합니다. 쉼표로 구분된 여러 식이 단일 when 절과 연결된 경우 case 문은 혼동될 수 있습니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### "super"를 호출하는 것과 "super()"를 호출하는 것의 차이점은 무엇입니까?

* 'super'를 호출하면 자식 메서드에 전달된 것과 동일한 인수를 사용하여 부모 메서드를 호출합니다. 따라서 자식 메서드에 전달된 인수가 부모가 기대하는 것과 일치하지 않으면 오류가 발생합니다.

* 'super()' 호출은 예상대로 인수 없이 부모 메서드를 호출합니다. 항상 그렇듯이 코드에서 명시적인 것은 좋은 것입니다.

###### Source

* https://www.toptal.com/ruby/interview-questions

[[↑] 맨 위로](#Ruby)
### 블록에 중괄호 구문을 사용하는 것과 비교하여 언제 `do`/`end` 구문을 사용할 수 있습니까?  

블록에 대한 `do`/`end` 구문은 일반적으로 여러 줄 문에 사용됩니다. 다른 규칙은 값을 반환하는 블록에는 중괄호 구문을 사용하고 시스템 상태를 어떻게든 변경하고 값을 반환하지 않는 블록에는 `do`/`end` 구문을 사용하는 것입니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 차이점을 설명하시오

`+=` 연산자는 변수를 새 값으로 다시 초기화하므로 `a += b`는 `a = a + b`와 같습니다.

따라서 `+=`가 값을 변경하는 것처럼 보일 수 있지만 실제로는 _new_ 객체를 생성하고 이전 변수를 새 객체로 가리키는 것입니다.

다음과 같이 작성하면 이해하기 쉬울 것입니다.

```ruby
foo = "foo"
foo2 = foo
foo.concat "bar"

puts foo
  => "foobar"
puts foo2
  => "foobar"

foo += "baz"
puts foo
  => "foobarbaz"
puts foo2
  => "foobar"
```

('foo'와 'foo2'의 'object_id'를 조사하면 새로운 객체가 생성되고 있음을 알 수 있습니다.)

그 차이는 성능에 영향을 미치며 예상과 다른 돌연변이 행동을 가집니다.

###### Source

* https://www.toptal.com/ruby/interview-questions

[[↑] 맨 위로](#Ruby)
### 블록에 두 개의 인수가 전달되었지만 하나의 인수만 허용하면 어떻게 됩니까?

아무것도. 첫 번째 인수만 블록에 전달됩니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 정확히 어떻게 작동합니까?

매개변수 앞에 `&`가 포함되어 전달되면(블록으로 사용됨을 나타냄) Ruby는 블록으로 사용할 수 있도록 하기 위해 `to_proc`을 호출합니다. `Symbol#to_proc`은 전달되는 모든 항목에 대해 해당 이름의 메서드를 호출하는 `Proc`를 매우 쉽게 반환하므로 우리의 작은 속기 트릭이 작동할 수 있습니다.

###### Source

* https://www.toptal.com/ruby/interview-questions

[[↑] 맨 위로](#Ruby)
### 아래 코드 줄이 유효한 Ruby 코드입니까? 그렇다면 어떤 역할을 합니까?

예, 유효합니다. 그 역할을 이해하는 방법은 다음과 같습니다.

`->` 연산자는 Ruby의 함수 유형 중 하나인 새로운 Proc를 생성합니다. (`->`는 종종 "stabby proc"이라고 합니다. 람다인 새로운 Proc 인스턴스를 생성하기 때문에 "stabby lambda"라고도 합니다. 모든 람다가 Proc이지만 모든 Proc가 람다는 아닙니다. 둘 사이에 약간의 차이가 있습니다.)

이 특정 Proc는 하나의 매개변수(즉, `a`)를 취합니다. Proc가 호출되면 Ruby는 'pa' 블록을 실행합니다. 이는 'puts(a.inspect)'와 동일합니다(미묘하지만 유용한 차이점이 있기 때문에 'p'가 디버깅에 'puts'보다 더 나은 경우가 있습니다. ). 따라서 이 Proc는 전달된 문자열을 단순히 인쇄합니다.

Proc에서 'call' 메서드를 사용하거나 대괄호 구문을 사용하여 Proc를 호출할 수 있으므로 이 코드 줄도 Proc를 호출하고 "Hello World" 문자열을 전달합니다.

따라서 이 모든 것을 종합하면 이 코드 줄은 (a) 단일 매개변수 `a`를 사용하여 출력하는 Proc를 생성하고 (b) 해당 Proc를 호출하고 "Hello world" 문자열을 전달합니다. 간단히 말해서 이 코드 줄은 "Hello World"를 인쇄합니다.

###### Source

* https://www.toptal.com/ruby/interview-questions

[[↑] 맨 위로](#Ruby)
### 다음 각 코드 줄의 결과는 무엇입니까?

코드의 처음 세 줄은 예상대로 모두 10을 출력합니다.
다음 두 줄의 코드는 예상대로 모두 3을 출력합니다.

그러나 코드의 마지막 줄(즉, `sum (1,2)`)은 다음과 같은 결과를 낳습니다.

```ruby
    syntax error, unexpected ',', expecting ')'
    sum (1, 2)
           ^
```    

문제는 메서드 이름과 여는 괄호 사이의 공백입니다. 공백 때문에 Ruby 파서는 `(1, 2)`가 단일 인수를 나타내는 표현식이라고 생각하지만 `(1, 2)`는 유효한 Ruby 표현식이 아니므로 오류가 발생합니다.

단일 인수 메소드(위의 `timesTwo` 메소드로 표시됨)에서는 문제가 발생하지 않습니다. 단일 값은 유효한 표현식이기 때문입니다(예: `(5)`는 단순히 5로 평가되는 유효한 표현식임).

###### Source

* https://www.toptal.com/ruby/interview-questions

[[↑] 맨 위로](#Ruby)
### 할당되지 않은 상수는 어떻게 됩니까?

존재하지 않습니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 블록이 객체입니까?

아니오. 블록은 인터프리터의 구문 구조입니다. 블록은 Proc 개체로 변환될 수 있습니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 이 두 코드 조각의 주요 차이점은 무엇입니까?

* Java 메소드 **only**는 문자열을 인수로 받아들이고 **only**는 부울을 반환하는 동안...

* ruby ​​메소드는 **모든 객체**를 허용하고 **무엇이든 반환할 수 있지만** 이 경우 예외 없이 실행되면 **부울**을 반환합니다.

###### Source

* https://gist.github.com/ryansobol/5252653#file-gistfile1-md

[[↑] 맨 위로](#Ruby)
### 임의의 길이의 피보나치 수열을 배열로 출력하는 Ruby 코드 한 줄을 작성하십시오.

이를 수행하는 방법은 여러 가지가 있지만 가능한 한 가지 대답은 다음과 같습니다.

```ruby
(1. .20).inject([0, 1]) { | fib | fib << fib.last(2).inject(: +)}
```

시퀀스 `fib`로 올라갈 때 배열의 마지막 두 요소를 합산하거나 `inject(:+)`하고 결과를 `fib`의 끝에 추가합니다.

참고: `inject`는 `reduce`의 별칭입니다.

###### Source

* https://www.toptal.com/ruby/interview-questions

[[↑] 맨 위로](#Ruby)
### Ruby가 메소드 오버로딩을 지원하지 않는 이유는 무엇입니까?

*오버로딩*은 Ruby에서는 이해가 되지 않는 용어입니다. 기본적으로 "정적 인수 기반 디스패치"와 동의어이지만 Ruby에는 정적 디스패치가 전혀 없습니다. 따라서 Ruby가 인수 기반의 정적 디스패치를 지원하지 않는 이유는 정적 디스패치, 마침표를 지원하지 않기 때문입니다. 인수 기반이든 아니든 모든 종류의 정적 디스패치를 지원하지 않습니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 메소드는 객체인가?

그러나 'Method' 개체는 물론 개체입니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### `BasicObject#instance_eval`과 `BasicObject#instance_exec`의 차이점은 무엇인가요?

`BasicObject#instance_exec`는 문자열이 아닌 블록만 수락할 수 있으며 인수를 수락하고 블록에 전달할 수 있으므로 블록에서 값이 오는 매개변수를 사용하여 수신자 객체의 컨텍스트에서 블록을 평가할 수 있습니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### `Object#dup`과 `#clone`의 차이점은 무엇입니까?

`#clone`은 객체의 고정 상태와 객체의 모든 싱글톤 메서드를 복사하지만 `Object#dup`은 둘 다 복사하지 않습니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 고유 클래스 란 무엇입니까?

개체와 연결된 익명 클래스입니다. 객체의 싱글톤 메소드는 연관된 고유 클래스의 인스턴스 메소드입니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 언제 `LocalJumpError`가 발생합니까?

블록이 제공되지 않을 때 양보를 시도할 때 일반적으로 이 예외가 발생할 수 있습니다. 사전적으로 둘러싸는 메서드가 이미 반환된 'Proc' 객체에서 반환을 시도하는 경우와 같이 이미 반환된 메서드에서 반환을 시도할 때도 이 예외가 발생할 수 있습니다.

###### Source

* https://raw.githubusercontent.com/undr/ruby-trivia/master/README.md

[[↑] 맨 위로](#Ruby)
### 루비에서 '확장'과 '포함'의 차이점은 무엇입니까?

* `include`는 지정된 모듈 메서드에서 대상 클래스의 인스턴스 메서드로 혼합됩니다.
* `extend`는 지정된 모듈 메서드를 대상 클래스의 클래스 메서드로 혼합합니다.

다음 클래스 정의가 제공됩니다.

```ruby
module ReusableModule
  def module_method
    puts "Module Method: Hi there! I'm a module method"
  end
end

class ClassThatIncludes
  include ReusableModule
end
class ClassThatExtends
  extend ReusableModule
end
```

'ClassThatIncludes'가 작동하는 방식은 다음과 같습니다.

```sh
# A class method does not exist
>> ClassThatIncludes.module_method
NoMethodError: undefined method `module_method' for ClassThatIncludes:Class

# A valid instance method exists
>> ClassThatIncludes.new.module_method
Module Method: Hi there! I'm a module method
=> nil
```

'ClassThatExtends'가 작동하는 방식은 다음과 같습니다.

```sh
# A valid class method exists
>> ClassThatExtends.module_method
Module Method: Hi there! I'm a module method
=> nil

# An instance method does not exist
ClassThatExtends.new.module_method
NoMethodError: undefined method `module_method' for #<ClassThatExtends:0x007ffa1e0317e8>
```

`object.extend ExampleModule`은 `ExampleModule` 메소드를 객체의 싱글톤 메소드로 사용할 수 있도록 한다는 점을 언급해야 합니다.

###### Source

* https://www.toptal.com/ruby/interview-questions

[[↑] 맨 위로](#Ruby)
