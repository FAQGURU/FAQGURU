## SQL

[기본 키란 무엇입니까?](#기본-키란-무엇입니까)

[임시 테이블 정의 ](#임시-테이블-정의-)

[view란 무엇입니까?](#view란-무엇입니까)

[로컬 임시 테이블과 전역 임시 테이블의 차이점은 무엇입니까?](#로컬-임시-테이블과-전역-임시-테이블의-차이점은-무엇입니까)

[blocking이란?](#blocking이란)

[WHERE 절과 HAVING 절의 차이점은 무엇입니까?](#WHERE-절과-HAVING-절의-차이점은-무엇입니까)

[외래 키란 무엇입니까?](#외래-키란-무엇입니까)

[정규화란 무엇입니까?](#정규화란-무엇입니까)

[기본값이 있는 열을 기존 테이블에 어떻게 추가할 수 있습니까?](#기본값이-있는-열을-기존-테이블에-어떻게-추가할-수-있습니까)

[기본값이란 무엇입니까?](#기본값이란-무엇입니까)

[내부 조인과 외부 조인의 차이점은 무엇입니까?](#내부-조인과-외부-조인의-차이점은-무엇입니까)

[INNER JOIN ON 대 WHERE 절 토론](#INNER-JOIN-ON-대-WHERE-절-토론)

[클러스터형 인덱스와 비클러스터형 인덱스의 차이점은 무엇입니까?](#클러스터형-인덱스와-비클러스터형-인덱스의-차이점은-무엇입니까)

[SQL SELECT에서 IF…THEN을 어떻게 수행합니까?](#SQL-SELECT에서-IFTHEN을-어떻게-수행합니까)

[SQL 테이블에서 중복 값 찾기](#SQL-테이블에서-중복-값-찾기)

[해시 테이블 인덱스는 어떻게 작동합니까?](#해시-테이블-인덱스는-어떻게-작동합니까)

[저장 프로시저를 사용하면 어떤 이점이 있습니까?](#저장-프로시저를-사용하면-어떤-이점이-있습니까)

[비정규화란 무엇입니까?](#비정규화란-무엇입니까)

[테이블에서 처음 5개의 레코드를 선택하는 방법은 무엇입니까?](#테이블에서-처음-5개의-레코드를-선택하는-방법은-무엇입니까)

[ACID 속성 정의](#ACID-속성-정의)

[데이터베이스 인덱스가 성능에 어떤 도움이 됩니까?](#데이터베이스-인덱스가-성능에-어떤-도움이-됩니까)

[UNION과 UNION ALL의 차이점은 무엇입니까?](#UNION과-UNION-ALL의-차이점은-무엇입니까)

[커서는 어떻게 작동합니까?](#커서는-어떻게-작동합니까)

[SQL Server의 SELECT에서 어떻게 업데이트합니까?](#SQL-Server의-SELECT에서-어떻게-업데이트합니까)

["INNER JOIN"과 "OUTER JOIN"의 차이점은 무엇입니까?](#INNER-JOIN과-OUTER-JOIN의-차이점은-무엇입니까)

[테이블에서 데이터를 삭제하면 테이블 크기가 줄어듭니까?](#테이블에서-데이터를-삭제하면-테이블-크기가-줄어듭니까)

[SQL Server의 함수 및 저장 프로시저 설명](#SQL-Server의-함수-및-저장-프로시저-설명)

[행 생성자란 무엇입니까?](#행-생성자란-무엇입니까)

[JOIN과 UNION의 차이점은 무엇입니까?](#JOIN과-UNION의-차이점은-무엇입니까)

[대조란 무엇입니까?](#대조란-무엇입니까)

[자르기와 삭제의 차이점 설명](#자르기와-삭제의-차이점-설명)

[B-트리 인덱스는 어떻게 작동합니까?](#B-트리-인덱스는-어떻게-작동합니까)

[통계란 무엇입니까?](#통계란-무엇입니까)

[교착 상태는 어떻게 해결됩니까?](#교착-상태는-어떻게-해결됩니까)

[UNION, MINUS 및 INTERSECT의 차이점은 무엇입니까?](#UNION-MINUS-및-INTERSECT의-차이점은-무엇입니까)

[파일 그룹이란 무엇입니까?](#파일-그룹이란-무엇입니까)

[SQL에서 JOIN으로 UPDATE 문을 수행하려면 어떻게 해야 합니까?](#SQL에서-JOIN으로-UPDATE-문을-수행하려면-어떻게-해야-합니까)

[자르기 및 삭제 작업은 ID에 어떤 영향을 줍니까?](#자르기-및-삭제-작업은-ID에-어떤-영향을-줍니까)

[사용자 정의 함수와 저장 프로시저의 사용법 차이 설명](#사용자-정의-함수와-저장-프로시저의-사용법-차이-설명)

[연결된 서버란 무엇입니까?](#연결된-서버란-무엇입니까)

[SQL을 사용하여 테이블을 어떻게 전치할 수 있습니까(행을 열로 또는 그 반대로 변경)?](#SQL을-사용하여-테이블을-어떻게-전치할-수-있습니까행을-열로-또는-그-반대로 변경)

[인덱스가 없으면 어떻게 될까요?](#인덱스가-없으면-어떻게-될까요)

[트리거의 이름 유형](#트리거의-이름-유형)

[DMV와 DMF는 무엇입니까?](#DMV와-DMF는-무엇입니까)

[기본 키와 고유 키의 차이점은 무엇입니까?](#기본-키와-고유-키의-차이점은-무엇입니까)

[SQL 테이블에서 중복 값 삭제](#SQL-테이블에서-중복-값-삭제)

[데이터베이스 인덱스를 보유하는 데 드는 비용은 얼마입니까?](#데이터베이스-인덱스를-보유하는-데-드는-비용은-얼마입니까)

[ROWNUM 없이 SQL에서 행 번호를 생성하는 방법](#ROWNUM-없이-SQL에서-행-번호를-생성하는-방법)

[exclusive lock과 update lock의 차이점 설명](#exclusive-lock과-update-lock의-차이점-설명)

[저장 프로시저의 결과를 임시 테이블에 삽입](#저장-프로시저의-결과를-임시-테이블에-삽입)

[다른 유형의 인덱스는 무엇입니까?](#다른-유형의-인덱스는-무엇입니까)

[해시 인덱스의 몇 가지 단점을 말하십시오.](#해시-인덱스의-몇-가지-단점을-말하십시오)

[데이터베이스 인덱싱은 어떻게 작동합니까?](#데이터베이스-인덱싱은-어떻게-작동합니까)

[기본 키 제약 조건과 고유 키 제약 조건은 어떻게 null에 영향을 줍니까?](#기본-키-제약-조건과-고유-키-제약-조건은-어떻게-null에-영향을-줍니까)

[각 GROUP BY 그룹의 첫 번째 행을 선택하시겠습니까(그룹당 최대 n개 문제)?](#각-GROUP-BY-그룹의-첫-번째-행을-선택하시겠습니까그룹당-최대-n개-문제)

[낙관적 잠금과 비관적 잠금이란 무엇입니까?](#낙관적-잠금과-비관적-잠금이란-무엇입니까)



### 기본 키란 무엇입니까?

**PRIMARY KEY** 제약 조건은 데이터베이스 테이블 내의 행에 대한 고유 식별자입니다. 모든 테이블에는 각 행을 고유하게 식별하기 위한 기본 키 제약 조건이 있어야 하며 각 테이블에 대해 하나의 기본 키 제약 조건만 생성할 수 있습니다. 기본 키 제약 조건은 엔터티 무결성을 적용하는 데 사용됩니다.

###### Source

* https://github.com/dhaval1406/SQL

[[↑] 맨 위로](#SQL)
### 임시 테이블 정의 

간단히 말해서 임시 테이블은 임시 저장 구조입니다. 그게 무슨 의미죠? 기본적으로 임시 테이블을 사용하여 데이터를 임시로 저장하여 데이터가 대상 형식에 도달하기 전에 데이터를 조작하고 변경할 수 있습니다.

###### Source

* https://github.com/dhaval1406/SQL

[[↑] 맨 위로](#SQL)
### view란 무엇입니까?

**view** 는 단순히 여러 물리적 또는 "실제" 테이블의 요소로 구성된 가상 테이블입니다. 보기는 여러 테이블을 함께 조인하거나 백그라운드 서버 프로세스에 있는 모든 테이블에 대한 액세스를 제어하는 ​​데 가장 일반적으로 사용됩니다.

###### Source

* https://github.com/dhaval1406/SQL

[[↑] 맨 위로](#SQL)
### 로컬 임시 테이블과 전역 임시 테이블의 차이점은 무엇입니까?

* **Local tables** 은 서버에 연결된 현재 사용자가 액세스할 수 있습니다. 이러한 테이블은 사용자가 서버에서 연결을 끊으면 사라집니다.
* 반면 **Global temp** 테이블은 연결에 관계없이 모든 사용자가 사용할 수 있습니다. 이러한 테이블은 모든 전역 연결이 닫힐 때까지 활성 상태를 유지합니다.

###### Source

* https://github.com/dhaval1406/SQL

[[↑] 맨 위로](#SQL)
### blocking이란?

SQL Server 차단은 한 연결이 레코드에 대한 잠금을 보유하고 다른 연결이 레코드를 가져오거나 레코드를 업데이트하려고 할 때 발생합니다.

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### WHERE 절과 HAVING 절의 차이점은 무엇입니까?

- WHERE 절은 집계되지 않은 정적 열에만 적용할 수 있습니다.
- 집계된 열에 HAVING을 사용해야 합니다.

###### Source

* https://github.com/dhaval1406/SQL

[[↑] 맨 위로](#SQL)
### 외래 키란 무엇입니까?

**FOREIGN KEY** 제약 조건은 해당 데이터 값이 있는 테이블 간의 링크를 파괴하는 모든 작업을 방지합니다. 한 테이블의 외래 키는 다른 테이블의 기본 키를 가리킵니다. 외래 키는 해당 값을 가진 기본 키가 없을 때 외래 키 값이 있는 행을 남기는 작업을 방지합니다. 외래 키 제약 조건은 참조 무결성을 적용하는 데 사용됩니다.

###### Source

* https://github.com/dhaval1406/SQL

[[↑] 맨 위로](#SQL)
### 정규화란 무엇입니까?

중복 데이터를 제거하고 데이터 종속성을 유지하는 프로세스입니다.

###### Source

* https://github.com/dhaval1406/SQL

[[↑] 맨 위로](#SQL)
### 기본값이 있는 열을 기존 테이블에 어떻게 추가할 수 있습니까?

Consider:
```sql
ALTER TABLE SomeTable
        ADD SomeCol Bit NULL --Or NOT NULL.
 CONSTRAINT D_SomeTable_SomeCol --When Omitted a Default-Constraint Name is autogenerated.
    DEFAULT (0)--Optional Default-Constraint.
WITH VALUES --Add if Column is Nullable and you want the Default Value for Existing Records.
```
열이 null을 허용하는 경우 null은 기존 행에 사용되는 값입니다.

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### 기본값이란 무엇입니까?

**Default** 을 사용하면 해당 열의 값이 설정되지 않은 경우 해당 열에 값을 추가할 수 있습니다. 기본값은 숫자 및 날짜/시간 필드에 정의할 수 있습니다. 타임스탬프 및 IDENTITY 열에는 정의할 수 없습니다.

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### 내부 조인과 외부 조인의 차이점은 무엇입니까?

- 내부 조인은 두 테이블에 일치하는 항목이 하나 이상 있을 때 행을 반환합니다.
- 외부 조인은 두 테이블의 일치하는 행과 하나 또는 두 테이블의 일치하지 않는 행을 반환합니다.

###### Source

* https://github.com/dhaval1406/SQL

[[↑] 맨 위로](#SQL)
### INNER JOIN ON 대 WHERE 절 토론

'INNER JOIN'은 사용해야 하는 ANSI 구문입니다. INNER JOIN은 사람의 가독성에 도움이 되며 이것이 최우선입니다. 필요할 때마다 OUTER JOIN으로 쉽게 교체할 수도 있습니다.

암시적 조인(여러 `FROM` 테이블 포함)은 쿼리에 더 많은 테이블을 추가하기 시작해야 하는 경우 훨씬 더 혼란스럽고 읽기 어렵고 유지 관리하기 어려워집니다.

###### Source

* https://stackoverflow.com/questions/3800551/select-first-row-in-each-group-by-group

[[↑] 맨 위로](#SQL)
### 클러스터형 인덱스와 비클러스터형 인덱스의 차이점은 무엇입니까?

* **clustered index** 는 테이블의 레코드가 물리적으로 저장되는 방식을 재정렬하는 특수한 유형의 인덱스입니다. 따라서 테이블에는 클러스터형 인덱스가 하나만 있을 수 있습니다. 클러스터형 인덱스의 리프 노드에는 데이터 페이지가 포함됩니다.
	
* **non clustered index** 는 인덱스의 논리적 순서가 디스크에 있는 행의 물리적 저장 순서와 일치하지 않는 특수한 유형의 인덱스입니다. 클러스터되지 않은 인덱스의 리프 노드는 데이터 페이지로 구성되지 않습니다. 대신 리프 노드에는 인덱스 행이 포함됩니다.

###### Source

* https://github.com/dhaval1406/SQL

[[↑] 맨 위로](#SQL)
### SQL SELECT에서 IF…THEN을 어떻게 수행합니까?

CASE 문은 SQL의 IF에 가장 가깝고 모든 버전의 SQL Server에서 지원됩니다:
```sql
SELECT CAST( 
   CASE
      WHEN
         Obsolete = 'N' 
         or InStock = 'Y' 
      THEN 1 
      ELSE 0 
   END AS bit) as Saleable, * 
FROM
   Product
```

###### Source

* https://stackoverflow.com/questions/63447/how-do-i-perform-an-if-then-in-an-sql-select

[[↑] 맨 위로](#SQL)
### SQL 테이블에서 중복 값 찾기

두 열을 모두 그룹화하기만 하면 됩니다:
```sql
SELECT
    name, email, COUNT(*) as CountOf
FROM
    users
GROUP BY
    name, email
HAVING 
    COUNT(*) > 1
```

###### Source

* https://stackoverflow.com/questions/2594829/finding-duplicate-values-in-a-sql-table

[[↑] 맨 위로](#SQL)
### 해시 테이블 인덱스는 어떻게 작동합니까?

해시 인덱스를 사용하는 이유는 해시 테이블이 값을 조회할 때 매우 효율적이기 때문입니다. 따라서 문자열과 동일한지 비교하는 쿼리는 해시 인덱스를 사용하는 경우 값을 매우 빠르게 검색할 수 있습니다.

예를 들어 질문의 쿼리는 `Employee_Name` 열에 생성된 해시 인덱스의 이점을 얻을 수 있습니다.
해시 인덱스가 작동하는 방식은 열 값이 해시 테이블의 키가 되고 해당 키에 매핑된 실제 값이 테이블의 행 데이터에 대한 포인터가 된다는 것입니다. 해시 테이블은 기본적으로 연관 배열이므로 일반적인 항목은 "Abc => 0x28939"와 같이 보일 것입니다. 여기서 0x28939는 Abc가 메모리에 저장된 테이블 행에 대한 참조입니다. 해시 테이블 인덱스에서 "Abc"와 같은 값을 찾고 메모리의 행에 대한 참조를 다시 얻는 것은 `Employee_Name` 열에서 값이 "Abc"인 모든 행을 찾기 위해 테이블을 스캔하는 것보다 분명히 훨씬 빠릅니다. .

###### Source

* https://stackoverflow.com/questions/1108/how-does-database-indexing-work

[[↑] 맨 위로](#SQL)
### 저장 프로시저를 사용하면 어떤 이점이 있습니까?

* 저장 프로시저는 네트워크 트래픽과 대기 시간을 줄여 애플리케이션 성능을 높일 수 있습니다.
* 저장 프로시저 실행 계획을 재사용하여 SQL Server 메모리에 캐시된 상태로 유지하여 서버 오버헤드를 줄일 수 있습니다.
* 저장 프로시저는 코드 재사용을 촉진하는 데 도움이 됩니다.
* 저장 프로시저는 논리를 캡슐화할 수 있습니다. 클라이언트에 영향을 주지 않고 저장 프로시저 코드를 변경할 수 있습니다.
* 저장 프로시저는 데이터에 더 나은 보안을 제공합니다.	
	

###### Source

* https://github.com/dhaval1406/SQL

[[↑] 맨 위로](#SQL)
### 비정규화란 무엇입니까?

중복 데이터를 _추가_하여 데이터베이스의 성능을 향상시키는 과정입니다.

###### Source

* https://github.com/dhaval1406/SQL

[[↑] 맨 위로](#SQL)
### 테이블에서 처음 5개의 레코드를 선택하는 방법은 무엇입니까?

```sql
-- SQL Server
SELECT TOP 5 * FROM EMP;
```
```sql
-- Oracle
SELECT * FROM EMP WHERE ROWNUM <= 5;
```

```sql
-- Generic
SELECT  name  FROM EMPLOYEE o
			   WHERE (SELECT count(*) FROM EMPLOYEE i WHERE i.name < o.name) < 5
```

###### Source

* https://github.com/dhaval1406/SQL

[[↑] 맨 위로](#SQL)
### ACID 속성 정의

* **Atomicity**: 데이터베이스 수정에 대해 모두 또는 없음 규칙을 보장합니다.
* **Consistency**: 데이터 값은 데이터베이스 전체에서 일관됩니다.
* **Isolation**: 두 트랜잭션은 서로 독립적이라고 합니다.
* **Durability**: 서버 장애 시에도 데이터가 손실되지 않습니다.

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### 데이터베이스 인덱스가 성능에 어떤 도움이 됩니까?

인덱스를 갖는 요점은 본질적으로 검사해야 하는 테이블의 레코드/행 수를 줄임으로써 검색 쿼리의 속도를 높이는 것입니다. 인덱스는 테이블의 특정 열에 대한 값을 저장하는 데이터 구조(가장 일반적으로 B-트리)입니다.

###### Source

* https://stackoverflow.com/questions/1108/how-does-database-indexing-work

[[↑] 맨 위로](#SQL)
### UNION과 UNION ALL의 차이점은 무엇입니까?

- UNION 작업은 결과 데이터 세트에서 고유한 레코드만 반환합니다.  
- UNION ALL은 하나 이상의 행이 서로 중복되더라도 모든 행을 반환합니다.

###### Source

* https://github.com/dhaval1406/SQL

[[↑] 맨 위로](#SQL)
### 커서는 어떻게 작동합니까?

**Cursor**는 행 단위로 데이터를 조작하는 데 사용되는 데이터베이스 개체입니다. 관련된 단계:
* 커서 선언
* 커서 열기
* 커서에서 행 가져오기
* 가져온 행 처리
* 커서 닫기
* 커서 할당을 해제합니다.

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### SQL Server의 SELECT에서 어떻게 업데이트합니까?

```sql
UPDATE
    Table_A
SET
    Table_A.col1 = Table_B.col1,
    Table_A.col2 = Table_B.col2
FROM
    Some_Table AS Table_A
    INNER JOIN Other_Table AS Table_B
        ON Table_A.id = Table_B.id
WHERE
    Table_A.col3 = 'cool'
```
or using `MERGE`:
```sql
MERGE INTO YourTable T
   USING other_table S 
      ON T.id = S.id
         AND S.tsql = 'cool'
WHEN MATCHED THEN
   UPDATE 
      SET col1 = S.col1, 
          col2 = S.col2;
```

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### "INNER JOIN"과 "OUTER JOIN"의 차이점은 무엇입니까?

매우 일반적인 경우인 중복이 없는 열에 조인한다고 가정합니다:

* A와 B의 **inner join**은 A 교차 B의 결과, 즉 벤 다이어그램 교차의 내부 부분을 제공합니다.
* A와 B의 **outer join**은 A 결합 B의 결과, 즉 벤 다이어그램 결합의 외부 부분을 제공합니다.
* **left outer join**은 A의 모든 행과 B의 모든 공통 행을 제공합니다.
* **right outer join**은 B의 모든 행과 A의 모든 공통 행을 제공합니다.
* **full outer join**은 A와 B의 합집합, 즉 A의 모든 행과 B의 모든 행을 제공합니다. A의 무언가가 B의 해당 데이텀을 갖지 않는 경우 B 부분은 null 및 그 반대의 경우도 마찬가지입니다.



<div class="text-center"/>
<img src="https://i.stack.imgur.com/1UKp7.png" class="img-fluid"/>
</div>


###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### 테이블에서 데이터를 삭제하면 테이블 크기가 줄어듭니까?

아니요 테이블 크기는 줄어들지 않습니다. 실제로 SQL Server는 해당 행을 사용 가능한 행으로 표시합니다. 새 데이터를 삽입하면 사용 가능한 행이 업데이트되고 데이터 삽입에 따라 테이블 크기가 변경됩니다. 데이터가 삽입되지 않으면 잠시 후 행이 제거됩니다.

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### SQL Server의 함수 및 저장 프로시저 설명

SP와 UDF의 차이점은 다음과 같습니다:

```sh
+---------------------------------+----------------------------------------+
| Stored Procedure (SP)           | Function (UDF - User Defined           |
|                                 | Function)                              |
+---------------------------------+----------------------------------------+
| SP can return zero , single or  | Function must return a single value    |
| multiple values.                | (which may be a scalar or a table).    |
+---------------------------------+----------------------------------------+
| We can use transaction in SP.   | We can't use transaction in UDF.       |
+---------------------------------+----------------------------------------+
| SP can have input/output        | Only input parameter.                  |
| parameter.                      |                                        |
+---------------------------------+----------------------------------------+
| We can call function from SP.   | We can't call SP from function.        |
+---------------------------------+----------------------------------------+
| We can't use SP in SELECT/      | We can use UDF in SELECT/ WHERE/       |
| WHERE/ HAVING statement.        | HAVING statement.                      |
+---------------------------------+----------------------------------------+
| We can use exception handling   | We can't use Try-Catch block in UDF.   |
| using Try-Catch block in SP.    |                                        |
+---------------------------------+----------------------------------------+
```

###### Source

* https://stackoverflow.com/questions/1179758/function-vs-stored-procedure-in-sql-server

[[↑] 맨 위로](#SQL)
### 행 생성자란 무엇입니까?

**ROW Constructor** 또는 **Table Value Constructor**는 `VALUES()` 절을 사용하여 행 집합을 생성하는 것을 의미합니다. 이를 통해 단일 DML 문에서 여러 데이터 행을 지정할 수 있습니다.

```sql
SELECT * 
FROM (
VALUES
    (1, 'cust 1', '(111) 111-1111', 'address 1'),
    (2, 'cust 2', '(222) 222-2222', 'address 2'),
    (3, 'cust 3', '(333) 333-3333', 'address 3'),
    (4, 'cust 4', '(444) 444-4444', 'address 4'),
    (5, 'cust 5', '(555) 555-5555', 'address 5')
) AS C (CustID, CustName, phone, addr);

```

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### JOIN과 UNION의 차이점은 무엇입니까?

- SQL JOIN을 사용하면 두 테이블 간의 주어진 조건에 따라 다른 테이블의 레코드를 "조회"할 수 있습니다.
- UNION 작업을 통해 2개의 유사한 데이터 세트를 추가하여 소스 데이터 세트의 모든 데이터를 포함하는 결과 데이터 세트를 생성할 수 있습니다. Union은 가입 조건을 요구하지 않습니다.

###### Source

* https://github.com/dhaval1406/SQL

[[↑] 맨 위로](#SQL)
### 대조란 무엇입니까?

**Collation** 은 데이터 정렬 및 비교 방법을 결정하는 일련의 규칙을 정의합니다. 데이터 정렬이 정의되면 다시 생성하거나 엔터티를 삭제할 때까지 데이터 정렬 규칙을 변경할 수 없습니다.

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### 자르기와 삭제의 차이점 설명

* **Delete** 명령은 WHERE 절과 함께 제공한 조건에 따라 테이블에서 행을 제거합니다.

* **Truncate**는 실제로 테이블에서 모든 행을 제거하며 truncate 명령을 실행한 후 테이블에 데이터가 없습니다.

###### Source

* https://github.com/dhaval1406/SQL

[[↑] 맨 위로](#SQL)
### B-트리 인덱스는 어떻게 작동합니까?

**B- tree**가 인덱스에서 가장 많이 사용되는 데이터 구조인 이유는 검색, 삭제 및 삽입이 _logmatic time_에 모두 수행될 수 있기 때문에 시간 효율적이기 때문입니다. 그리고 B-트리가 더 일반적으로 사용되는 또 다른 주요 이유는 B-트리 내부에 저장된 데이터를 정렬할 수 있기 때문입니다. RDBMS는 일반적으로 인덱스에 실제로 사용되는 데이터 구조를 결정합니다. 그러나 특정 RDBMS를 사용하는 일부 시나리오에서는 실제로 인덱스를 작성할 때 데이터베이스에서 사용할 데이터 구조를 지정할 수 있습니다.

###### Source

* https://stackoverflow.com/questions/1108/how-does-database-indexing-work

[[↑] 맨 위로](#SQL)
### 통계란 무엇입니까?

**Statistics**는 낮은 리소스 소비로 쿼리를 얼마나 잘 실행할 수 있는지 정의합니다.

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### 교착 상태는 어떻게 해결됩니까?

교착 상태는 SQL Server에서 자동으로 해결됩니다. 오버헤드가 적은 프로세스를 식별하고 그에 따라 해당 프로세스와 관련된 트랜잭션을 롤백합니다.

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### UNION, MINUS 및 INTERSECT의 차이점은 무엇입니까?

- UNION은 2개 테이블의 결과를 결합하고 결과 세트에서 중복 레코드를 제거합니다.
- MINUS 연산자는 두 테이블 사이에서 사용될 때 두 번째 테이블에 있는 행을 제외하고 첫 번째 테이블의 모든 행을 제공합니다.
- INTERSECT 연산자는 2개의 결과 집합 사이에 일치하거나 공통된 행만 반환합니다.

###### Source

* https://github.com/dhaval1406/SQL

[[↑] 맨 위로](#SQL)
### 파일 그룹이란 무엇입니까?

**파일 그룹**은 단일 단위로 관리되는 데이터 파일의 모음입니다. 데이터베이스당 하나의 기본 파일 그룹과 많은 사용자 정의 파일 그룹을 가질 수 있습니다. 로그 파일은 구조의 차이로 인해 파일 그룹의 일부가 될 수 없습니다.

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### SQL에서 JOIN으로 UPDATE 문을 수행하려면 어떻게 해야 합니까?

```sql
update u
set u.assid = s.assid
from ud u
    inner join sale s on
        u.id = s.udid
```
Without `JOIN`:
```sql
update ud 
set assid = sale.assid
from sale
where sale.udid = id
```


###### Source

* https://stackoverflow.com/questions/1293330/how-can-i-do-an-update-statement-with-join-in-sql

[[↑] 맨 위로](#SQL)
### 자르기 및 삭제 작업은 ID에 어떤 영향을 줍니까?

_resets_ ID를 기본 값으로 자르고 _delete_는 기본 값으로 재설정하지 않습니다.

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### 사용자 정의 함수와 저장 프로시저의 사용법 차이 설명

**User defined functions**는 쿼리의 어느 곳에서나 사용할 수 있습니다. 즉, 저장 프로시저가 할 수 없는 where/have/select 섹션 내.

**Note:** 저장 프로시저는 삽입 문과 함께 사용할 수 있습니다. UDF는 조인 작업에서도 사용할 수 있으며 UDF는 다른 테이블과 조인할 수 있는 테이블을 반환하는 데 사용할 수 있습니다.

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### 연결된 서버란 무엇입니까?

**Linked server** 는 이기종 서버와의 연결을 용이하게 합니다. 연결된 서버를 사용하여 원격 서버의 데이터를 조작하고 로컬 데이터와 통합할 수도 있습니다.

저장 프로시저: `sp_linkedservers`는 서버에서 사용할 수 있는 연결된 서버 목록을 제공합니다.

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### SQL을 사용하여 테이블을 어떻게 전치할 수 있습니까(행을 열로 또는 그 반대로 변경)?

SQL에서 수행하는 일반적인 방법은 CASE 문 또는 DECODE 문을 사용하는 것입니다.

###### Source

* https://github.com/dhaval1406/SQL

[[↑] 맨 위로](#SQL)
### 인덱스가 없으면 어떻게 될까요?

데이터베이스 소프트웨어는 말 그대로 `Employee` 테이블의 모든 단일 행을 살펴보고 해당 행의 `Employee_Name`이 'Abc'인지 확인해야 합니다. 그리고 우리는 그 안에 'Abc'라는 이름을 가진 모든 행을 원하기 때문에 Abc라는 이름을 가진 다른 행이 있을 수 있기 때문에 'Abc'라는 이름의 행을 하나만 찾으면 찾는 것을 멈출 수 없습니다. 따라서 마지막 행까지 모든 행을 검색해야 합니다. 즉, 이 시나리오에서 수천 개의 행을 데이터베이스에서 검사하여 이름이 'Abc'인 행을 찾아야 합니다. 이것을 **전체 테이블 스캔**이라고 합니다.

###### Source

* https://stackoverflow.com/questions/1108/how-does-database-indexing-work

[[↑] 맨 위로](#SQL)
### 트리거의 이름 유형

다음과 같은 세 가지 유형의 트리거가 있습니다:
   1. **DML Triggers**: 두 가지 종류가 있습니다.
   	 * _Instead of Triggers_: 삽입, 업데이트 또는 삭제와 같은 트리거 작업 대신 호출됩니다.
        * _After Triggers_: 삽입, 업데이트 또는 삭제와 같은 트리거 작업 후에 호출됩니다.
   2. **DDL Triggers**: 이는 DDL 문에 대해 호출됩니다. 이들은 항상 _After Triggers_입니다.
   3. **Logon Triggers**: 로그온 이벤트가 발생하고 사용자 세션이 설정되기 전에 호출됩니다.

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### DMV와 DMF는 무엇입니까?

**데이터 관리 보기** 및 **데이터 관리 기능**은 SQL Server의 상태에 대한 정보를 제공합니다. 즉, SQL Server의 상태에 대한 정보를 제공하는 역할을 합니다.

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### 기본 키와 고유 키의 차이점은 무엇입니까?

기본 키와 고유 키는 모두 정의된 열의 고유성을 적용합니다.

그러나 기본적으로 기본 키는 열에 _클러스터형 인덱스_를 생성하며, 여기서 고유성은 기본적으로 _비클러스터형_ 인덱스를 생성합니다.

또 다른 주요 차이점은 _primary 키는 NULL을 허용하지 않지만 고유 키는 하나의 NULL만 허용한다는 것입니다_.	

###### Source

* https://github.com/dhaval1406/SQL

[[↑] 맨 위로](#SQL)
### SQL 테이블에서 중복 값 삭제

Consider:
```sql
DELETE FROM users
WHERE id IN (
    SELECT id/*, name, email*/
    FROM users u, users u2
    WHERE u.name = u2.name AND u.email = u2.email AND u.id > u2.id
)
```
또는 `PARTITION BY` 사용:
```sql
DELETE d
    FROM @YourTable d
        INNER JOIN (SELECT
                        y.id,y.name,y.email,ROW_NUMBER() OVER(PARTITION BY y.name,y.email ORDER BY y.name,y.email,y.id) AS RowRank
                        FROM @YourTable y
                            INNER JOIN (SELECT
                                            name,email, COUNT(*) AS CountOf
                                            FROM @YourTable
                                            GROUP BY name,email
                                            HAVING COUNT(*)>1
                                        ) dt ON y.name=dt.name AND y.email=dt.email
                   ) dt2 ON d.id=dt2.id
        WHERE dt2.RowRank!=1
SELECT * FROM @YourTable
```

###### Source

* https://stackoverflow.com/questions/2594829/finding-duplicate-values-in-a-sql-table

[[↑] 맨 위로](#SQL)
### 데이터베이스 인덱스를 보유하는 데 드는 비용은 얼마입니까?

공간을 차지하며 테이블이 클수록 인덱스도 커집니다. 인덱스의 또 다른 성능 저하는 해당 테이블의 행을 추가, 삭제 또는 업데이트할 때마다 인덱스에 대해 동일한 작업을 수행해야 한다는 사실입니다. 인덱스는 인덱스가 포함하는 테이블 열에 있는 것과 동일한 최대 분 데이터를 포함해야 함을 기억하십시오.

일반적으로 인덱싱된 열의 데이터가 자주 쿼리되는 경우에만 테이블에 인덱스를 생성해야 합니다.

###### Source

* https://stackoverflow.com/questions/1108/how-does-database-indexing-work

[[↑] 맨 위로](#SQL)
### ROWNUM 없이 SQL에서 행 번호를 생성하는 방법

Consider:
```sql
SELECT name, sal, (SELECT COUNT(*)  FROM EMPLOYEE i WHERE o.name >= i.name) row_num
		FROM EMPLOYEE o 
		order by row_num
```

###### Source

* https://github.com/dhaval1406/SQL

[[↑] 맨 위로](#SQL)
### exclusive lock과 update lock의 차이점 설명

* **exclusive lock**의 경우 해당 행이나 테이블에 대해 다른 잠금을 획득할 수 없습니다. 모든 프로세스는 잠금을 보유하고 있는 프로세스가 잠금을 해제할 때까지 기다려야 합니다.

* **update lock**의 경우 행이나 레코드를 읽는 동안 해당 행이나 레코드와 연결된 다른 잠금을 가질 수 있습니다. 레코드를 업데이트하는 경우 업데이트 잠금이 자체적으로 단독 잠금으로 변경되고 잠금이 해제될 때까지 다른 프로세스는 해당 행에 대한 잠금을 얻을 수 없습니다.

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### 저장 프로시저의 결과를 임시 테이블에 삽입

OPENROWSET을 사용하면 됩니다. 또한 sp_configure 코드를 포함하여 애드혹 분산 쿼리를 사용하도록 설정했습니다.

```sql
CREATE PROC getBusinessLineHistory
AS
BEGIN
    SELECT * FROM sys.databases
END
GO

sp_configure 'Show Advanced Options', 1
GO
RECONFIGURE
GO
sp_configure 'Ad Hoc Distributed Queries', 1
GO
RECONFIGURE
GO

SELECT * INTO #MyTempTable FROM OPENROWSET('SQLNCLI', 'Server=(local)\SQL2008;Trusted_Connection=yes;',
     'EXEC getBusinessLineHistory')

SELECT * FROM #MyTempTable
```

###### Source

* https://stackoverflow.com/questions/653714/insert-results-of-a-stored-procedure-into-a-temporary-table

[[↑] 맨 위로](#SQL)
### 다른 유형의 인덱스는 무엇입니까?

**R-tree** 데이터 구조를 사용하는 인덱스는 일반적으로 _spatial_ 문제를 해결하는 데 사용됩니다. 예를 들어 "내 2km 이내의 모든 스타벅스 찾기"와 같은 쿼리는 데이터베이스 테이블이 R-트리 인덱스를 사용하는 경우 향상된 성능을 보여줄 수 있는 쿼리 유형입니다.

다른 유형의 인덱스는 **비트맵 인덱스**로, 부울 값(예: true 및 false)을 포함하는 열에서 잘 작동하지만 이러한 값의 많은 인스턴스(기본적으로 선택도가 낮은 열)에서 잘 작동합니다.

###### Source

* https://www.programmerinterview.com/index.php/database-sql/what-is-an-index/

[[↑] 맨 위로](#SQL)
### 해시 인덱스의 몇 가지 단점을 말하십시오.

해시 테이블은 정렬된 데이터 구조가 아니며 해시 인덱스가 도움이 되지 않는 쿼리 유형이 많이 있습니다. 예를 들어, 40세 미만의 모든 직원을 찾고 싶다고 가정합니다. 해시 테이블 인덱스로 어떻게 그렇게 할 수 있습니까? 해시 테이블은 키 값 쌍을 찾는 데만 적합하기 때문에 불가능합니다. 즉, _equality_만 확인하는 쿼리를 의미합니다.

###### Source

* https://stackoverflow.com/questions/1108/how-does-database-indexing-work

[[↑] 맨 위로](#SQL)
### 데이터베이스 인덱싱은 어떻게 작동합니까?

**인덱싱**은 여러 필드에서 여러 레코드를 정렬하는 방법입니다. 테이블의 필드에 인덱스를 생성하면 필드 값과 관련된 레코드에 대한 포인터를 보유하는 다른 데이터 구조(디스크에 저장됨)가 생성됩니다. 그런 다음 이 인덱스 구조가 정렬되어 log2 N 블록 액세스가 있는 이진 검색을 수행할 수 있습니다. 또한 키가 아닌 필드가 주어지면 데이터가 정렬되기 때문에 더 높은 값이 발견되면 나머지 테이블에서 중복 값을 검색할 필요가 없습니다.

인덱스를 갖는 요점은 본질적으로 검사해야 하는 테이블의 레코드/행 수를 줄임으로써 검색 쿼리의 속도를 높이는 것입니다. 인덱스는 테이블의 특정 열에 대한 값을 저장하는 데이터 구조(가장 일반적으로 B-트리 또는 해시 테이블)입니다.

이진 검색의 특성을 감안할 때 데이터의 **cardinality or uniqueness**이 중요합니다. 카디널리티가 2인 필드에 대한 인덱싱은 데이터를 절반으로 분할하는 반면 카디널리티가 1,000이면 약 1,000개의 레코드를 반환합니다.

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### 기본 키 제약 조건과 고유 키 제약 조건은 어떻게 null에 영향을 줍니까?

기본 키 제약 조건은 지정된 열에 null 값을 허용하지 않는 반면 고유 키 제약 조건은 여러 null 값이 아닌 단일 null 값을 허용합니다.

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
### 각 GROUP BY 그룹의 첫 번째 행을 선택하시겠습니까(그룹당 최대 n개 문제)?

Consider:
```sql
WITH summary AS (
    SELECT p.id, 
           p.customer, 
           p.total, 
           ROW_NUMBER() OVER(PARTITION BY p.customer 
                                 ORDER BY p.total DESC) AS rk
      FROM PURCHASES p)
SELECT s.*
  FROM summary s
 WHERE s.rk = 1
```

###### Source

* https://stackoverflow.com/questions/3800551/select-first-row-in-each-group-by-group

[[↑] 맨 위로](#SQL)
### 낙관적 잠금과 비관적 잠금이란 무엇입니까?

**Optimistic Locking**은 레코드를 읽고 버전 번호를 기록하고(날짜, 타임스탬프 또는 체크섬/해시를 포함하는 다른 방법) 레코드를 쓰기 전에 버전이 변경되지 않았는지 확인하는 전략입니다. 뒤. 레코드를 다시 쓸 때 버전의 업데이트를 필터링하여 원자성인지 확인합니다. (즉, 버전을 확인하고 디스크에 레코드를 쓸 때 사이에 업데이트되지 않음) 한 번의 히트로 버전을 업데이트합니다.

레코드가 지저분한 경우(즉, 다른 버전) 트랜잭션을 중단하면 사용자가 다시 시작할 수 있습니다.

이 전략은 세션을 위해 데이터베이스에 대한 연결을 반드시 유지할 필요가 없는 대용량 시스템 및 3계층 아키텍처에 가장 적합합니다. 이 상황에서 클라이언트는 풀에서 연결을 가져오기 때문에 실제로 데이터베이스 잠금을 유지할 수 없으며 한 액세스에서 다음 액세스로 동일한 연결을 사용하지 않을 수 있습니다.

**Pessimistic Locking**은 녹음을 마칠 때까지 독점적으로 사용할 수 있도록 레코드를 잠그는 것입니다. 낙관적 잠금보다 무결성이 훨씬 우수하지만 교착 상태를 방지하려면 애플리케이션 설계에 주의해야 합니다. 비관적 잠금을 사용하려면 데이터베이스에 대한 직접 연결(일반적으로 2계층 클라이언트 서버 응용 프로그램의 경우와 같이) 또는 연결과 독립적으로 사용할 수 있는 외부에서 사용 가능한 트랜잭션 ID가 필요합니다.

비관적 잠금의 단점은 리소스가 트랜잭션에서 처음 액세스된 시간부터 트랜잭션이 완료될 때까지 잠겨 있어 해당 시간 동안 다른 트랜잭션에서 액세스할 수 없다는 것입니다.

###### Source

* https://github.com/chetansomani/SQL-Interview-Questions

[[↑] 맨 위로](#SQL)
